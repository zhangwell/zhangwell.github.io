<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="data base," />










<meta name="description" content="引言：  针对面试的mysql数据库总结">
<meta name="keywords" content="data base">
<meta property="og:type" content="article">
<meta property="og:title" content="DataBase">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;index.html">
<meta property="og:site_name" content="Well">
<meta property="og:description" content="引言：  针对面试的mysql数据库总结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261820297.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261830802.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261842897.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261850318.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261860507.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261871063.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262283010.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262067821.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261930304.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261963108.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262116465.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262137053.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262151740.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262159079.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566262385992.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566263834174.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566264130165.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566265001814.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566264973315.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566268250911.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566268427287.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com&#x2F;1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com&#x2F;ac929ea3-daca-40ec-9e95-4b2fa6678243.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com&#x2F;5bb1b38a-527e-4802-a385-267dadbd30ba.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com&#x2F;14389ea4-8d96-4e96-9f76-564ca3324c1e.png">
<meta property="og:updated_time" content="2019-11-25T06:22:37.912Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;DataBase&#x2F;1566261820297.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/24/DataBase/"/>





  <title>DataBase | Well</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Well</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">huo dao lao xue dao lao</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/DataBase/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Well">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DataBase</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-24T09:35:17+08:00">
                2019-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Summary/" itemprop="url" rel="index">
                    <span itemprop="name">Interview Summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p> 引言：</p>
<blockquote>
<p>针对面试的mysql数据库总结</p>
</blockquote>
<a id="more"></a>

<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p><strong>客观存在并可相互区别的事物</strong>称之为实体。可以看成是Java类</p>
<p>例子：(课程关系表)就是一个实体。</p>
<h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p><strong>实体所具有的某一特性</strong>称之为属性。可以看成是Java类的成员变量。属性在数据库中又称为字段（或者是列）</p>
<p>例子：(课程名)，(课程号)、(学时)就是属性名。</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>除含有属性名所在的行之外的其他行称之为元组。</strong></p>
<p><strong>下面的每一行数据都称之为元组</strong><br>(C401001 数据结构 70)<br>(C401002 操作系统 80)<br>(C402001 计算机原理 60)</p>
<h3 id="码-Key"><a href="#码-Key" class="headerlink" title="码(Key)"></a>码(Key)</h3><p><strong>码也被称作是关键字。它可以唯一标识一个实体</strong>。</p>
<p>候选码和主码：</p>
<ul>
<li>候选码：如果一组属性集能唯一地标识一个关系中的元组而又不含有多余的属性，则称该属性集为该关系的候选码 。（<strong>候选码可能不止有一个</strong>）</li>
<li>主码：用户选定的那个候选键称为主键</li>
</ul>
<p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p>
<p>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</p>
<p>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系名和其属性集合的组合称之为关系模式</strong>。</p>
<p>关系模式例子：课程关系表(课程号,课程名,学时)</p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>关系模型要求元组的每一个分量都是原子性的，也就是说，它必须属于某种元素类型，如Integer、String等等，不能是列，集合，记录，数组！</p>
<p><strong>域就代表着该元组中每个分量的类型</strong>，例如：课程号:string,课程名:string,学时:int</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2019/11/24/DataBase/1566261820297.png" alt="1566261820297"></p>
<p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p>
<p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p>
<p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p>
<h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么使用索引？"><a href="#为什么使用索引？" class="headerlink" title="为什么使用索引？"></a>为什么使用索引？</h3><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p>
<p><strong>磁盘文件存储</strong></p>
<p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p>
<p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p>
<h3 id="什么样的信息能够称为索引？"><a href="#什么样的信息能够称为索引？" class="headerlink" title="什么样的信息能够称为索引？"></a>什么样的信息能够称为索引？</h3><p>主键，唯一键，普通键，有一定区分性</p>
<p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p>
<blockquote>
<p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p>
</blockquote>
<p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p>
<blockquote>
<p>唯一键不是主键，但主键有不可重复性</p>
<p>一张表可以有多个唯一键，但只能有一个主键</p>
</blockquote>
<p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p>
<h3 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h3><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p>
<p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p>
<p><img src="/2019/11/24/DataBase/1566261830802.png" alt="1566261830802"></p>
<p>特性：</p>
<p><img src="/2019/11/24/DataBase/1566261842897.png" alt="1566261842897"></p>
<p><img src="/2019/11/24/DataBase/1566261850318.png" alt="1566261850318"></p>
<p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p>
<p>B+树：</p>
<p><img src="/2019/11/24/DataBase/1566261860507.png" alt="1566261860507"></p>
<p>结论：B+树更适合，原因：</p>
<ul>
<li><p><strong>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</strong></p>
</li>
<li><p><strong>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</strong></p>
</li>
<li><p><strong>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</strong></p>
</li>
</ul>
<p><strong>Hash索引了解一下：</strong></p>
<p>缺点：</p>
<ul>
<li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li>
<li>无法运用索引值来排序</li>
<li>不能利用部分索引键查询</li>
<li>不能避免表扫描，哈希值可能重复，需要全表扫描</li>
<li>大量hash值相等时，效率很底。</li>
</ul>
<p>密集索引和稀疏索引</p>
<p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列（属性）的数据。</p>
<blockquote>
<p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p>
</blockquote>
<p>稀疏索引：叶子节点仅保存了键位信息（索引键位）及其主键。</p>
<p>InnoDB的索引</p>
<p><img src="/2019/11/24/DataBase/1566261871063.png" alt="1566261871063"></p>
<h3 id="如何定位并优化sql？"><a href="#如何定位并优化sql？" class="headerlink" title="如何定位并优化sql？"></a>如何定位并优化sql？</h3><ul>
<li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p>
<p><img src="/2019/11/24/DataBase/1566262283010.png" alt="1566262283010"></p>
</li>
<li><p>使用explain等工具分析sql</p>
<p><img src="/2019/11/24/DataBase/1566262067821.png" alt="1566262067821"></p>
<ul>
<li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li>
<li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li>
</ul>
<p><img src="/2019/11/24/DataBase/1566261930304.png" alt="1566261930304"></p>
<ul>
<li>字段：extra，如图</li>
</ul>
<p><img src="/2019/11/24/DataBase/1566261963108.png" alt="1566261963108"></p>
</li>
<li><p>修改sql或者尽量让sql走索引</p>
<ul>
<li>改用索引查</li>
</ul>
<p><img src="/2019/11/24/DataBase/1566262116465.png" alt="1566262116465"></p>
<ul>
<li>添加索引</li>
</ul>
<p><img src="/2019/11/24/DataBase/1566262137053.png" alt="1566262137053"></p>
</li>
<li><p>使用fore_index()测试那个索引更好</p>
</li>
</ul>
<h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p><img src="/2019/11/24/DataBase/1566262151740.png" alt="1566262151740"></p>
<p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p>
<p>索引建立的越多越好吗？</p>
<p><img src="/2019/11/24/DataBase/1566262159079.png" alt="1566262159079"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>首先需要了解：</p>
<ul>
<li>对于<code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li>
<li><strong>MyISAM</strong>在执行查询语句<code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（<code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li>
</ul>
<p>其次需要了解：</p>
<p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p>
<ul>
<li>也就是说，<strong>InnoDB的行锁是基于索引的</strong>！</li>
</ul>
<p>Myisam：表级锁，不支持行级锁</p>
<p>InnoDB：默认行级锁，支持表级锁，</p>
<blockquote>
<p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p>
</blockquote>
<p>无论表锁还是行锁，默认都分为共享锁和排他锁</p>
<p><img src="/2019/11/24/DataBase/1566262385992.png" alt="1566262385992"></p>
<h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>MyISAM</p>
<ul>
<li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li>
<li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li>
<li>适合没有事务的</li>
</ul>
<p>InnoDB</p>
<ul>
<li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li>
<li>支持事务的系统</li>
</ul>
<p>数据库锁分类：</p>
<ul>
<li>按粒度划分：表级锁，行级锁，页级锁</li>
<li>按级别划分：共享锁，排他锁</li>
<li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li>
<li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li>
<li><strong>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</strong></li>
</ul>
<h3 id="乐观锁和悲观锁："><a href="#乐观锁和悲观锁：" class="headerlink" title="乐观锁和悲观锁："></a>乐观锁和悲观锁：</h3><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p>
<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul>
<li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li>
<li>实现方式：使用数据库中的锁机制</li>
</ul>
</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<ul>
<li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li>
<li>实现方式：使用version版本或者时间戳</li>
</ul>
</li>
</ul>
<h2 id="事务隔离与锁"><a href="#事务隔离与锁" class="headerlink" title="事务隔离与锁"></a>事务隔离与锁</h2><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><p>不同的隔离级别对锁的使用是不同的，<strong>锁的应用最终导致不同事务的隔离级别</strong></p>
<p>ACID：原子性，一致性，隔离性，持久性</p>
<p>事务的隔离性以及各级别下的并发问题</p>
<p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p>
<p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事务读取另一个事务未提交数据</p>
<p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p>
<p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p>
<p><img src="/2019/11/24/DataBase/1566263834174.png" alt="1566263834174"></p>
<h3 id="InnoDB引擎的隔离与锁"><a href="#InnoDB引擎的隔离与锁" class="headerlink" title="InnoDB引擎的隔离与锁"></a>InnoDB引擎的隔离与锁</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种<strong>具体方式</strong>，用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别。</p>
<blockquote>
<p>而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
</blockquote>
<blockquote>
<p>InnoDB<strong>基于行锁</strong>实现了MVCC多版本并发控制，MVCC在隔离级别下的<code>Read committed</code>和<code>Repeatable read</code>下工作。MVCC能够实现<strong>读写不阻塞</strong>！</p>
</blockquote>
<h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><ul>
<li>通过一定机制生成一个数据请求<strong>时间点的一致性数据快照（Snapshot)</strong>，并用这个快照来提供一定级别（<strong>语句级或事务级</strong>）的<strong>一致性读取</strong>。从用户的角度来看，好像是<strong>数据库可以提供同一数据的多个版本</strong>。</li>
<li>版本号<ul>
<li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号：事务开始时的系统版本号。<ul>
<li>版本号用来和查询到的每行记录的版本号进行比较。</li>
</ul>
</li>
</ul>
</li>
<li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：<ul>
<li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li>
</ul>
</li>
</ul>
<h4 id="Read-committed实现"><a href="#Read-committed实现" class="headerlink" title="Read committed实现"></a><code>Read committed</code>实现</h4><p>原理：快照读机制，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p>
<p><code>Read committed</code><strong>避免脏读</strong>的做法其实很简单：</p>
<ul>
<li><strong>在读取的时候生成一个版本号，直到事务其他commit被修改了之后，才会有新的版本号</strong>，读取时会对比版本号</li>
</ul>
<p>过程：</p>
<ul>
<li>事务A读取了记录(生成版本号)</li>
<li>事务B修改了记录(此时加了写锁)</li>
<li>事务A再读取的时候，<strong>是依据最新的版本号来读取的</strong>(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据。</li>
</ul>
<h4 id="Repeatable-read实现"><a href="#Repeatable-read实现" class="headerlink" title="Repeatable read实现"></a><code>Repeatable read</code>实现</h4><p><code>Read committed</code>会出现不可重复读：<strong>一个事务可以看到其他事务所做的修改</strong>。</p>
<p>例如，<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样（危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了）</strong></p>
<blockquote>
<p><code>Read committed</code>是<strong>语句级别</strong>（执行语句）的快照！<strong>每次读取的都是当前最新的数据行版本</strong>！</p>
</blockquote>
<blockquote>
<p><code>Repeatable read</code>避免不可重复读是<strong>事务级别</strong>的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。</p>
</blockquote>
<p>总结：事务开启时使用系统版本作为事务版本号，事务开启时数据行更新后使用最新数据行版本号，<strong>读提交实现</strong>使用数据行版本号的比对，确保每次commit被修改了之后，才会有新的版本号，通过版本号实现隔离；<strong>重复读实现</strong>对比的是快照中的事务版本号，即在 <strong>tempdb</strong> 中存储原始行的副本，和为该行添加事务版本号，通过版本号实现隔离。</p>
<h3 id="InnoDB在可重复度隔离级别下是如何避免幻读？"><a href="#InnoDB在可重复度隔离级别下是如何避免幻读？" class="headerlink" title="InnoDB在可重复度隔离级别下是如何避免幻读？"></a>InnoDB在可重复度隔离级别下是如何避免幻读？</h3><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><p>表象：快照度（非阻塞读）——伪MVCC</p>
<p>内在：next-key锁（行锁+gap锁）</p>
<p><img src="/2019/11/24/DataBase/1566264130165.png" alt="1566264130165"></p>
<p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p>
<p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p>
<p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p>
<ol>
<li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li>
<li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li>
</ol>
<p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p>
<p><img src="/2019/11/24/DataBase/1566265001814.png" alt="1566265001814"></p>
<p>再次修改为（11，32，45）时会发生：</p>
<p><img src="/2019/11/24/DataBase/1566264973315.png" alt="1566264973315"></p>
<ol start="3">
<li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li>
</ol>
<p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p>
<p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>next-key锁（record锁+gap锁）</p>
<ul>
<li><p>record锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</p>
</li>
<li><p>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</p>
</li>
<li><p>next-key锁：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10],(10, 11],(11, 13],(13, 20],(20, +∞)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p>
<p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p>
<ul>
<li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li>
<li>如果where条件部分命中或者未命中，就会加上gap锁</li>
</ul>
<p>gap锁会出现在非唯一索引或者不走索引的当前读中</p>
<p>非唯一索引：</p>
<p><img src="/2019/11/24/DataBase/1566268250911.png" alt="1566268250911"></p>
<p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p>
<p>不走索引</p>
<p><img src="/2019/11/24/DataBase/1566268427287.png" alt="1566268427287"></p>
<p>会对所有gap上锁，类似表锁，也能防止幻读。</p>
<p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><strong>在我们书写SQL语句的时候，其实书写的顺序、策略会影响到SQL的性能，虽然实现的功能是一样的，但是它们的性能会有些许差别。</strong></p>
<p>因此，下面就讲解在书写SQL的时候，怎么写比较好。</p>
<hr>
<h3 id="选择最有效率的表名顺序"><a href="#选择最有效率的表名顺序" class="headerlink" title="选择最有效率的表名顺序"></a>选择最有效率的表名顺序</h3><p>数据库的解析器按照<strong>从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p>
<p>在FROM子句中包含多个表的情况下：</p>
<ul>
<li><strong>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</strong></li>
<li><strong>也就是说：选择记录条数最少的表放在最后</strong></li>
</ul>
<p>如果有3个以上的表连接查询：</p>
<ul>
<li><strong>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推</strong>。</li>
<li><strong>也就是说：被其他表所引用的表放在最后</strong></li>
</ul>
<p>例如：查询员工的编号，姓名，工资，工资等级，部门名</p>
<p><strong>emp表被引用得最多，记录数也是最多，因此放在form字句的最后面</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname</span><br><span class="line"><span class="keyword">from</span> salgrade,dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="WHERE子句中的连接顺序"><a href="#WHERE子句中的连接顺序" class="headerlink" title="WHERE子句中的连接顺序"></a>WHERE子句中的连接顺序</h3><p>数据库采用自<strong>右而左的顺序解析WHERE子句</strong>,根据这个原理,<strong>表之间的连接必须写在其他WHERE条件之左</strong>,那些<strong>可以过滤掉最大数量记录的条件必须写在WHERE子句的之右</strong>。</p>
<p><strong>emp.sal可以过滤多条记录，写在WHERE字句的最右边</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,dept.dname</span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal &gt; <span class="number">1500</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="SELECT子句中避免使用-号"><a href="#SELECT子句中避免使用-号" class="headerlink" title="SELECT子句中避免使用*号"></a>SELECT子句中避免使用*号</h3><p>我们当时学习的时候，星号是可以获取表中全部的字段数据的。</p>
<ul>
<li><strong>但是它要通过查询数据字典完成的，这意味着将耗费更多的时间</strong></li>
<li>使用*号写出来的SQL语句也不够直观。</li>
</ul>
<hr>
<h3 id="用TRUNCATE替代DELETE"><a href="#用TRUNCATE替代DELETE" class="headerlink" title="用TRUNCATE替代DELETE"></a>用TRUNCATE替代DELETE</h3><p>这里仅仅是：<strong>删除表的全部记录，除了表结构才这样做</strong>。</p>
<p><strong>DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快</strong></p>
<hr>
<h3 id="多使用内部函数提高SQL效率"><a href="#多使用内部函数提高SQL效率" class="headerlink" title="多使用内部函数提高SQL效率"></a>多使用内部函数提高SQL效率</h3><p><strong>例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。</strong></p>
<hr>
<h3 id="使用表或列的别名"><a href="#使用表或列的别名" class="headerlink" title="使用表或列的别名"></a>使用表或列的别名</h3><p><strong>如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了。。。</strong></p>
<hr>
<h3 id="多使用commit"><a href="#多使用commit" class="headerlink" title="多使用commit"></a>多使用commit</h3><p>comiit会释放回滚点…</p>
<hr>
<h3 id="善用索引"><a href="#善用索引" class="headerlink" title="善用索引"></a>善用索引</h3><p>索引就是为了提高我们的查询数据的，当表的记录量非常大的时候，我们就可以使用索引了。</p>
<hr>
<h3 id="SQL写大写"><a href="#SQL写大写" class="headerlink" title="SQL写大写"></a>SQL写大写</h3><p>我们在编写SQL 的时候，官方推荐的是使用大写来写关键字，<strong>因为Oracle服务器总是先将小写字母转成大写后，才执行</strong></p>
<hr>
<h3 id="避免在索引列上使用NOT"><a href="#避免在索引列上使用NOT" class="headerlink" title="避免在索引列上使用NOT"></a>避免在索引列上使用NOT</h3><p>因为Oracle服务器遇到NOT后，他就会停止目前的工作，转而执行全表扫描</p>
<h4 id="避免在索引列上使用计算"><a href="#避免在索引列上使用计算" class="headerlink" title="避免在索引列上使用计算"></a>避免在索引列上使用计算</h4><p>WHERE子句中，<strong>如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢</strong></p>
<h4 id="用-gt-替代-gt"><a href="#用-gt-替代-gt" class="headerlink" title="用 &gt;= 替代 &gt;"></a>用 <code>&gt;=</code> 替代 <code>&gt;</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">低效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt; <span class="number">3</span>   </span><br><span class="line">首先定位到DEPTNO=<span class="number">3</span>的记录并且扫描到第一个DEPT大于<span class="number">3</span>的记录</span><br><span class="line">高效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;= <span class="number">4</span>  </span><br><span class="line">直接跳到第一个DEPT等于<span class="number">4</span>的记录</span><br></pre></td></tr></table></figure>

<h4 id="用IN替代OR"><a href="#用IN替代OR" class="headerlink" title="用IN替代OR"></a>用IN替代OR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal = <span class="number">1500</span> <span class="keyword">or</span> sal = <span class="number">3000</span> <span class="keyword">or</span> sal = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span> (<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">800</span>);</span><br></pre></td></tr></table></figure>

<h4 id="总是使用索引的第一个列"><a href="#总是使用索引的第一个列" class="headerlink" title="总是使用索引的第一个列"></a>总是使用索引的第一个列</h4><p>如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> emp_sal_job_idex</span><br><span class="line"><span class="keyword">on</span> emp(sal,job);</span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp  </span><br><span class="line"><span class="keyword">where</span> job != <span class="string">'SALES'</span>;    </span><br><span class="line"></span><br><span class="line">上边就不使用索引了。</span><br></pre></td></tr></table></figure>

<h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul>
<li>1）范式优化： 比如消除冗余（节省空间。。）</li>
<li>2）反范式优化：比如适当加冗余等（减少join）</li>
<li>3）拆分表： 垂直拆分和水平拆分</li>
</ul>
<h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><p>money</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote>
<p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。<br>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>首先要明确的是：范式一到三是越来越严格的。<strong>满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</strong></li>
<li>第一范式：<strong>字段是最小的的单元不可再分</strong><ul>
<li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li>
</ul>
</li>
<li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul>
<li><strong>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的</strong></li>
<li>学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</li>
</ul>
</li>
<li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul>
<li><strong>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖</strong></li>
<li>比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</li>
</ul>
</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种基于数据表的一种<strong>虚表</strong></p>
<ul>
<li>（1）视图是一种虚表</li>
<li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li>
<li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li>
<li>（4）视图向用户提供基表数据的另一种表现形式</li>
<li>（5）视图没有存储真正的数据，真正的数据还是存储在基表中</li>
<li>（6）程序员虽然操作的是视图，但最终视图还会转成操作基表</li>
<li>（7）一个基表可以有0个或多个视图</li>
</ul>
<p>有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段…</p>
<p>那么把全部的字段都都显示给他们看，这是不合理的。</p>
<p>我们应该做到：<strong>他们想看到什么样的数据，我们就给他们什么样的数据…一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来…</strong></p>
<p><strong>视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便</strong>…</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure>

<h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h4 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h4><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img"></p>
<h4 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h4><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img"></p>
<h4 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h4><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img"></p>
<h4 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h4><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img"></p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="MySQL表设计要注意什么？"><a href="#MySQL表设计要注意什么？" class="headerlink" title="MySQL表设计要注意什么？"></a>MySQL表设计要注意什么？</h3><h4 id="主键是用自增还是UUID"><a href="#主键是用自增还是UUID" class="headerlink" title="主键是用自增还是UUID?"></a>主键是用自增还是UUID?</h4><p>肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p>
<h4 id="主键为什么不推荐有业务含义"><a href="#主键为什么不推荐有业务含义" class="headerlink" title="主键为什么不推荐有业务含义?"></a>主键为什么不推荐有业务含义?</h4><p>有如下两个原因</p>
<ul>
<li>因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</li>
<li>带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</li>
</ul>
<h4 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型?"></a>时间字段用什么类型?</h4><p>(1)<code>varchar</code>，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为<code>2013111</code>的数据，请问这是代表2013年1月11日，还是2013年11月1日？<br>其次，做时间比较运算，你需要用<code>STR_TO_DATE</code>等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p>
<p>(2)<code>timestamp</code>，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用<code>timestamp</code>类型存储的。<br>但是它有一个优势，<code>timestamp</code>类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TIME_ZONE</span> = <span class="string">"america/new_york"</span>;</span><br></pre></td></tr></table></figure>

<p>你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p>
<p>(3)<code>datetime</code>，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p>
<p>(4)<code>bigint</code>，也是8个字节，自己维护一个时间戳，表示范围比<code>timestamp</code>大多了，就是要自己维护，不大方便。</p>
<h4 id="为什么不直接存储图片、音频、视频等大容量内容"><a href="#为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="为什么不直接存储图片、音频、视频等大容量内容?"></a>为什么不直接存储图片、音频、视频等大容量内容?</h4><p>我们在实际应用中，都是用<code>HDFS</code>来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是<code>text</code>和<code>blob</code>类型。但是，我们在生产中，基本不用这两个类型！<br>主要原因有如下两点</p>
<ul>
<li>(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢</li>
<li>(2)<code>binlog</code>内容太多。因为你数据内容比较大，就会造成<code>binlog</code>内容比较多。大家也知道，主从同步是靠<code>binlog</code>进行同步，<code>binlog</code>太大了，就会导致主从同步效率问题！</li>
</ul>
<p>因此，不推荐使用<code>text</code>和<code>blob</code>类型！</p>
<h4 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL?"></a>字段为什么要定义为NOT NULL?</h4><p>(1)索引性能不好</p>
<blockquote>
<p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。                                                                              </p>
</blockquote>
<p>(2)查询会出现一些不可预料的结果<br>这里举一个例子，大家就懂了。假设，表结构如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>表数据是这样的</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">孤独烟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">肥朝</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p>你执行语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> table_2;</span><br></pre></td></tr></table></figure>

<p>你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。<br>记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.</p>
<h3 id="索引的特点"><a href="#索引的特点" class="headerlink" title="索引的特点"></a>索引的特点</h3><ul>
<li><strong>是一种快速查询表中内容的机制，</strong></li>
<li><strong>运用在表中某个些字段上，但存储时，独立于表之外</strong></li>
</ul>
<p>索引的特点</p>
<ul>
<li>索引一旦建立, <strong>DB管理系统会对其进行自动维护</strong>, 而且由DB管理系统决定何时使用索引</li>
<li>用户不用在查询语句中指定使用哪个索引</li>
<li><strong>在定义primary key或unique约束后系统自动在相应的列上创建索引</strong></li>
<li>用户也能按自己的需求，对指定单个字段或多个字段，添加索引</li>
</ul>
<table>
<thead>
<tr>
<th align="center">什么时候【要】创建索引</th>
<th align="center">什么时候【不要】创建索引</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表经常进行 SELECT 操作</td>
<td align="center">表经常进行 INSERT/UPDATE/DELETE 操作</td>
</tr>
<tr>
<td align="center">表很大(记录超多)，记录内容分布范围很广</td>
<td align="center">表很小(记录超少)</td>
</tr>
<tr>
<td align="center">列名经常在 WHERE 子句或连接条件中出现</td>
<td align="center">列名不经常作为连接条件或出现在 WHERE 子句中</td>
</tr>
</tbody></table>
<p><strong>索引优缺点：</strong></p>
<ul>
<li>索引加快数据库的检索速度</li>
<li>索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，<strong>因为大部分数据更新需要同时更新索引</strong>)</li>
<li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>
<li>索引需要占物理和数据空间</li>
</ul>
<p>索引分类：</p>
<ul>
<li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li>
<li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li>
<li><strong>聚集索引</strong>(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li>
<li><strong>二级索引</strong>(Non-clustered)：二级索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</li>
</ul>
<h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="一个-SQL-执行的很慢？"><a href="#一个-SQL-执行的很慢？" class="headerlink" title="一个 SQL 执行的很慢？"></a>一个 SQL 执行的很慢？</h3><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 redo log （<strong>重做日志</strong>）写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>
<h3 id="MySQL-基础架构分析"><a href="#MySQL-基础架构分析" class="headerlink" title="MySQL 基础架构分析"></a>MySQL 基础架构分析</h3><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<p><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p>
<p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p>
<h3 id="SQL语句执行过程分析"><a href="#SQL语句执行过程分析" class="headerlink" title="SQL语句执行过程分析"></a>SQL语句执行过程分析</h3><p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p>
<p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog（归档日志）—》redo log commit</p>
<h3 id="常用的存储引擎"><a href="#常用的存储引擎" class="headerlink" title="常用的存储引擎"></a>常用的存储引擎</h3><ul>
<li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Innodb</th>
<th align="center">MyIASM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">事务</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">存储容量</td>
<td align="center">64TB</td>
<td align="center">无上限</td>
</tr>
</tbody></table>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/data-base/" rel="tag"># data base</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/22/ComputerNetworks/" rel="next" title="ComputerNetworks">
                <i class="fa fa-chevron-left"></i> ComputerNetworks
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/25/Redis/" rel="prev" title="Redis">
                Redis <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Mr.Zhang" />
            
              <p class="site-author-name" itemprop="name">Mr.Zhang</p>
              <p class="site-description motion-element" itemprop="description">爱学习的小学生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhangwell" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhangwell0323@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://google.com" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#术语"><span class="nav-number">1.</span> <span class="nav-text">术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实体-Entity"><span class="nav-number">1.1.</span> <span class="nav-text">实体(Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性-Attribute"><span class="nav-number">1.2.</span> <span class="nav-text">属性(Attribute)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组"><span class="nav-number">1.3.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#码-Key"><span class="nav-number">1.4.</span> <span class="nav-text">码(Key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系模式"><span class="nav-number">1.5.</span> <span class="nav-text">关系模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域"><span class="nav-number">1.6.</span> <span class="nav-text">域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引模块"><span class="nav-number">3.</span> <span class="nav-text">索引模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用索引？"><span class="nav-number">3.1.</span> <span class="nav-text">为什么使用索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么样的信息能够称为索引？"><span class="nav-number">3.2.</span> <span class="nav-text">什么样的信息能够称为索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的数据结构？"><span class="nav-number">3.3.</span> <span class="nav-text">索引的数据结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何定位并优化sql？"><span class="nav-number">3.4.</span> <span class="nav-text">如何定位并优化sql？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合索引的最左匹配原则"><span class="nav-number">3.5.</span> <span class="nav-text">联合索引的最左匹配原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁"><span class="nav-number">4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言："><span class="nav-number">4.1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景分析："><span class="nav-number">4.2.</span> <span class="nav-text">场景分析：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁："><span class="nav-number">4.3.</span> <span class="nav-text">乐观锁和悲观锁：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务隔离与锁"><span class="nav-number">5.</span> <span class="nav-text">事务隔离与锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发事务"><span class="nav-number">5.1.</span> <span class="nav-text">并发事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB引擎的隔离与锁"><span class="nav-number">5.2.</span> <span class="nav-text">InnoDB引擎的隔离与锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC实现方式"><span class="nav-number">5.3.</span> <span class="nav-text">MVCC实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Read-committed实现"><span class="nav-number">5.3.1.</span> <span class="nav-text">Read committed实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Repeatable-read实现"><span class="nav-number">5.3.2.</span> <span class="nav-text">Repeatable read实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB在可重复度隔离级别下是如何避免幻读？"><span class="nav-number">5.4.</span> <span class="nav-text">InnoDB在可重复度隔离级别下是如何避免幻读？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引言："><span class="nav-number">5.4.1.</span> <span class="nav-text">引言：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理："><span class="nav-number">5.4.2.</span> <span class="nav-text">原理：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL优化"><span class="nav-number">6.</span> <span class="nav-text">SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择最有效率的表名顺序"><span class="nav-number">6.1.</span> <span class="nav-text">选择最有效率的表名顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WHERE子句中的连接顺序"><span class="nav-number">6.2.</span> <span class="nav-text">WHERE子句中的连接顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT子句中避免使用-号"><span class="nav-number">6.3.</span> <span class="nav-text">SELECT子句中避免使用*号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用TRUNCATE替代DELETE"><span class="nav-number">6.4.</span> <span class="nav-text">用TRUNCATE替代DELETE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多使用内部函数提高SQL效率"><span class="nav-number">6.5.</span> <span class="nav-text">多使用内部函数提高SQL效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用表或列的别名"><span class="nav-number">6.6.</span> <span class="nav-text">使用表或列的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多使用commit"><span class="nav-number">6.7.</span> <span class="nav-text">多使用commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#善用索引"><span class="nav-number">6.8.</span> <span class="nav-text">善用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL写大写"><span class="nav-number">6.9.</span> <span class="nav-text">SQL写大写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免在索引列上使用NOT"><span class="nav-number">6.10.</span> <span class="nav-text">避免在索引列上使用NOT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#避免在索引列上使用计算"><span class="nav-number">6.10.1.</span> <span class="nav-text">避免在索引列上使用计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用-gt-替代-gt"><span class="nav-number">6.10.2.</span> <span class="nav-text">用 &gt;= 替代 &gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用IN替代OR"><span class="nav-number">6.10.3.</span> <span class="nav-text">用IN替代OR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总是使用索引的第一个列"><span class="nav-number">6.10.4.</span> <span class="nav-text">总是使用索引的第一个列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库结构优化"><span class="nav-number">6.11.</span> <span class="nav-text">数据库结构优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器硬件优化"><span class="nav-number">6.12.</span> <span class="nav-text">服务器硬件优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他知识点"><span class="nav-number">7.</span> <span class="nav-text">其他知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#范式"><span class="nav-number">7.1.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">7.2.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-R图"><span class="nav-number">7.3.</span> <span class="nav-text">E-R图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实体的三种联系"><span class="nav-number">7.3.1.</span> <span class="nav-text">实体的三种联系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表示出现多次的关系"><span class="nav-number">7.3.2.</span> <span class="nav-text">表示出现多次的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联系的多向性"><span class="nav-number">7.3.3.</span> <span class="nav-text">联系的多向性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表示子类"><span class="nav-number">7.3.4.</span> <span class="nav-text">表示子类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">8.</span> <span class="nav-text">QA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL表设计要注意什么？"><span class="nav-number">8.1.</span> <span class="nav-text">MySQL表设计要注意什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主键是用自增还是UUID"><span class="nav-number">8.1.1.</span> <span class="nav-text">主键是用自增还是UUID?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主键为什么不推荐有业务含义"><span class="nav-number">8.1.2.</span> <span class="nav-text">主键为什么不推荐有业务含义?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间字段用什么类型"><span class="nav-number">8.1.3.</span> <span class="nav-text">时间字段用什么类型?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么不直接存储图片、音频、视频等大容量内容"><span class="nav-number">8.1.4.</span> <span class="nav-text">为什么不直接存储图片、音频、视频等大容量内容?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段为什么要定义为NOT-NULL"><span class="nav-number">8.1.5.</span> <span class="nav-text">字段为什么要定义为NOT NULL?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的特点"><span class="nav-number">8.2.</span> <span class="nav-text">索引的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-约束有哪几种？"><span class="nav-number">8.3.</span> <span class="nav-text">SQL 约束有哪几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个-SQL-执行的很慢？"><span class="nav-number">8.4.</span> <span class="nav-text">一个 SQL 执行的很慢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-基础架构分析"><span class="nav-number">8.5.</span> <span class="nav-text">MySQL 基础架构分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL语句执行过程分析"><span class="nav-number">8.6.</span> <span class="nav-text">SQL语句执行过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的存储引擎"><span class="nav-number">8.7.</span> <span class="nav-text">常用的存储引擎</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
