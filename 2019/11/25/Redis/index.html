<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="redis," />










<meta name="description" content="引言：  针对面试中redis问答形式的总结   数据库与redis数据一致性问题">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;index.html">
<meta property="og:site_name" content="Well">
<meta property="og:description" content="引言：  针对面试中redis问答形式的总结   数据库与redis数据一致性问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;image-20191125110950740.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;image-20191125111306113.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;1566521057383.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;1566521457362.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;image-20191125135302360.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;%E5%89%91%E6%8C%87Java%5C1566518903284.png">
<meta property="og:updated_time" content="2019-11-26T06:54:33.563Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;25&#x2F;Redis&#x2F;image-20191125110950740.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/25/Redis/"/>





  <title>Redis | Well</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Well</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">huo dao lao xue dao lao</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/25/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Well">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-25T10:28:57+08:00">
                2019-11-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Summary/" itemprop="url" rel="index">
                    <span itemprop="name">Interview Summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>引言：</p>
<blockquote>
<p>针对面试中redis问答形式的总结</p>
<ul>
<li><input disabled type="checkbox"> 数据库与redis数据一致性问题</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p>
<p><strong>1、速度快</strong></p>
<p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p>
<blockquote>
<p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p>
</blockquote>
<p><strong>2、支持丰富数据类型</strong></p>
<p>支持 String ，List，Set，Sorted Set，Hash 。</p>
<blockquote>
<ul>
<li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li>
<li>用他的 Set 可以做高性能的 tag 系统等等。</li>
</ul>
</blockquote>
<p><strong>3、持久化存储</strong></p>
<p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p>
<h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul>
<li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li>
<li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</li>
</ul>
<p><strong>TODO网络 IO 模型</strong></p>
<ul>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li>
<li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li>
</ul>
<p>TODO 有点看不懂，找亚普表弟确认中。</p>
<h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="/2019/11/25/Redis/image-20191125110950740.png" alt="image-20191125110950740"></p>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="/2019/11/25/Redis/image-20191125111306113.png" alt="image-20191125111306113"></p>
<ul>
<li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li>
<li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li>
<li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li>
</ul>
<p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。</p>
<h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul>
<li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li>
<li>数据结构简单，操作也就简单；全程使用 hash 结构，读取速度快；</li>
<li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li>
<li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li>
<li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li>
</ul>
<h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p>
<ul>
<li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p>
<ul>
<li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li>
<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>
<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>
</ul>
<p><strong>RDB又存在哪些劣势呢？</strong></p>
<ul>
<li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ul>
<p><strong>AOF的优势有哪些呢？</strong></p>
<ul>
<li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li>
<li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li>
</ul>
<p><strong>AOF的劣势有哪些呢？</strong></p>
<ul>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>
</ul>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p>
<p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF持久化配置</strong></p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure>

<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p>
</li>
<li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p>
</li>
<li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<ul>
<li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>
<blockquote>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>在 Redis4.0 版本开始，当使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034" target="_blank" rel="noopener">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。</p>
<h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul>
<li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li>
<li>主从复制时，主节点自动触发</li>
<li>执行 Debug Reload</li>
<li>执行 Shutdown 且没有开启 AOF 持久化</li>
</ul>
<p><strong>重要知识：</strong></p>
<ul>
<li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li>
<li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li>
<li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li>
</ul>
<p>BGSAVE底层实现方式：</p>
<p><img src="/2019/11/25/Redis/1566521057383.png" alt="1566521057383"></p>
<ol>
<li>查询子进程是否有冲突</li>
<li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li>
</ol>
<p><img src="/2019/11/25/Redis/1566521457362.png" alt="1566521457362"></p>
<p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p>
<p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p>
<h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p>
<p>Redis 提供了 3 种数据过期策略：</p>
<ul>
<li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li>
<li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「数据“淘汰”策略」</a> 。</li>
</ul>
<p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html" target="_blank" rel="noopener">《关于 Redis 数据过期策略》</a> 文章。</p>
<h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p>
<p>Redis 提供了 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru</li>
<li>volatile-ttl</li>
<li>volatile-random</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>no-enviction</li>
</ol>
<p><img src="/2019/11/25/Redis/image-20191125135302360.png" alt="image-20191125135302360"></p>
<p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">《Redis实战（二） 内存淘汰机制》</a> 。</p>
<p><strong>Redis LRU 算法</strong></p>
<p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p>
<ul>
<li><p>具体的可以看看 <a href="http://ifeve.com/lru-cache/" target="_blank" rel="noopener">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p>
<p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p>
</li>
</ul>
<blockquote>
<p>这个问题的目的是，如何保证热点数据不要被淘汰。</p>
</blockquote>
<p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p>
<p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p>
<p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p>
<h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p>
<p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<p>详细的介绍，可以看看如下文章：</p>
<ul>
<li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li>
<li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li>
<li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li>
</ul>
<p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p>
<p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p>
<p>具体的代码实现，可以看看 <a href="https://www.jianshu.com/p/e3abbfc59d77" target="_blank" rel="noopener">《一道 Redis 面试题》</a> 。</p>
<h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p>
<ul>
<li><p>Redisson</p>
<blockquote>
<p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
</blockquote>
</li>
<li><p>Jedis</p>
<blockquote>
<p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p>
<p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p>
<p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</blockquote>
</li>
<li><p>Lettuce</p>
<blockquote>
<p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p>
</blockquote>
</li>
</ul>
<p>Spring Boot 2.x 内置使用 Lettuce 。</p>
<h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p>
<ul>
<li>互斥性：任意时刻，只能有一个客户端获取锁；</li>
<li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li>
<li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li>
<li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li>
</ul>
<p><strong>方案一：set 指令</strong></p>
<p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<ul>
<li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li>
<li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li>
</ul>
<p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span> [EX <span class="keyword">seconds</span>] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/25/Redis/%E5%89%91%E6%8C%87Java%5C1566518903284.png" alt="1566518903284"></p>
<ul>
<li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li>
<li>具体的实现，可以参考 <a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/" target="_blank" rel="noopener">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li>
</ul>
<p><strong>方案二：redlock</strong></p>
<p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p>
<p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">《Redlock：Redis分布式锁最牛逼的实现》</a></li>
<li><a href="https://www.jianshu.com/p/f302aa345ca8" target="_blank" rel="noopener">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li>
</ul>
<p><strong>对比 Zookeeper 分布式锁</strong></p>
<ul>
<li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li>
<li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li>
</ul>
<p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p>
<h2 id="Redis并发竞争key"><a href="#Redis并发竞争key" class="headerlink" title="Redis并发竞争key"></a>Redis并发竞争key</h2><p>即：多个系统同时对一个 key 进行操作</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<ul>
<li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li>
<li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li>
<li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li>
<li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li>
</ul>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p>
<p><strong>Redis 如何做大量数据插入？</strong></p>
<p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">《Redis 大量数据插入》</a> 文章。</p>
<h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p>
<ul>
<li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p>
</li>
<li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p>
</li>
<li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p>
</li>
<li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p>
</li>
<li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p>
<blockquote>
<p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p>
</blockquote>
</li>
</ul>
<p><strong>如何实现 Redis CAS 操作？</strong></p>
<p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p>
<p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p>
<p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26" target="_blank" rel="noopener">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p>
<h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p>
<ul>
<li>1、Redis Sentinel</li>
<li>2、Redis Cluster</li>
<li>3、Twemproxy</li>
<li>4、Codis</li>
<li>5、客户端分片</li>
</ul>
<p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">《Redis 实战（四）集群机制》</a> 这篇文章。</p>
<p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p>
<blockquote>
<p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p>
<p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
</blockquote>
<p><strong>选择</strong></p>
<p>目前一般在选型上来说：</p>
<ul>
<li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p>
</li>
<li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p>
<p><strong>Redis 集群如何扩容？</strong></p>
</li>
</ul>
<blockquote>
<p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p>
</blockquote>
<ul>
<li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li>
</ul>
<h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p>
<p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p>
<ul>
<li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li>
<li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li>
<li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
<p><strong>好处</strong></p>
<p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p>
<p>更多详细，可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md" target="_blank" rel="noopener">《Redis 主从架构》</a> 。</p>
<h2 id="数据与数据库双写一致"><a href="#数据与数据库双写一致" class="headerlink" title="数据与数据库双写一致"></a>数据与数据库双写一致</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通用的读操作</p>
<ul>
<li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li>
<li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li>
<li>最后将数据返回给请求</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>写操作</strong>可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li><p>设置<strong>键的过期时间</strong>，可以保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p>
</li>
<li><p>更新操作的细分</p>
</li>
</ol>
<p>执行更新操作时，我们会有两种选择：</p>
<ul>
<li>先操作数据库，再操作缓存</li>
<li>先操作缓存，再操作数据库</li>
</ul>
<blockquote>
<p>注：这里的缓存操作一般是删除操作。</p>
</blockquote>
<p>对比：</p>
<ul>
<li>先删除缓存，再更新数据库<ul>
<li>在高并发下表现不如意，在原子性被破坏时表现优异</li>
</ul>
</li>
<li>先更新数据库，再删除缓存(<code>Cache Aside Pattern</code>设计模式)<ul>
<li>在高并发下表现优异，在原子性被破坏时表现不如意</li>
</ul>
</li>
</ul>
<h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">《Redis 哨兵集群实现高可用》</a> 。</p>
<h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p>
<ul>
<li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">《Redis 集群教程》</a> 完整版</li>
<li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md" target="_blank" rel="noopener">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li>
</ul>
<p><strong>说说 Redis 哈希槽的概念？</strong></p>
<p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p>
<p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p>
<p><strong>Redis Cluster 的主从复制模型是怎样的？</strong></p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p>
<p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p>
<ul>
<li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li>
</ul>
<p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p>
<p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p>
<p><strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p>
<p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<p><strong>Redis 集群如何选择数据库？</strong></p>
<p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p>
<blockquote>
<p>重点问题，仔细理解。</p>
</blockquote>
<ul>
<li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li>
<li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li>
<li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li>
<li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li>
<li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li>
</ul>
<h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote>
<p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 集群都有哪些方案？」</a> 是同类问题。</p>
</blockquote>
<p>关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html" target="_blank" rel="noopener">《Redis 分区》</a> 文章。</p>
<ul>
<li>Redis 分区是什么？</li>
<li>分区的优势？</li>
<li>分区的不足？</li>
<li>分区类型？</li>
</ul>
<p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p>
<ul>
<li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li>
<li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li>
</ul>
<p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p>
<p>Redis 分区方案，主要分成两种类型：</p>
<ul>
<li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul>
<li>案例：Redis Cluster 和客户端分区。</li>
</ul>
</li>
<li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul>
<li>案例：Twemproxy 和 Codis 。</li>
</ul>
</li>
</ul>
<p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p>
<p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p>
<p>如下是网络上的一个大答案：</p>
<blockquote>
<p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
</blockquote>
<ul>
<li>和飞哥沟通了下，这个操作不是很合理。</li>
<li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li>
</ul>
<h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA" target="_blank" rel="noopener">《Redis 几个重要的健康指标》</a></p>
<ul>
<li>存活情况</li>
<li>连接数</li>
<li>阻塞客户端数量</li>
<li>使用内存峰值</li>
<li>内存碎片率</li>
<li>缓存命中率</li>
<li>OPS</li>
<li>持久化</li>
<li>失效KEY</li>
<li>慢日志</li>
</ul>
<p><strong>如何提高 Redis 命中率？</strong></p>
<p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html" target="_blank" rel="noopener">《如何提高缓存命中率（Redis）》</a> 。</p>
<h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865" target="_blank" rel="noopener">《Redis 的内存优化》</a></p>
<ul>
<li><p>redisObject 对象</p>
</li>
<li><p>缩减键值对象</p>
</li>
<li><p>共享对象池</p>
</li>
<li><p>字符串优化</p>
</li>
<li><p>编码优化</p>
</li>
<li><p>控制 key 的数量</p>
<p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p>
</li>
</ul>
<p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p>
<p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p>
<p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p>
<p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p>
<p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<ul>
<li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li>
<li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li>
</ul>
<h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p>
<ul>
<li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li>
<li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li>
<li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li>
</ul>
<p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong></p>
<p><strong>3、尽量避免在压力很大的主库上增加从库。</strong></p>
<p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong></p>
<ul>
<li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li>
</ul>
<p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/24/DataBase/" rel="next" title="DataBase">
                <i class="fa fa-chevron-left"></i> DataBase
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/25/LeetCode-Top100/" rel="prev" title="LeetCode Top100">
                LeetCode Top100 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Mr.Zhang" />
            
              <p class="site-author-name" itemprop="name">Mr.Zhang</p>
              <p class="site-description motion-element" itemprop="description">爱学习的小学生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhangwell" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhangwell0323@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://google.com" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Redis-？"><span class="nav-number">1.</span> <span class="nav-text">什么是 Redis ？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-有什么缺点？"><span class="nav-number">1.1.</span> <span class="nav-text">Redis 有什么缺点？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请说说-Redis-的线程模型？"><span class="nav-number">2.</span> <span class="nav-text">请说说 Redis 的线程模型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么-Redis-单线程模型也能效率这么高？"><span class="nav-number">3.</span> <span class="nav-text">为什么 Redis 单线程模型也能效率这么高？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-有几种持久化方式？"><span class="nav-number">4.</span> <span class="nav-text">Redis 有几种持久化方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化方式"><span class="nav-number">4.1.</span> <span class="nav-text">持久化方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二者的区别"><span class="nav-number">4.2.</span> <span class="nav-text">二者的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二者优缺点"><span class="nav-number">4.3.</span> <span class="nav-text">二者优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用配置"><span class="nav-number">4.4.</span> <span class="nav-text">常用配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何选择"><span class="nav-number">4.5.</span> <span class="nav-text">如何选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动化触发-RDB-持久化的方式"><span class="nav-number">4.6.</span> <span class="nav-text">自动化触发 RDB 持久化的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-有几种数据“过期”策略？"><span class="nav-number">5.</span> <span class="nav-text">Redis 有几种数据“过期”策略？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-有哪几种数据“淘汰”策略？"><span class="nav-number">6.</span> <span class="nav-text">Redis 有哪几种数据“淘汰”策略？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><span class="nav-number">7.</span> <span class="nav-text">如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-使用场景"><span class="nav-number">8.</span> <span class="nav-text">Redis 使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-支持的-Java-客户端都有哪些？"><span class="nav-number">9.</span> <span class="nav-text">Redis 支持的 Java 客户端都有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用-Redis-实现分布式锁？"><span class="nav-number">10.</span> <span class="nav-text">如何使用 Redis 实现分布式锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis并发竞争key"><span class="nav-number">11.</span> <span class="nav-text">Redis并发竞争key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用-Redis-实现消息队列？"><span class="nav-number">12.</span> <span class="nav-text">如何使用 Redis 实现消息队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Redis-Pipelining-？"><span class="nav-number">13.</span> <span class="nav-text">什么是 Redis Pipelining ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Redis-事务？"><span class="nav-number">14.</span> <span class="nav-text">什么是 Redis 事务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-集群都有哪些方案？"><span class="nav-number">15.</span> <span class="nav-text">Redis 集群都有哪些方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Redis-主从同步？"><span class="nav-number">16.</span> <span class="nav-text">什么是 Redis 主从同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据与数据库双写一致"><span class="nav-number">17.</span> <span class="nav-text">数据与数据库双写一致</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">17.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">17.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决"><span class="nav-number">17.3.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用-Redis-Sentinel-实现高可用？"><span class="nav-number">18.</span> <span class="nav-text">如何使用 Redis Sentinel 实现高可用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果使用-Redis-Cluster-实现高可用？"><span class="nav-number">19.</span> <span class="nav-text">如果使用 Redis Cluster 实现高可用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-Redis-分区？"><span class="nav-number">20.</span> <span class="nav-text">什么是 Redis 分区？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-有哪些重要的健康指标？"><span class="nav-number">21.</span> <span class="nav-text">Redis 有哪些重要的健康指标？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么优化-Redis-的内存占用"><span class="nav-number">22.</span> <span class="nav-text">怎么优化 Redis 的内存占用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-常见的性能问题都有哪些？如何解决？"><span class="nav-number">23.</span> <span class="nav-text">Redis 常见的性能问题都有哪些？如何解决？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
