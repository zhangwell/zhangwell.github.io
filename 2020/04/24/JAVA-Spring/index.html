<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java spring," />










<meta name="description" content="引言：   Java Spring框架笔记">
<meta name="keywords" content="java spring">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA-Spring">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;index.html">
<meta property="og:site_name" content="Well">
<meta property="og:description" content="引言：   Java Spring框架笔记">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567131737917.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132198944.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132290549.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132348627.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132527700.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132665135.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567132802864.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567133056969.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567133089064.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567133141092.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567133889794.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pic1.zhimg.com&#x2F;80&#x2F;v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567134047279.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567134582679.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567134623398.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567135465808.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567135556369.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567135577177.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567134859951.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567134968136.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567135018588.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567137963853.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567138042701.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567138130281.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567138269117.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567138332244.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567138744314.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567139561022.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567139336948.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567139966763.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567139981229.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141357464.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141421420.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141491889.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141574312.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141612844.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567141729918.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567142579843.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567142610000.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567143238161.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567143257267.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567143313889.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567143353134.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567144837023.png">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751905?w=887&amp;h=870">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751906?w=1097&amp;h=620">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751907?w=980&amp;h=583">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751908">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751909?w=1063&amp;h=761">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751910?w=1051&amp;h=783">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751911">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751912?w=899&amp;h=444">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000013751913?w=887&amp;h=485">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979707">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979708">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979710">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979711">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979712">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979713">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979714?w=874&amp;h=758">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979715?w=883&amp;h=588">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979716?w=690&amp;h=307">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979717">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979718?w=715&amp;h=146">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979719">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979720?w=1221&amp;h=288">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979721?w=1400&amp;h=435">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979722?w=874&amp;h=217">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979723">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979724?w=1091&amp;h=396">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979725">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979726?w=859&amp;h=341">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979727">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979728?w=1159&amp;h=308">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979729">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979730?w=720&amp;h=159">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979731">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979732?w=1061&amp;h=316">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018891?w=773&amp;h=474">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018892">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018893">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018894?w=485&amp;h=159">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018903?w=815&amp;h=774">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018904?w=797&amp;h=726">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018905">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018906?w=785&amp;h=230">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018907?w=508&amp;h=93">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018908?w=681&amp;h=425">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018909">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018910?w=966&amp;h=293">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018911?w=1371&amp;h=154">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018912">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000015018913">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075072?w=1189&amp;h=769">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075073?w=888&amp;h=659">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075074">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075075">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075076?w=1300&amp;h=799">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075077">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075078">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075079?w=1052&amp;h=852">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075080">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018075081?w=1498&amp;h=796">
<meta property="og:image" content="https:&#x2F;&#x2F;my-blog-to-use.oss-cn-beijing.aliyuncs.com&#x2F;2019-6&#x2F;SpringAOPProcess.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979733?w=804&amp;h=623">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979734">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000014979735">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182343">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182344?w=600&amp;h=143">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182345">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182346">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182347">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182348">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182349?w=1353&amp;h=684">
<meta property="og:image" content="https:&#x2F;&#x2F;segmentfault.com&#x2F;img&#x2F;remote&#x2F;1460000018182350">
<meta property="og:updated_time" content="2020-04-28T13:44:45.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;04&#x2F;24&#x2F;JAVA-Spring&#x2F;1567131737917.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/24/JAVA-Spring/"/>





  <title>JAVA-Spring | Well</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Well</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">huo dao lao xue dao lao</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/JAVA-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr.Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Well">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA-Spring</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-24T21:46:16+08:00">
                2020-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Summary/" itemprop="url" rel="index">
                    <span itemprop="name">Interview Summary</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>引言：</p>
<blockquote>
<p> Java Spring框架笔记</p>
</blockquote>
<a id="more"></a>

<p>先要看看反射&amp;注解的详细知识。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>家族图谱</p>
<p>第一阶段Spring Core、Spring Security、Spring Data，实现将单体应用开发服务好。不仅仅提供的便捷的数据库访问，web 中SpringMVC等必要功能。使用IOC、AOP实现应用低耦合、可扩展。</p>
<p><img src="/2020/04/24/JAVA-Spring/1567131737917.png" alt="1567131737917"></p>
<blockquote>
<p>利用工厂模式（DI）和代理模式（AOP）来解耦应用组件，然后实现了web应用的框架（SpringMVC）;</p>
</blockquote>
<p>第二阶段推出的SpringBoot不仅仅提高了开发效率，而且将程序由可用变为好用。</p>
<p><img src="/2020/04/24/JAVA-Spring/1567132198944.png" alt="1567132198944"></p>
<p>第三阶段的Spring Cloud，推动了微服务架构的落地</p>
<p><img src="/2020/04/24/JAVA-Spring/1567132290549.png" alt="1567132290549"></p>
<p>第四阶段：Spring Cloud DataFlow</p>
<p>DataFlow将实时消息的处理任务和临时运行的任务都作为组件处理，定义这样组件的交互。</p>
<p><img src="/2020/04/24/JAVA-Spring/1567132348627.png" alt="1567132348627"></p>
<h3 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/04/24/JAVA-Spring/1567132527700.png" alt="1567132527700"></p>
<p>IOC是一种思想，使我们从繁琐的对象交互中解脱出来，进而专注于对象本身，更进一步了解面向对对象。</p>
<p>一般的设计思路：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567132665135.png" alt="1567132665135"></p>
<blockquote>
<p>先设计轮子，根据轮子设计底盘，根据底盘设计箱体…</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567132802864.png" alt="1567132802864"></p>
<blockquote>
<p>这里每个类的构造函数都直接调用了底层代码的构造函数，这样底层需求变动时会影响整个上层的代码，是不可取的。</p>
</blockquote>
<p>依赖注入的思路</p>
<p><img src="/2020/04/24/JAVA-Spring/1567133056969.png" alt="1567133056969"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567133089064.png" alt="1567133089064"></p>
<p>其思想是<strong>反转资源获取的方向</strong>。传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了 IOC 之后，则是<strong>容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源</strong>。这种行为也被称为查找的被动形式</p>
<p><img src="/2020/04/24/JAVA-Spring/1567133141092.png" alt="1567133141092"></p>
<p>DI（Dependency Injection）— IOC 的另一种表述方式：即<strong>组件以一些预先定义好的方式</strong>接受来自如容器的资源注入。</p>
<ul>
<li>set：实现特定属性的public set()方法，让IOC容器注入所依赖类型的对象</li>
<li>接口：实现特定接口，让IOC容器注入所依赖类型的对象</li>
<li>构造函数：实现特定参数的构造函数，实现在创建对象时让IOC容器注入所依赖类型的对象</li>
<li>注解：通过Java的注解机制，让IOC容器注入所依赖类型的对象</li>
</ul>
<h4 id="依赖倒置原则、IOC、DI、IOC容器"><a href="#依赖倒置原则、IOC、DI、IOC容器" class="headerlink" title="依赖倒置原则、IOC、DI、IOC容器"></a>依赖倒置原则、IOC、DI、IOC容器</h4><p><strong>什么是依赖倒置原则？</strong></p>
<p>假设我们设计行李箱：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计箱体，最后根据箱体设计好整个箱子。这里就出现了一个“依赖”关系：箱子依赖箱体，箱体依赖底盘，底盘依赖轮子。</p>
<p><img src="/2020/04/24/JAVA-Spring/1567133889794.png" alt="1567133889794"></p>
<p>上面的依赖关系是该原则所反对的，该原则的思想为高层模块不应该依赖与底层模块，两者都应该依赖于其抽象。</p>
<blockquote>
<p>依赖倒置原则思想的指导才有了IOC的思路，有了IOC的思路则需要DI方法的支撑。Spring框架基于IOC才提出了容器的概念，容器管理着Bean的生命周期，控制着Bean的依赖注入。</p>
</blockquote>
<p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。这几种概念的关系大概如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt="img"></p>
<p>那什么是<strong>控制反转容器(IoC Container)</strong>呢？对行李箱类进行初始化的那段代码发生的地方，就是控制反转容器。</p>
<p><img src="/2020/04/24/JAVA-Spring/1567134047279.png" alt="1567134047279"></p>
<p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<strong>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化行李箱都要亲手去写那一大段初始化的代码</strong>。这是引入IoC Container的第一个好处。</p>
<p><strong>IOC的优势：</strong></p>
<p><img src="/2020/04/24/JAVA-Spring/1567134582679.png" alt="1567134582679"></p>
<p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567134623398.png" alt="1567134623398"></p>
<p>我们就像是工厂的客户。我们只需要向工厂请求一个Luggage实例，然后它就给我们按照Config创建了一个Luggage实例。我们完全不用管这个Luggage实例是怎么一步一步被创建出来。</p>
<h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>容器：Spring 提供了两种类型的 IOC 容器实现. </p>
<ul>
<li>BeanFactory：IOC 容器的基本实现。</li>
<li>ApplicationContext：提供了更多的高级特性。是 BeanFactory 的子接口（都用这个）</li>
</ul>
<p>实际Spring IOC容器是怎么实现对象的创建和依赖的：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567135465808.png" alt="1567135465808"></p>
<p>1、Spring启动时读取应用程序提供的Bean配置信息，并在容器生成一份相应的Bean配置注册表</p>
<p>2、根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</p>
<blockquote>
<p>这里利用的是Java语言的反射功能实例化bean、并建立Bean之间的依赖关系</p>
</blockquote>
<p>3、将这些准备就绪的Bean放到Map缓存池中，为上层提供就绪的运行环境，等待应用程序执行调用</p>
<p><img src="/2020/04/24/JAVA-Spring/1567135556369.png" alt="1567135556369"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567135577177.png" alt="1567135577177"></p>
<blockquote>
<p>Spring 作者设计这两个核心接口用以表示容器</p>
</blockquote>
<p>相关接口：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567134859951.png" alt="1567134859951"></p>
<blockquote>
<p>Spring容器在启动时会将xml或者注解里的Bean的定义解析为Spring内部的BeanDefinition</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567134968136.png" alt="1567134968136"></p>
<blockquote>
<p>Spring 将Bean的定义解析为BeanDefinition后会通过BeanDefinitionRegistry 以BeanName为key，BeanDefinition为value存储到BeanDefinitionMap （这是个ConcurrentHashMap类型的map结构）中。</p>
</blockquote>
<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><h5 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h5><p><img src="/2020/04/24/JAVA-Spring/1567135018588.png" alt="1567135018588"></p>
<blockquote>
<p>包含Bean的各种定义，以便在接收客户端请求时可以实例化Bean，并在实例化对象时建立Bean 之间的依赖关系，这将使Bean从Bean客户端中解放出来。</p>
</blockquote>
<p>BeanFactory源码：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567137963853.png" alt="1567137963853"></p>
<blockquote>
<p>各种getBean()方法，可以看到可以从Spring中按类型 / 按名称获取Bean</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567138042701.png" alt="1567138042701"></p>
<blockquote>
<p>判断是否为单例方法，SpringIOC中，默认Bean都是以单例存在的</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567138130281.png" alt="1567138130281"></p>
<blockquote>
<p>与上面相反，判断为多例的</p>
</blockquote>
<h5 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h5><p><img src="/2020/04/24/JAVA-Spring/1567138269117.png" alt="1567138269117"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567138332244.png" alt="1567138332244"></p>
<blockquote>
<p>3表示可以管理message，4表示可以发布实事件给监听器，实现监听</p>
<p>可以看出这不单单是个工厂，是整个应用上下文，代表整个大容器的所有功能</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567138744314.png" alt="1567138744314"></p>
<blockquote>
<p>SpringBoot的自带启动类的run()方法，深入进去其最终会执行createApplicationContext()方法，会发现其会用Class.forName加载AnnotationConfigServleWebServerApplicationContext类。</p>
</blockquote>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h5><p><strong>装载对象</strong></p>
<ol>
<li>建Category类</li>
<li>在src目录下新建applicationContext.xml文件<br>applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"pojo.Category"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"category 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试<br>演示通过spring获取Category对象，以及该对象被注入的name属性。<br>可以打印出通过Spring拿到的Category对象的name属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">            <span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line"></span><br><span class="line">        Category c = (Category) context.getBean(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注入对象</strong></p>
<p>上文对Category的name属性注入了”category 1”字符串<br>下面对Product对象，注入一个Category对象</p>
<ol>
<li>Product类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对Category对象的setter getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>applicationContext.xml 配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Product"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"product1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"category"</span> <span class="attr">ref</span>=<span class="string">"c"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="案例二：注解方式"><a href="#案例二：注解方式" class="headerlink" title="案例二：注解方式"></a>案例二：注解方式</h5><p>对<strong>注入对象行为</strong>的注解案例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Category"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"category 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Product"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"product1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>@Autowired</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> category; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123; <span class="keyword">this</span>.category = category; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对Bean进行注解</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"p"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"product 1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> category; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123; <span class="keyword">this</span>.category = category; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"category 1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Bean装载案例："><a href="#Bean装载案例：" class="headerlink" title="Bean装载案例："></a>Bean装载案例：</h5><p>Person Bean：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567139561022.png" alt="1567139561022"></p>
<blockquote>
<p>扫描装配Bean，使用注解@Component（指定要扫描的类进入IOC容器中）@Value()是赋值</p>
</blockquote>
<p>启动类：</p>
<p><img src="/2020/04/24/JAVA-Spring/1567139336948.png" alt="1567139336948"></p>
<blockquote>
<p>@SpringBootApplication注解包含了启动扫描的功能。</p>
</blockquote>
<h5 id="Bean依赖注入案例："><a href="#Bean依赖注入案例：" class="headerlink" title="Bean依赖注入案例："></a>Bean依赖注入案例：</h5><p><img src="/2020/04/24/JAVA-Spring/1567139966763.png" alt="1567139966763"></p>
<blockquote>
<p>装载Dog 类进入IOC容器</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567139981229.png" alt="1567139981229"></p>
<blockquote>
<p>注入Pet（Pet是个接口），@Autowired会根据属性类型找到对应的Bean进行注入（最基本是用getBean()方法根据类型注入），这里的Dog类是Pet的一种实现，所以会根据类型查找到Dog，由SpringIOC容器将Dog的实例注入Person中。</p>
<p>当有多个Pet的实现时（例如还有Cat、Bird类），需要在要注入的类上加上@Primary注解。</p>
</blockquote>
<h4 id="getBean-解析"><a href="#getBean-解析" class="headerlink" title="getBean()解析"></a>getBean()解析</h4><p>会调用doGetBean()放法；</p>
<p><img src="/2020/04/24/JAVA-Spring/1567141357464.png" alt="1567141357464"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567141421420.png" alt="1567141421420"></p>
<blockquote>
<p>1、先获取Bean名称beanName；2、获取一个（共享的）实例；3、试着从缓存或者实例工厂中获取实例；</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567141491889.png" alt="1567141491889"></p>
<h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p><img src="/2020/04/24/JAVA-Spring/1567141574312.png" alt="1567141574312"></p>
<h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p><img src="/2020/04/24/JAVA-Spring/1567141612844.png" alt="1567141612844"></p>
<blockquote>
<p>1、实例化Bean对象以及设置属性</p>
<p>2、 对 Aware 接口的实现，目的是在Bean中设置对IOC容器的感知</p>
<p>3、Bean的前置初始化方法，对Spring容器完成实例化的Bean添加自定义的处理逻辑</p>
<p>4、…   5、…</p>
<p>6、Bena的后置初始化方法，Bean实例初始化后的自定义工作，3、6和AOP相关</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567141729918.png" alt="1567141729918"></p>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p><img src="/2020/04/24/JAVA-Spring/1567142579843.png" alt="1567142579843"></p>
<p>分类与合并（织入）</p>
<p><img src="/2020/04/24/JAVA-Spring/1567142610000.png" alt="1567142610000"></p>
<blockquote>
<p>Spring 采用的方式不需要特殊的Java编译器，但性能开销多一些</p>
</blockquote>
<p><img src="/2020/04/24/JAVA-Spring/1567143238161.png" alt="1567143238161"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567143257267.png" alt="1567143257267"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567143313889.png" alt="1567143313889"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567143353134.png" alt="1567143353134"></p>
<p><img src="/2020/04/24/JAVA-Spring/1567144837023.png" alt="1567144837023"></p>
<h3 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h3><p>所谓静态代理，其实质是自己手写(或者用工具生成)代理类，也就是在程序运行前就已经存在的编译好的代理类。</p>
<ul>
<li>但是，如果我们需要很多的代理，每一个都这么去创建实属浪费时间，而且会有大量的重复代码，</li>
</ul>
<p><strong>动态代理可以在程序运行期间根据需要动态的创建代理类及其实例来完成具体的功能</strong>。</p>
<p>总的来说，<strong>根据代理类的创建时机和创建方式的不同，我们可以将代理分为静态代理和动态代理两种形式</strong>。</p>
<ul>
<li>代理对象存在的价值主要用于拦截对真实业务对象的访问；</li>
<li>代理对象应该具有和目标对象(真实业务对象)相同的方法，即实现共同的接口或继承于同一个类；</li>
<li>代理对象应该是目标对象的增强，否则我们就没有必要使用代理了。</li>
</ul>
<p>事实上，<strong>真正的业务功能还是由目标类来实现，代理类只是用于扩展、增强目标类的行为</strong>。例如，在项目开发中我们没有加入缓冲、日志这些功能而后期需要加入，我们就可以使用代理来实现，而没有必要去直接修改已经封装好的目标类。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案。</p>
<blockquote>
<p>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
</blockquote>
<p>AOP机制是 Spring 所提供的核心功能之一，其既是Java动态代理机制的经典应用，也是动态AOP实现的代表。Spring AOP默认使用Java动态代理来创建AOP代理，具体通过以下几个步骤来完成：</p>
<ul>
<li><p>Spring IOC 容器创建Bean(目标类对象)；</p>
</li>
<li><p>Bean创建完成后，Bean后处理器(BeanPostProcessor)根据具体的切面逻辑及Bean本身使用Java动态代理技术生成代理对象；</p>
</li>
<li><p>应用程序使用上述生成的代理对象替代原对象来完成业务逻辑，从而达到增强处理的目的。</p>
</li>
</ul>
<blockquote>
<p>要实现动态代理必须要有接口的，<strong>动态代理是基于接口来代理的</strong>(实现接口的所有方法)，如果没有接口的话我们可以考虑cglib代理。cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能</strong>！</p>
</blockquote>
<h2 id="Spring-DAO模块"><a href="#Spring-DAO模块" class="headerlink" title="Spring DAO模块"></a>Spring DAO模块</h2><p><strong>Spring的DAO模块对JDBC的支持，以及Spring对事务的控制</strong>…</p>
<h3 id="回顾对模版代码优化过程"><a href="#回顾对模版代码优化过程" class="headerlink" title="回顾对模版代码优化过程"></a>回顾对模版代码优化过程</h3><p>我们来回忆一下我们怎么对模板代码进行优化的！</p>
<ul>
<li>首先来看一下我们<strong>原生的JDBC：需要手动去数据库的驱动从而拿到对应的连接</strong>..</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    con = DriverManager.getConnection(<span class="string">"jdbc:mysql:///hib_demo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    <span class="comment">// 执行命令对象</span></span><br><span class="line">    stmt =  con.createStatement();</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    stmt.execute(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为JDBC是面向接口编程的，因此数据库的驱动都是由数据库的厂商给做到好了，我们<strong>只要加载对应的数据库驱动，便可以获取对应的数据库连接</strong>….因此，我们<strong>写了一个工具类，专门来获取与数据库的连接(Connection)</strong>，当然啦，为了更加灵活，我们的<strong>工具类是读取配置文件的方式来做的</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 连接数据库的driver，url，username，password通过配置文件来配置，可以增加灵活性</span></span><br><span class="line"><span class="comment">    * 当我们需要切换数据库的时候，只需要在配置文件中改以上的信息即可</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  driver = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  username = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取配置文件的读入流</span></span><br><span class="line">        InputStream inputStream = UtilsDemo.class.getClassLoader().getResourceAsStream("db.properties");</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取配置文件的信息</span></span><br><span class="line">        driver = properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">        password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载驱动类</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url,username,password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>经过上面一层的封装，我们可以<strong>在使用的地方直接使用工具类来得到与数据库的连接…那么比原来就方便很多了！</strong>但是呢，<strong>每次还是需要使用Connection去创建一个Statement对象。并且无论是什么方法，其实就是SQL语句和传递进来的参数不同！</strong></li>
<li>于是，我们就自定义了一个JDBC的工具类，详情可以看<a href="http://blog.csdn.net/hon_3y/article/details/53760782#t6" target="_blank" rel="noopener">http://blog.csdn.net/hon_3y/article/details/53760782#t6</a></li>
<li>我们自定义的工具类其实就是以DbUtils组件为模板来写的，因此我们在开发的时候就一直<strong>使用DbUtils组件了</strong>。</li>
</ul>
<hr>
<h3 id="使用Spring的JDBC"><a href="#使用Spring的JDBC" class="headerlink" title="使用Spring的JDBC"></a>使用Spring的JDBC</h3><p>上面已经回顾了一下以前我们的JDBC开发了，那么看看Spring对JDBC又是怎么优化的</p>
<p>首先，想要使用Spring的JDBC模块，就必须引入两个jar文件：</p>
<ul>
<li>引入jar文件<ul>
<li><strong>spring-jdbc-3.2.5.RELEASE.jar</strong></li>
<li><strong>spring-tx-3.2.5.RELEASE.jar</strong></li>
</ul>
</li>
<li>首先还是看一下我们原生的JDBC代码：<strong>获取Connection是可以抽取出来的，直接使用dataSource来得到Connection就行了</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// 连接对象</span></span><br><span class="line">        con = DriverManager.getConnection(<span class="string">"jdbc:mysql:///hib_demo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">// 执行命令对象</span></span><br><span class="line">        stmt =  con.createStatement();</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        stmt.execute(sql);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>值得注意的是，<strong>JDBC对C3P0数据库连接池是有很好的支持的。因此我们直接可以使用Spring的依赖注入，在配置文件中配置dataSource就行了</strong>！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="jdbcUrl" value="jdbc:mysql:///hib_demo"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="user" value="root"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="password" value="root"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="initialPoolSize" value="3"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxPoolSize" value="10"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxStatements" value="100"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="acquireIncrement" value="2"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    <span class="comment">// IOC容器注入</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 连接对象</span></span><br><span class="line">        con = dataSource.getConnection();</span><br><span class="line">        <span class="comment">// 执行命令对象</span></span><br><span class="line">        stmt =  con.createStatement();</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        stmt.execute(sql);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Spring来提供了JdbcTemplate这么一个类给我们使用！它封装了DataSource，也就是说我们可以在Dao中使用JdbcTemplate就行了。</strong></li>
<li>创建dataSource，创建jdbcTemplate对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///zhongfucheng"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"bb"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 创建JdbcTemplate对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>userDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Spring的自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user(name,password) values('zhoggucheng','123')"</span>;</span><br><span class="line">        template.update(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">    UserDao userDao = (UserDao) ac.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000013751905?w=887&h=870" alt="这里写图片描述"></p>
<hr>
<h3 id="JdbcTemplate查询"><a href="#JdbcTemplate查询" class="headerlink" title="JdbcTemplate查询"></a>JdbcTemplate查询</h3><p>我们要是使用JdbcTemplate查询会发现<strong>有很多重载了query()方法</strong></p>
<p><img src="https://segmentfault.com/img/remote/1460000013751906?w=1097&h=620" alt="这里写图片描述"></p>
<p>一般地，<strong>如果我们使用queryForMap()，那么只能封装一行的数据，如果封装多行的数据、那么就会报错</strong>！并且，Spring是不知道我们想把一行数据封装成是什么样的，因此返回值是Map集合…我们得到Map集合的话还需要我们自己去转换成自己需要的类型。</p>
<hr>
<p>我们一般使用下面这个方法：</p>
<p><img src="https://segmentfault.com/img/remote/1460000013751907?w=980&h=583" alt="这里写图片描述"></p>
<p>我们可以<strong>实现RowMapper，告诉Spring我们将每行记录封装成怎么样的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from USER where password=?"</span>;</span><br><span class="line">    List&lt;User&gt; query = template.query(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">        <span class="comment">//将每行记录封装成User对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            user.setPassword(resultSet.getString(<span class="string">"password"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,id);</span><br><span class="line">    System.out.println(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000013751908" alt="这里写图片描述"></p>
<hr>
<p>当然了，一般我们都是<strong>将每行记录封装成一个JavaBean对象的，因此直接实现RowMapper，在使用的时候创建就好了</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResult</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Dept</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如何封装一行记录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">        dept.setDeptId(rs.getInt(<span class="string">"deptId"</span>));</span><br><span class="line">        dept.setDeptName(rs.getString(<span class="string">"deptName"</span>));</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务控制概述"><a href="#事务控制概述" class="headerlink" title="事务控制概述"></a>事务控制概述</h3><p>下面主要讲解Spring的事务控制，如何使用Spring来对程序进行事务控制….</p>
<ul>
<li><strong>Spring的事务控制是属于Spring Dao模块的</strong>。</li>
</ul>
<p>一般地，我们<strong>事务控制都是在service层做的</strong>。。为什么是在service层而不是在dao层呢？？有没有这样的疑问…</p>
<p><strong>service层是业务逻辑层，service的方法一旦执行成功，那么说明该功能没有出错</strong>。</p>
<p>一个<strong>service方法可能要调用dao层的多个方法</strong>，如果在dao层做事务控制的话，一个dao方法出错了，仅仅把事务回滚到当前dao的功能，这样是不合适的[因为我们的业务由多个dao方法组成]。如果没有出错，调用完dao方法就commit了事务，这也是不合适的[导致太多的commit操作]。</p>
<p>事务控制分为两种：</p>
<ul>
<li><strong>编程式事务控制</strong></li>
<li><strong>声明式事务控制</strong></li>
</ul>
<h4 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h4><p><strong>自己手动控制事务，就叫做编程式事务控制。</strong></p>
<ul>
<li>Jdbc代码：<ul>
<li>Conn.setAutoCommite(false); // 设置手动控制事务</li>
</ul>
</li>
<li>Hibernate代码：<ul>
<li>Session.beginTransaction(); // 开启一个事务</li>
</ul>
</li>
<li><strong>【细粒度的事务控制： 可以对指定的方法、指定的方法的某几行添加事务控制】</strong></li>
<li><strong>(比较灵活，但开发起来比较繁琐： 每次都要开启、提交、回滚.)</strong></li>
</ul>
<h4 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h4><p><strong>Spring提供对事务的控制管理就叫做声明式事务控制</strong></p>
<p>Spring提供了对事务控制的实现。</p>
<ul>
<li>如果用户想要使用Spring的事务控制，<strong>只需要配置就行了</strong>。</li>
<li>当不用Spring事务的时候，直接移除就行了。</li>
<li>Spring的事务控制是<strong>基于AOP实现的</strong>。因此它的<strong>耦合度是非常低</strong>的。</li>
<li>【粗粒度的事务控制： <strong>只能给整个方法应用事务，不可以对方法的某几行应用事务。</strong>】<ul>
<li>(因为aop拦截的是方法。)</li>
</ul>
</li>
</ul>
<p><strong>Spring给我们提供了事务的管理器类</strong>，事务管理器类又分为两种，因为<strong>JDBC的事务和Hibernate的事务是不一样的</strong>。</p>
<ul>
<li>Spring声明式事务管理器类：<ul>
<li>Jdbc技术：DataSourceTransactionManager</li>
<li>Hibernate技术：HibernateTransactionManager</li>
</ul>
</li>
</ul>
<hr>
<h3 id="声明式事务控制-1"><a href="#声明式事务控制-1" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><p>我们基于Spring的JDBC来做例子吧</p>
<p>引入相关jar包</p>
<ul>
<li><strong>AOP相关的jar包【因为Spring的声明式事务控制是基于AOP的，那么就需要引入AOP的jar包。】</strong></li>
<li><strong>引入tx名称空间</strong></li>
<li><strong>引入AOP名称空间</strong></li>
<li><strong>引入jdbcjar包【jdbc.jar包和tx.jar包】</strong></li>
</ul>
<hr>
<h4 id="搭建配置环境"><a href="#搭建配置环境" class="headerlink" title="搭建配置环境"></a>搭建配置环境</h4><ul>
<li>编写一个接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>UserDao实现类，使用JdbcTemplate对数据库进行操作！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Spring的自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user(name,password) values('zhong','222')"</span>;</span><br><span class="line">        template.update(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>userService</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bean.xml配置：配置数据库连接池、jdbcTemplate对象、扫描注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据连接池配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///zhongfucheng"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"bb"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 创建JdbcTemplate对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>前面搭建环境的的时候，是没有任何的事务控制的。</p>
<p>也就是说，<strong>当我在service中调用两次userDao.save()，即时在中途中有异常抛出，还是可以在数据库插入一条记录的</strong>。</p>
<ul>
<li>Service代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) ac.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000013751909?w=1063&h=761" alt="这里写图片描述"></p>
<hr>
<h4 id="XML方式实现声明式事务控制"><a href="#XML方式实现声明式事务控制" class="headerlink" title="XML方式实现声明式事务控制"></a>XML方式实现声明式事务控制</h4><p><strong>首先，我们要配置事务的管理器类：因为JDBC和Hibernate的事务控制是不同的。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置事务的管理器类:JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManage"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再而，<strong>配置事务管理器类如何管理事务</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.配置如何管理事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManage"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有的方法，并不是只读--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，<strong>配置拦截哪些方法，</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.配置拦截哪些方法+事务的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* bb.UserService.*(..) )"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成之后，service中的方法都应该被Spring的声明式事务控制了。因此我们再次测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">    UserService userService = (UserService) ac.getBean(<span class="string">"userService"</span>);</span><br><span class="line">    userService.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000013751910?w=1051&h=783" alt="这里写图片描述"></p>
<hr>
<h4 id="使用注解的方法实现事务控制"><a href="#使用注解的方法实现事务控制" class="headerlink" title="使用注解的方法实现事务控制"></a>使用注解的方法实现事务控制</h4><p>当然了，有的人可能觉得到XML文件上配置太多东西了。<strong>Spring也提供了使用注解的方式来实现对事务控制</strong></p>
<p>第一步和XML的是一样的，<strong>必须配置事务管理器类：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置事务的管理器类:JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManage"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：开启以注解的方式来实现事务控制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启以注解的方式实现事务控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManage"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后，<strong>想要控制哪个方法事务，在其前面添加@Transactional这个注解就行了！</strong>如果想要控制整个类的事务，那么在类上面添加就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.save();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000013751911" alt="这里写图片描述"></p>
<hr>
<h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><p>其实我们<strong>在XML配置管理器类如何管理事务，就是在指定事务的属性！</strong>我们来看一下事务的属性有什么：</p>
<p><img src="https://segmentfault.com/img/remote/1460000013751912?w=899&h=444" alt="这里写图片描述"></p>
<p>对于事务的隔离级别，不清楚的朋友可参考之前的博文：<a href="http://blog.csdn.net/hon_3y/article/details/53760782" target="_blank" rel="noopener">http://blog.csdn.net/hon_3y/article/details/53760782</a></p>
<h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>看了上面的事务属性，没有接触过的其实就这么一个：<code>propagation = Propagation.REQUIRED</code>事务的传播行为。</p>
<p>事务传播行为的属性有以下这么多个，常用的就只有两个：</p>
<ul>
<li>Propagation.REQUIRED【如果当前方法已经有事务了，<strong>加入当前方法事务</strong>】</li>
<li>Propagation.REQUIRED_NEW【如果当前方法有事务了，当前方法事务会挂起。<strong>始终开启一个新的事务</strong>，直到新的事务执行完、当前方法的事务才开始】</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000013751913?w=887&h=485" alt="这里写图片描述"></p>
<h4 id="当事务传播行为是Propagation-REQUIRED"><a href="#当事务传播行为是Propagation-REQUIRED" class="headerlink" title="当事务传播行为是Propagation.REQUIRED"></a>当事务传播行为是Propagation.REQUIRED</h4><ul>
<li><h4 id="现在有一个日志类，它的事务传播行为是Propagation-REQUIRED"><a href="#现在有一个日志类，它的事务传播行为是Propagation-REQUIRED" class="headerlink" title="现在有一个日志类，它的事务传播行为是Propagation.REQUIRED"></a><strong>现在有一个日志类，它的事务传播行为是Propagation.REQUIRED</strong></h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Log&#123;</span><br><span class="line">    Propagation.REQUIRED  </span><br><span class="line">        insertLog();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>现在，我要在保存之前记录日志</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Propagation.REQUIRED</span><br><span class="line">    <span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();   </span><br><span class="line">    saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>saveDept()本身就存在着一个事务，当调用insertLog()的时候，insertLog()的事务会加入到saveDept()事务中</strong></p>
<p>也就是说，<strong>saveDept()方法内始终是一个事务，如果在途中出现了异常，那么insertLog()的数据是会被回滚的【因为在同一事务内】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();    <span class="comment">// 加入当前事务</span></span><br><span class="line">    .. 异常, 会回滚</span><br><span class="line">        saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="当事务传播行为是Propagation-REQUIRED-NEW"><a href="#当事务传播行为是Propagation-REQUIRED-NEW" class="headerlink" title="当事务传播行为是Propagation.REQUIRED_NEW"></a>当事务传播行为是Propagation.REQUIRED_NEW</h4><ul>
<li><strong>现在有一个日志类，它的事务传播行为是Propagation.REQUIRED_NEW</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Log&#123;</span><br><span class="line">    Propagation.REQUIRED  </span><br><span class="line">        insertLog();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>现在，我要在保存之前记录日志</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Propagation.REQUIRED</span><br><span class="line">    <span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();   </span><br><span class="line">    saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行到saveDept()中的insertLog()方法时，<strong>insertLog()方法发现 saveDept()已经存在事务了，insertLog()会独自新开一个事务，直到事务关闭之后，再执行下面的方法</strong></p>
<p><strong>如果在中途中抛出了异常，insertLog()是不会回滚的，因为它的事务是自己的，已经提交了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();    <span class="comment">// 始终开启事务</span></span><br><span class="line">    .. 异常, 日志不会回滚</span><br><span class="line">        saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-IOC总结"><a href="#Spring-IOC总结" class="headerlink" title="Spring IOC总结"></a>Spring IOC总结</h2><p>结合《Spring 实战 (第4版)》和《精通Spring4.x 企业应用开发实战》两本书的IOC章节将其知识点整理起来~</p>
<h3 id="IOC和DI概述"><a href="#IOC和DI概述" class="headerlink" title="IOC和DI概述"></a>IOC和DI概述</h3><p>在《精通Spring4.x 企业应用开发实战》中对IOC的定义是这样的：</p>
<blockquote>
<p>IoC(Inversion of Control)控制反转，包含了两个方面：一、控制。二、反转</p>
</blockquote>
<p>我们可以简单认为：</p>
<ul>
<li>控制指的是：<strong>当前对象对内部成员的控制权</strong>。</li>
<li>反转指的是：这种控制权<strong>不由当前对象管理</strong>了，由其他(类,第三方容器)来管理。</li>
</ul>
<blockquote>
<p>IOC不够开门见山，于是Martin Fowler提出了DI(dependency injection)来替代IoC，即让调用类对某一接口实现类的依赖关系由第三方(容器或协作类)注入，以移除调用类对某一接口实现类的依赖。</p>
</blockquote>
<p>在《Spring 实战 (第4版)》中并没有提及到IOC，而是直接来说DI的：</p>
<blockquote>
<p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去</p>
</blockquote>
<p>从书上我们也可以发现：IoC和DI的定义(区别)并不是如此容易就可以说得清楚的了。这里我就<strong>简单摘抄</strong>一下：</p>
<ul>
<li>IoC(思想，设计模式)主要的实现方式有两种：依赖查找，<strong>依赖注入</strong>。</li>
<li>依赖注入是一种更可取的方式(实现的方式)</li>
</ul>
<p>对我们而言，其实也没必要分得那么清，混合一谈也不影响我们的理解…</p>
<p>再通过昨天写过的<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484243&idx=1&sn=972cbe6cdb578256e4d4771e7ca25de3&chksm=ebd74252dca0cb44419903758e8ca52d9ab287562f80be9365e305d6dcc2deaa45b40f9fd2e9#rd" target="_blank" rel="noopener">工厂模式理解了没有？</a>，我们现在就可以很清楚的发现，其实<strong>所谓的IOC容器就是一个大工厂</strong>【第三方容器】(Spring实现的功能很强大！比我们自己手写的工厂要好很多)。</p>
<p>使用IOC的好处(知乎@Intopass的回答)：</p>
<ol>
<li>不用自己组装，拿来就用。</li>
<li>享受单例的好处，效率高，不浪费空间。</li>
<li>便于单元测试，方便切换mock组件。</li>
<li>便于进行AOP操作，对于使用者是透明的。</li>
<li>统一配置，便于修改。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/23277575--Spring" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575--Spring</a> IoC有什么好处呢？</li>
</ul>
<h3 id="IOC容器的原理"><a href="#IOC容器的原理" class="headerlink" title="IOC容器的原理"></a>IOC容器的原理</h3><p>从上面就已经说了：IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系。</p>
<ul>
<li>原理就是通过Java的<strong>反射技术</strong>来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</li>
<li>再通过配置文件(xml)或者注解来<strong>描述</strong>类与类之间的关系</li>
<li>我们就可以通过这些配置信息和反射技术来<strong>构建</strong>出对应的对象和依赖关系了！</li>
</ul>
<p>上面描述的技术只要学过点Java的都能说出来，这一下子可能就会被面试官问倒了，我们<strong>简单</strong>来看看实际Spring IOC容器是怎么实现对象的创建和依赖的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979707" alt="img"></p>
<ol>
<li>根据Bean配置信息在容器内部创建Bean定义注册表</li>
<li>根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</li>
<li>将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用</li>
</ol>
<p>Spring容器(Bean工厂)可简单分成两种：</p>
<ul>
<li>BeanFactory<ul>
<li>这是最基础、面向Spring的</li>
</ul>
</li>
<li>ApplicationContext<ul>
<li>这是在BeanFactory基础之上，面向使用Spring框架的开发者。提供了一系列的功能！</li>
</ul>
</li>
</ul>
<p>几乎所有的应用场合<strong>都是</strong>使用ApplicationContext！</p>
<p>BeanFactory的继承体系：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979708" alt="img"></p>
<p>ApplicationContext的继承体系：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979710" alt="img"></p>
<p>其中在ApplicationContext子类中又有一个比较重要的：WebApplicationContext</p>
<ul>
<li>专门为Web应用准备的</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000014979711" alt="img"></p>
<p>Web应用与Spring融合：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979712" alt="img"></p>
<p>我们看看BeanFactory的生命周期：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979713" alt="img"></p>
<p>接下来我们再看看ApplicationContext的生命周期：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979714?w=874&h=758" alt="img"></p>
<p>初始化的过程都是比较长，我们可以<strong>分类</strong>来对其进行解析：</p>
<ul>
<li><strong>Bean自身的方法</strong>：如调用 Bean 构造函数实例化 Bean，调用 Setter 设置 Bean 的属性值以及通过<bean>的 init-method 和 destroy-method 所指定的方法；</bean></li>
<li><strong>Bean级生命周期接口方法</strong>：如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，这些接口方法由 Bean 类直接实现；</li>
<li><strong>容器级生命周期接口方法</strong>：在上图中带“★” 的步骤是由 InstantiationAwareBean PostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“ <strong>后处理器</strong>” 。 后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为Spring容器预先识别。当Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣Bean 进行加工处理</li>
</ul>
<p>ApplicationContext和BeanFactory<strong>不同之处</strong>在于：</p>
<ul>
<li>ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor<strong>后置器</strong>，并<strong>自动将它们注册到应用上</strong>下文中。而BeanFactory需要在代码中通过<strong>手工调用</strong><code>addBeanPostProcessor()</code>方法进行注册</li>
<li>ApplicationContext在<strong>初始化</strong>应用上下文的时候<strong>就实例化所有单实例的Bean</strong>。而BeanFactory在初始化容器的时候并未实例化Bean，<strong>直到</strong>第一次访问某个Bean时<strong>才</strong>实例化目标Bean。</li>
</ul>
<p>有了上面的知识点了，我们再来<strong>详细</strong>地看看Bean的初始化过程：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979715?w=883&h=588" alt="img"></p>
<p>简要总结：</p>
<ul>
<li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个<code>&lt;bean&gt;</code>解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中；</li>
<li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作；</li>
<li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。</li>
</ul>
<h3 id="IOC容器装配Bean"><a href="#IOC容器装配Bean" class="headerlink" title="IOC容器装配Bean"></a>IOC容器装配Bean</h3><h4 id="装配Bean方式"><a href="#装配Bean方式" class="headerlink" title="装配Bean方式"></a>装配Bean方式</h4><p>Spring4.x开始IOC容器装配Bean有<strong>4种</strong>方式：</p>
<ul>
<li>XML配置</li>
<li>注解</li>
<li>JavaConfig</li>
<li>基于Groovy DSL配置(这种很少见)</li>
</ul>
<p>总的来说：我们以XML配置+注解来装配Bean得多，其中<strong>注解这种方式占大部分</strong>！</p>
<h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>依赖注入的方式有3种方式：</p>
<ul>
<li><strong>属性注入</strong>–&gt;通过<code>setter()</code>方法注入</li>
<li>构造函数注入</li>
<li>工厂方法注入</li>
</ul>
<p>总的来说使用<strong>属性注入</strong>是比较灵活和方便的，这是大多数人的选择！</p>
<h4 id="对象之间关系"><a href="#对象之间关系" class="headerlink" title="对象之间关系"></a>对象之间关系</h4><p><code>&lt;bean&gt;</code>对象之间有三种关系：</p>
<ul>
<li>依赖–&gt;挺少用的(使用depends-on就是依赖关系了–&gt;前置依赖【依赖的Bean需要初始化之后，当前Bean才会初始化】)</li>
<li>继承–&gt;可能会用到(指定abstract和parent来实现继承关系)</li>
<li>引用–&gt;最常见(使用ref就是引用关系了)</li>
</ul>
<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><ul>
<li>单例Singleton</li>
<li>多例prototype</li>
<li>与Web应用环境相关的Bean作用域<ul>
<li>reqeust</li>
<li>session</li>
</ul>
</li>
</ul>
<p>使用到了Web应用环境相关的Bean作用域的话，是需要我们<strong>手动配置代理</strong>的~</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979716?w=690&h=307" alt="img"></p>
<p>原因也很简单：因为我们默认的Bean是单例的，为了适配Web应用环境相关的Bean作用域—&gt;每个request都需要一个对象，此时我们<strong>返回一个代理对象</strong>出去就可以完成我们的需求了！</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979717" alt="img"></p>
<hr>
<p>将Bean配置单例的时候还有一个问题：</p>
<ul>
<li>如果我们的Bean配置的是单例，而Bean对象里边的<strong>成员对象我们希望是多例的话</strong>。那怎么办呢？？</li>
<li>默认的情况下我们的Bean单例，返回的成员对象也默认是单例的(因为对象就只有那么一个)！</li>
</ul>
<p>此时我们需要用到了<code>lookup</code>方法注入，使用也很简单，看看例子就明白了：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979718?w=715&h=146" alt="img"></p>
<h4 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h4><p>昨天在刷书的时候刚好看到了有人在知乎邀请我回答这个问题：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979719" alt="img"></p>
<p>结合两本书的知识点，可以归纳成两种解决方案：</p>
<ul>
<li>使用<code>@Primary</code>注解设置为<strong>首选</strong>的注入Bean</li>
<li>使用<code>@Qualifier</code>注解设置<strong>特定名称的Bean</strong>来限定注入！<ul>
<li>也可以使用自定义的注解来标识</li>
</ul>
</li>
</ul>
<h4 id="引用属性文件以及Bean属性"><a href="#引用属性文件以及Bean属性" class="headerlink" title="引用属性文件以及Bean属性"></a>引用属性文件以及Bean属性</h4><p>之前在写配置文件的时候都是直接将我们的数据库配置信息在里面写死的了：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979720?w=1221&h=288" alt="img"></p>
<p>其实我们有<strong>更优雅的做法</strong>：将这些配置信息写到配置文件上(因为这些配置信息很可能是会变的，而且有可能被多个配置文件引用).</p>
<ul>
<li>如此一来，我们<strong>改的时候就十分方便</strong>了。</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000014979721?w=1400&h=435" alt="img"></p>
<p>引用配置文件的数据使用的是<code>${}</code></p>
<p>除了引用配置文件上的数据，我们还可以<strong>引用Bean的属性</strong>：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979722?w=874&h=217" alt="img"></p>
<p><img src="https://segmentfault.com/img/remote/1460000014979723" alt="img"></p>
<p>引用Bean的属性使用的是<code>#{}</code></p>
<p>在这种技术在《Spring 实战 第四版》称之为Spring EL，跟我们之前学过的EL表达式是类似的。主要的功能就是上面的那种，想要更深入了解可参考下面的链接：</p>
<ul>
<li><a href="http://www.cnblogs.com/leiOOlei/p/3543222.html" target="_blank" rel="noopener">http://www.cnblogs.com/leiOOlei/p/3543222.html</a></li>
</ul>
<h4 id="组合配置文件"><a href="#组合配置文件" class="headerlink" title="组合配置文件"></a>组合配置文件</h4><p>xml文件之间组合：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979724?w=1091&h=396" alt="img"></p>
<p>xml和javaconfig互相组合的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.通过构造函数加载配置类</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConf<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过编码方式注册配置类</span></span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(DaoConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ctx.register(ServiceConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ctx.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过XML组装@Configuration配置类所提供的配置信息</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/conf/beans2.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.通过@Configuration组装XML配置所提供的配置信息</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(LogonAppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.@Configuration的配置类相互引用</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(DaoConfig<span class="class">.<span class="keyword">class</span>,<span class="title">ServiceConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    LogonService logonService = ctx.getBean(LogonService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println((logonService.getLogDao() !=<span class="keyword">null</span>));</span><br><span class="line">    logonService.printHelllo();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种的例子：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979725" alt="img"></p>
<p>第二种的例子：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979726?w=859&h=341" alt="img"></p>
<p><img src="https://segmentfault.com/img/remote/1460000014979727" alt="img"></p>
<p>第三种的例子：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979728?w=1159&h=308" alt="img"></p>
<p>第四种的例子：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979729" alt="img"></p>
<p>第五种的例子：</p>
<ul>
<li>代码由上可见</li>
</ul>
<h4 id="装配Bean总结"><a href="#装配Bean总结" class="headerlink" title="装配Bean总结"></a>装配Bean总结</h4><p>总的来说，Spring IOC容器就是在创建Bean的时候有很多的方式给了我们实现，其中也包括了很多关于Bean的配置~</p>
<p>对于Bean相关的注入教程代码和简化配置(p和c名称空间)我就不一一说明啦，你们去看<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483942&idx=1&sn=f71e1adeeaea3430dd989ef47cf9a0b3&chksm=ebd74327dca0ca3141c8636e95d41629843d2623d82be799cf72701fb02a665763140b480aec#rd" target="_blank" rel="noopener">Spring入门这一篇就够了</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483946&idx=1&sn=bb21dfd83cf51214b2789c9ae214410f&chksm=ebd7432bdca0ca3ded6ad9b50128d29267f1204bf5722e5a0501a1d38af995c1ee8e37ae27e7#rd" target="_blank" rel="noopener">Spring【依赖注入】就是这么简单</a>就行了。</p>
<p>总的对比图：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979730?w=720&h=159" alt="img"><br><img src="https://segmentfault.com/img/remote/1460000014979731" alt="img"></p>
<p>分别的应用场景：</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979732?w=1061&h=316" alt="img"></p>
<p>至于一些小的知识点：</p>
<ul>
<li>方法替换<ul>
<li>使用某个Bean的方法替换成另一个Bean的方法</li>
</ul>
</li>
<li>属性编辑器<ul>
<li>Spring可以对基本类型做转换就归结于属性编辑器的功劳！</li>
</ul>
</li>
<li>国际化<ul>
<li>使用不同语言(英语、中文)的操作系统去显式不同的语言</li>
</ul>
</li>
<li>profile与条件化的Bean<ul>
<li>满足了某个条件才初始化Bean，这可以方便切换生产环境和开发环境~</li>
</ul>
</li>
<li>容器事件<ul>
<li>类似于我们的Servlet的监听器，只不过它是在Spring中实现了~</li>
</ul>
</li>
</ul>
<p>上面这些小知识点比较少情况会用到，这也不去讲解啦。知道有这么一回事，到时候查查就会用啦<del>~</del></p>
<p>参考资料：</p>
<ul>
<li>《Spring 实战》</li>
<li>《精通Spring4.x 企业应用开发实战》</li>
<li><a href="https://zhuanlan.zhihu.com/p/29344811--Spring" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29344811--Spring</a> IOC原理总结</li>
<li><a href="https://blog.csdn.net/u014079773/article/details/52453002---Java面试题集（七）--Spring常见面试问题" target="_blank" rel="noopener">https://blog.csdn.net/u014079773/article/details/52453002---Java面试题集（七）--Spring常见面试问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31527327--69" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31527327--69</a> 个经典 Spring 面试题和答案</li>
</ul>
<h2 id="Spring-AOP总结"><a href="#Spring-AOP总结" class="headerlink" title="Spring AOP总结"></a>Spring AOP总结</h2><p>结合《Spring 实战 (第4版)》和《精通Spring4.x 企业应用开发实战》两本书的AOP章节将其知识点整理起来~</p>
<h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><p>AOP称为面向切面编程，那我们怎么理解面向切面编程？？</p>
<p>我们可以先看看下面这段代码：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018891?w=773&h=474" alt="img"></p>
<p>我们学Java面向对象的时候，如果代码重复了怎么办啊？？可以分成下面几个步骤：</p>
<ul>
<li>1：抽取成方法</li>
<li>2：抽取类</li>
</ul>
<p>抽取成类的方式我们称之为：<strong>纵向抽取</strong></p>
<ul>
<li>通过继承的方式实现纵向抽取</li>
</ul>
<p>但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)<strong>依附在我们业务类的方法逻辑中</strong>！</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018892" alt="img"></p>
<p>现在纵向抽取的方式不行了，AOP的理念：就是将<strong>分散在各个业务逻辑代码中相同的代码通过横向切割的方式</strong>抽取到一个独立的模块中！</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018893" alt="img"></p>
<p>上面的图也很清晰了，将重复性的逻辑代码横切出来其实很容易(我们简单可认为就是封装成一个类就好了)，但我们要将这些<strong>被我们横切出来的逻辑代码融合到业务逻辑中</strong>，来完成和之前(没抽取前)一样的功能！这就是AOP首要解决的问题了！</p>
<h3 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h3><blockquote>
<p>被我们横切出来的逻辑代码融合到业务逻辑中，来完成和之前(没抽取前)一样的功能</p>
</blockquote>
<p>没有学Spring AOP之前，我们就可以使用代理来完成。</p>
<ul>
<li>如果看过我写的<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1#rd" target="_blank" rel="noopener">给女朋友讲解什么是代理模式</a>这篇文章的话，一定就不难理解上面我说的那句话了</li>
<li>代理能干嘛？代理可以帮我们<strong>增强对象的行为</strong>！使用动态代理实质上就是<strong>调用时拦截对象方法，对方法进行改造、增强</strong>！</li>
</ul>
<p>其实Spring AOP的底层原理就是<strong>动态代理</strong>！</p>
<p>来源《精通Spring4.x 企业应用开发实战》一段话：</p>
<blockquote>
<p>Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器，它在<strong>运行期通过代理方式向目标类织入增强代码</strong>。在Spring中可以无缝地将Spring AOP、IoC和AspectJ整合在一起。</p>
</blockquote>
<p>来源《Spring 实战 (第4版)》一句话：</p>
<blockquote>
<p>Spring AOP构建在动态代理基础之上，因此，<strong>Spring对AOP的支持局限于方法拦截</strong>。</p>
</blockquote>
<p>在Java中动态代理有<strong>两种</strong>方式：</p>
<ul>
<li>JDK动态代理</li>
<li>CGLib动态代理</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000015018894?w=485&h=159" alt="img"></p>
<p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了~~</p>
<ul>
<li>CGLib代理其生成的动态代理对象是目标类的子类</li>
<li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li>
</ul>
<p>那么JDK代理和CGLib代理我们该用哪个呢？？在《精通Spring4.x 企业应用开发实战》给出了建议：</p>
<ul>
<li>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</li>
</ul>
<p>原因：</p>
<ul>
<li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li>
<li>如果是单例的代理，推荐使用CGLib</li>
</ul>
<p>看到这里我们就应该知道什么是Spring AOP(面向切面编程)了：<strong>将相同逻辑的重复代码横向抽取出来，使用动态代理技术将这些重复代码织入到目标对象方法中，实现和原来一样的功能</strong>。</p>
<ul>
<li>这样一来，我们就在<strong>写业务时只关心业务代码</strong>，而不用关心与业务无关的代码</li>
</ul>
<h3 id="AOP的实现者"><a href="#AOP的实现者" class="headerlink" title="AOP的实现者"></a>AOP的实现者</h3><p>AOP除了有Spring AOP实现外，还有著名的AOP实现者：AspectJ，也有可能大家没听说过的实现者：JBoss AOP~~</p>
<p>我们下面来说说AspectJ扩展一下知识面：</p>
<blockquote>
<p>AspectJ是<strong>语言级别</strong>的AOP实现，扩展了Java语言，定义了AOP语法，能够在<strong>编译期</strong>提供横切代码的织入，所以它有<strong>专门的编译器</strong>用来生成遵守Java字节码规范的Class文件。</p>
</blockquote>
<p>而Spring借鉴了AspectJ很多非常有用的做法，<strong>融合了AspectJ实现AOP的功能</strong>。但Spring AOP本质上<strong>底层还是动态代理</strong>，所以Spring AOP是不需要有专门的编辑器的~</p>
<h3 id="AOP的术语"><a href="#AOP的术语" class="headerlink" title="AOP的术语"></a>AOP的术语</h3><p>嗯，AOP搞了好几个术语出来~~两本书都有讲解这些术语，我会尽量让大家看得明白的：</p>
<p><strong>连接点</strong>(Join point)：</p>
<ul>
<li><strong>能够被拦截的地方</strong>：Spring AOP是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点~</li>
</ul>
<p><strong>切点</strong>(Poincut)：</p>
<ul>
<li><strong>具体定位的连接点</strong>：上面也说了，每个方法都可以称之为连接点，我们<strong>具体定位到某一个方法就成为切点</strong>。</li>
</ul>
<p><strong>增强/通知</strong>(Advice)：</p>
<ul>
<li>表示添加到切点的一段<strong>逻辑代码</strong>，并定位连接点的<strong>方位信息</strong>。<ul>
<li>简单来说就定义了是干什么的，具体是在哪干</li>
<li>Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用！</li>
</ul>
</li>
</ul>
<p><strong>织入</strong>(Weaving)：</p>
<ul>
<li>将<code>增强/通知</code>添加到目标类的具体连接点上的过程。</li>
</ul>
<p><strong>引入/引介</strong>(Introduction)：</p>
<ul>
<li><code>引入/引介</code>允许我们<strong>向现有的类添加新方法或属性</strong>。是一种<strong>特殊</strong>的增强！</li>
</ul>
<p><strong>切面</strong>(Aspect)：</p>
<ul>
<li>切面由切点和<code>增强/通知</code>组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</li>
</ul>
<p>在《Spring 实战 (第4版)》给出的总结是这样子的：</p>
<blockquote>
<p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p>
</blockquote>
<p>总的来说：</p>
<ul>
<li>这些术语可能翻译过来不太好理解，但对我们正常使用AOP的话<strong>影响并没有那么大</strong>~~看多了就知道它是什么意思了。</li>
</ul>
<h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><p>Spring提供了3种类型的AOP支持：</p>
<ul>
<li>基于代理的经典SpringAOP<ul>
<li>需要实现接口，手动创建代理</li>
</ul>
</li>
<li>纯POJO切面<ul>
<li>使用XML配置，aop命名空间</li>
</ul>
</li>
<li><code>@AspectJ</code>注解驱动的切面<ul>
<li>使用注解的方式，这是最简洁和最方便的！</li>
</ul>
</li>
</ul>
<h3 id="基于注解和命名空的AOP编程"><a href="#基于注解和命名空的AOP编程" class="headerlink" title="基于注解和命名空的AOP编程"></a>基于注解和命名空的AOP编程</h3><p>Spring在新版本中对AOP功能进行了增强，体现在这么几个方面：</p>
<ul>
<li>在XML配置文件中为AOP提供了aop命名空间</li>
<li>增加了AspectJ切点表达式语言的支持</li>
<li>可以无缝地集成AspectJ</li>
</ul>
<p>那我们使用<code>@AspectJ</code>来玩AOP的话，学什么？？其实也就是上面的内容，学如何设置切点、创建切面、增强的内容是什么…</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018903?w=815&h=774" alt="img"></p>
<p>具体的切点表达式使用还是前往：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483954&idx=1&sn=b34e385ed716edf6f58998ec329f9867&chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4#rd" target="_blank" rel="noopener">Spring【AOP模块】就这么简单</a>看吧~~</p>
<p>对应的增强注解：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018904?w=797&h=726" alt="img"></p>
<p><img src="https://segmentfault.com/img/remote/1460000015018905" alt="img"></p>
<h4 id="使用引介-引入功能实现为Bean引入新方法"><a href="#使用引介-引入功能实现为Bean引入新方法" class="headerlink" title="使用引介/引入功能实现为Bean引入新方法"></a>使用引介/引入功能实现为Bean引入新方法</h4><p>其实前置啊、后置啊这些很容易就理解了，整篇文章看下来就只有这个引介/引入切面有点搞头。于是我们就来玩玩吧~</p>
<p>我们来看一下具体的用法吧，现在我有个服务员的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向客人打招呼</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line">    <span class="comment">// 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一位年轻服务员实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:greet to "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NeedTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:serving "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我想做的就是：<strong>想这个服务员可以充当售货员的角色，可以卖东西</strong>！当然了，我肯定不会加一个卖东西的方法到Waiter接口上啦，因为这个是暂时的~</p>
<p>所以，我搞了一个售货员接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖东西</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods, String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个售货员实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartSeller</span> <span class="keyword">implements</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖东西</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods,String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmartSeller: sell "</span>+goods +<span class="string">" to "</span>+clientName+<span class="string">"..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们的类图是这样子的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018906?w=785&h=230" alt="img"></p>
<p>现在我想干的就是：<strong>借助AOP的引入/引介切面，来让我们的服务员也可以卖东西</strong>！</p>
<p>我们的引入/引介切面具体是这样干的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableSellerAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"com.smart.NaiveWaiter"</span>,  <span class="comment">// 指定服务员具体的实现</span></span><br><span class="line">    defaultImpl = SmartSeller<span class="class">.<span class="keyword">class</span>) // 售货员具体的实现</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Seller</span> <span class="title">seller</span></span>; <span class="comment">// 要实现的目标接口 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写了这个切面类会发生什么？？</p>
<ul>
<li>切面技术将SmartSeller融合到NaiveWaiter中，这样<strong>NaiveWaiter就实现了Seller接口</strong>！！！！</li>
</ul>
<p>是不是很神奇？？我也觉得很神奇啊，我们来测试一下：</p>
<p>我们的<code>bean.xml</code>文件很简单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"waiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.aspectj.basic.EnableSellerAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/aspectj/basic/beans.xml"</span>);</span><br><span class="line">        Waiter waiter = (Waiter) ctx.getBean(<span class="string">"waiter"</span>);</span><br><span class="line">        <span class="comment">// 调用服务员原有的方法</span></span><br><span class="line">        waiter.greetTo(<span class="string">"Java3y"</span>);</span><br><span class="line">        waiter.serveTo(<span class="string">"Java3y"</span>);</span><br><span class="line">        <span class="comment">// 通过引介/引入切面已经将waiter服务员实现了Seller接口，所以可以强制转换</span></span><br><span class="line">        Seller seller = (Seller) waiter;</span><br><span class="line">        seller.sell(<span class="string">"水军"</span>, <span class="string">"Java3y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/remote/1460000015018907?w=508&h=93" alt="img"></p>
<p>具体的调用过程是这样子的：</p>
<blockquote>
<p>当引入接口方法被调用时，代理对象会把此调用委托给实现了新接口的某个其他对象。实际上，一个Bean的实现被拆分到多个类中</p>
</blockquote>
<p><img src="https://segmentfault.com/img/remote/1460000015018908?w=681&h=425" alt="img"></p>
<h4 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h4><p>我们知道注解很方便，<strong>但是</strong>，要想使用<strong>注解的方式</strong>使用Spring AOP就<strong>必须要有源码</strong>(因为我们要在切面类上添加注解)。如果没有源码的话，我们就得使用XML来声明切面了~</p>
<p>其实就跟注解差不多的功能：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018909" alt="img"></p>
<p>我们就直接来个例子终结掉它吧：</p>
<p>首先我们来测试一下与传统的SpringAOP结合的advisor是怎么用的：</p>
<p>实现类：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018910?w=966&h=293" alt="img"></p>
<p>xml配置文件：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018911?w=1371&h=154" alt="img"></p>
<p>…….</p>
<p>一个一个来讲解还是太花时间了，我就一次性用图的方式来讲啦：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018912" alt="img"></p>
<p>最后还有一个切面类型总结图，看完就几乎懂啦：</p>
<p><img src="https://segmentfault.com/img/remote/1460000015018913" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看起来AOP有很多很多的知识点，其实我们只要记住AOP的核心概念就行啦。</p>
<p>下面是我的简要总结AOP：</p>
<ul>
<li>AOP的底层实际上是动态代理，动态代理分成了JDK动态代理和CGLib动态代理。如果被代理对象没有接口，那么就使用的是CGLIB代理(也可以直接配置使用CBLib代理)</li>
<li>如果是单例的话，那我们最好使用CGLib代理，因为CGLib代理对象运行速度要比JDK的代理对象要快</li>
<li>AOP既然是基于动态代理的，那么它只能对方法进行拦截，它的层面上是方法级别的</li>
<li>无论经典的方式、注解方式还是XML配置方式使用Spring AOP的原理都是一样的，只不过形式变了而已。一般我们使用注解的方式使用AOP就好了。</li>
<li>注解的方式使用Spring AOP就了解几个切点表达式，几个增强/通知的注解就完事了，是不是贼简单…使用XML的方式和注解其实没有很大的区别，很快就可以上手啦。</li>
<li>引介/引入切面也算是一个比较亮的地方，可以用代理的方式为某个对象实现接口，从而能够使用借口下的方法。这种方式是非侵入式的~</li>
<li>要增强的方法还可以接收与被代理方法一样的参数、绑定被代理方法的返回值这些功能…</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><ul>
<li>如果<strong>嵌套调用</strong>含有事务的方法，在Spring事务管理中，这属于哪个知识点？</li>
<li>我们使用的框架可能是<code>Hibernate/JPA</code>或者是<code>Mybatis</code>，都知道的底层是需要一个<code>session/connection</code>对象来帮我们执行操作的。要保证事务的完整性，我们需要多组数据库操作要使用<strong>同一个</strong><code>session/connection</code>对象，而我们又知道Spring IOC所管理的对象默认都是<strong>单例</strong>的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？</li>
<li>人家所说的BPP又是啥东西？</li>
<li>Spring事务管理重要接口有哪几个？</li>
</ul>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>阅读这篇文章的同学我<strong>默认</strong>大家都对Spring事务相关知识有一定的了解了。(ps:如果不了解点解具体的文章去阅读再回到这里来哦)</p>
<p>我们都知道，Spring事务是Spring AOP的最佳实践之一，所以说<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483954&idx=1&sn=b34e385ed716edf6f58998ec329f9867&chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP入门基础知识(简单配置，使用)</a>是需要先知道的。如果想更加全面了解AOP可以看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484251&idx=1&sn=f792c5a1835af2c17f260be2055b5776&chksm=ebd7425adca0cb4cc3a4e2ee61bdfa99508ea564e4ba4fd4ed54054b12fed76694b2b3afc26e&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP重要知识点(术语介绍、全面使用)</a>。说到AOP就不能不说<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP底层原理：动态代理设计模式</a>。到这里，对AOP已经有一个基础的认识了。于是我们就可以<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483965&idx=1&sn=2cd6c1530e3f81ca5ad35335755ed287&chksm=ebd7433cdca0ca2a70cb8419306eb9b3ccaa45b524ddc5ea549bf88cf017d6e5c63c45f62c6e&scene=21##wechat_redirect" target="_blank" rel="noopener">使用XML/注解方式来配置Spring事务管理</a>。</p>
<p>在IOC学习中，可以知道的是<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484247&idx=1&sn=e228e29e344559e469ac3ecfa9715217&chksm=ebd74256dca0cb40059f3f627fc9450f916c1e1b39ba741842d91774f5bb7f518063e5acf5a0&scene=21##wechat_redirect" target="_blank" rel="noopener">Spring中Bean的生命周期(引出BPP对象)</a>并且<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484239&idx=1&sn=6560be96e456b513cb1e4f78a740a258&chksm=ebd7424edca0cb584906fb97679cf2ca557f430fbc87d2c86ce0652d2e3c36c2528466942df5&scene=21##wechat_redirect" target="_blank" rel="noopener">IOC所管理的对象默认都是单例的：单例设计模式</a>，单例对象如果有”<strong>状态</strong>“(有成员变量)，那么多线程访问这个单例对象，可能就造成线程不安全。那么<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484194&idx=1&sn=ed1241fcba5d3e85b6d900d8667f04f6&chksm=ebd74223dca0cb35fe16a267c88ac9e5159825b27c278fb165a8c50d681e1340b73cfd69ae0d&scene=21##wechat_redirect" target="_blank" rel="noopener">何为线程安全？</a>，解决线程安全有很多方式，但其中有一种：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484118&idx=1&sn=da3e4c4cfd0642687c5d7bcef543fe5b&chksm=ebd743d7dca0cac19a82c7b29b5b22c4b902e9e53bd785d066b625b4272af2a6598a0cc0f38e&scene=21##wechat_redirect" target="_blank" rel="noopener">让每一个线程都拥有自己的一个变量：ThreadLocal</a></p>
<h3 id="两个不靠谱直觉的例子"><a href="#两个不靠谱直觉的例子" class="headerlink" title="两个不靠谱直觉的例子"></a>两个不靠谱直觉的例子</h3><h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>之前朋友问了我一个例子：</p>
<p>在Service层抛出Exception，在Controller层捕获，那如果在Service中有异常，那会事务回滚吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service方法</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">    employeeRepository.save(employee);</span><br><span class="line">    <span class="comment">// 假设这里出了Exception</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Controller调用</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        employee = employeeService.addEmployee();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我<strong>第一反应</strong>：不会回滚吧。</p>
<ul>
<li>我当时是这样想的：因为Service层已经抛出了异常，由Controller捕获。那是否回滚应该由Controller的catch代码块中逻辑来决定，如果catch代码块没有回滚，那应该是不会回滚。</li>
</ul>
<p>但朋友经过测试说，可以回滚阿。(pappapa打脸)</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075072?w=1189&h=769" alt="发生了运行时Exception，Spring事务管理自动回滚"></p>
<p>看了一下文档，原来文档有说明：</p>
<blockquote>
<p>By default checked exceptions do not result in the transactional interceptor marking the transaction for rollback and instances of RuntimeException and its subclasses do</p>
</blockquote>
<p>结论：如果是编译时异常不会自动回滚，<strong>如果是运行时异常，那会自动回滚</strong>！</p>
<h4 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h4><blockquote>
<p>第二个例子来源于知乎@柳树文章，文末会给出相应的URL</p>
</blockquote>
<p>我们都知道，带有<code>@Transactional</code>注解所包围的方法就能被Spring事务管理起来，那如果我在<strong>当前类下使用一个没有事务的方法去调用一个有事务的方法</strong>，那我们这次调用会怎么样？是否会有事务呢？</p>
<p>用代码来描述一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有事务的方法去调用有事务的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee2Controller</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addEmployee();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    employeeRepository.deleteAll();</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 模拟异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我第一直觉是：这跟Spring事务的传播机制有关吧。</p>
<p>其实这跟Spring事务的传播机制<strong>没有关系</strong>，下面我讲述一下：</p>
<ul>
<li>Spring事务管理用的是AOP，AOP底层用的是动态代理。所以如果我们在类或者方法上标注注解<code>@Transactional</code>，那么会生成一个<strong>代理对象</strong>。</li>
</ul>
<p>接下来我用图来说明一下：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075073?w=888&h=659" alt="Spring会自动生成代理对象"></p>
<p>显然地，我们拿到的是代理(Proxy)对象，调用<code>addEmployee2Controller()</code>方法，而<code>addEmployee2Controller()</code>方法的逻辑是<code>target.addEmployee()</code>，调用回原始对象(target)的<code>addEmployee()</code>。所以这次的调用<strong>压根就没有事务存在</strong>，更谈不上说Spring事务传播机制了。</p>
<p>原有的数据：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075074" alt="原有的数据"></p>
<p>测试结果：压根就没有事务的存在</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075075" alt="没有事务的存在"></p>
<h5 id="再延伸一下"><a href="#再延伸一下" class="headerlink" title="再延伸一下"></a>再延伸一下</h5><p>从上面的测试我们可以发现：如果是在本类中没有事务的方法来调用标注注解<code>@Transactional</code>方法，最后的结论是没有事务的。那如果我将这个标注注解的方法<strong>移到</strong>别的Service对象上，有没有事务？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        employeeRepository.deleteAll();</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 模拟异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line">    <span class="comment">// 没有事务的方法去调用别的类有事务的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee2Controller</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testService.addEmployee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075076?w=1300&h=799" alt="抛出了运行时异常，但我们的数据还是存在的！"></p>
<p>因为我们用的是代理对象(Proxy)去调用<code>addEmployee()</code>方法，那就当然有事务了。</p>
<h3 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h3><blockquote>
<p>如果<strong>嵌套调用</strong>含有事务的方法，在Spring事务管理中，这属于哪个知识点？</p>
</blockquote>
<p>在当前<strong>含有事务方法内部调用其他的方法</strong>(无论该方法是否含有事务)，这就属于Spring事务传播机制的知识点范畴了。</p>
<p>Spring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：</p>
<ul>
<li>基于接口代理(JDK代理)<ul>
<li>基于接口代理，凡是类的方法<strong>非public修饰</strong>，或者<strong>用了static关键字</strong>修饰，那这些方法都不能被Spring AOP增强</li>
</ul>
</li>
<li>基于CGLib代理(子类代理)<ul>
<li>基于子类代理，凡是类的方法<strong>使用了private、static、final修饰</strong>，那这些方法都不能被Spring AOP增强</li>
</ul>
</li>
</ul>
<p>值得说明的是：那些不能被Spring AOP增强的方法<strong>并不是不能</strong>在事务环境下工作了。只要它们<strong>被外层的事务方法调用了</strong>，由于Spring事务管理的传播级别，内部方法也可以<strong>工作</strong>在外部方法所启动的<strong>事务上下文中</strong>。</p>
<h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><blockquote>
<p>我们使用的框架可能是<code>Hibernate/JPA</code>或者是<code>Mybatis</code>，都知道的底层是需要一个<code>session/connection</code>对象来帮我们执行操作的。要保证事务的完整性，我们需要<strong>多组数据库操作要使用同一个</strong><code>session/connection</code>对象，而我们又知道Spring IOC所管理的对象默认都是<strong>单例</strong>的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？</p>
</blockquote>
<p>回想一下当年我们学Mybaits的时候，是怎么编写<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483937&idx=2&sn=28c7827639bb6ac0296746c4c4343c59&chksm=ebd74320dca0ca36b763b3975665fc38a7e921f9ecaef1aaea3a7c757063a29222cd00b3d3b6&scene=21##wechat_redirect" target="_blank" rel="noopener">Session工具类</a>？</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075077" alt="Mybatis工具类部分代码截图"></p>
<p>没错，用的就是ThreadLocal，同样地，Spring也是用的ThreadLocal。</p>
<p>以下内容来源《精通 Spring4.x》</p>
<blockquote>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、<strong>TransactionSynchronizationManager</strong>、LocaleContextHolder等）中非线程安全状态的“状态性对象”采用ThreadLocal封装，让它们也成为线程安全的“状态性对象”，因此，有状态的Bean就能够以singleton的方式在多线程中工作。</p>
</blockquote>
<p>我们可以试着点一下进去TransactionSynchronizationManager中看一下：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075078" alt="全都是ThreadLocal"></p>
<h3 id="啥是BPP？"><a href="#啥是BPP？" class="headerlink" title="啥是BPP？"></a>啥是BPP？</h3><p>BBP的全称叫做：BeanPostProcessor，一般我们俗称<strong>对象后处理器</strong></p>
<ul>
<li>简单来说，通过BeanPostProcessor可以对我们的对象进行“<strong>加工处理</strong>”。</li>
</ul>
<p>Spring管理Bean(或者说Bean的生命周期)也是一个<strong>常考</strong>的知识点，我在秋招也<strong>重新</strong>整理了一下步骤，因为比较重要，所以还是在这里贴一下吧：</p>
<ol>
<li>ResouceLoader加载配置信息</li>
<li>BeanDefintionReader解析配置信息，生成一个一个的BeanDefintion</li>
<li>BeanDefintion由BeanDefintionRegistry管理起来</li>
<li>BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)</li>
<li>实例化Bean</li>
<li>如果该Bean<code>配置/实现</code>了InstantiationAwareBean，则调用对应的方法</li>
<li>使用BeanWarpper来完成对象之间的属性配置(依赖)</li>
<li>如果该Bean<code>配置/实现了</code>Aware接口，则调用对应的方法</li>
<li>如果该Bean配置了BeanPostProcessor的before方法，则调用</li>
<li>如果该Bean配置了<code>init-method</code>或者实现InstantiationBean，则调用对应的方法</li>
<li>如果该Bean配置了BeanPostProcessor的after方法，则调用</li>
<li>将对象放入到HashMap中</li>
<li>最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</li>
</ol>
<p><img src="https://segmentfault.com/img/remote/1460000018075079?w=1052&h=852" alt="Application中Bean的声明周期"></p>
<p>其中也有关于BPP图片：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018075080" alt="BBP所在的位置"></p>
<h4 id="为什么特意讲BPP？"><a href="#为什么特意讲BPP？" class="headerlink" title="为什么特意讲BPP？"></a>为什么特意讲BPP？</h4><p>Spring AOP编程底层通过的是动态代理技术，在调用的时候肯定用的是<strong>代理对象</strong>。那么Spring是怎么做的呢？</p>
<blockquote>
<p>我只需要写一个BPP，在postProcessBeforeInitialization或者postProcessAfterInitialization方法中，对对象进行判断，看他需不需要织入切面逻辑，如果需要，那我就根据这个对象，生成一个代理对象，然后返回这个代理对象，那么最终注入容器的，自然就是代理对象了。</p>
</blockquote>
<p>Spring提供了BeanPostProcessor，就是让我们可以对有需要的对象进行“<strong>加工处理</strong>”啊！</p>
<h3 id="认识Spring事务几个重要的接口"><a href="#认识Spring事务几个重要的接口" class="headerlink" title="认识Spring事务几个重要的接口"></a>认识Spring事务几个重要的接口</h3><p>Spring事务可以分为两种：</p>
<ul>
<li>编程式事务(通过代码的方式来实现事务)</li>
<li>声明式事务(通过配置的方式来实现事务)</li>
</ul>
<p>编程式事务在Spring实现相对简单一些，而声明式事务因为封装了大量的东西(一般我们使用简单，里头都非常复杂)，所以声明式事务实现要难得多。</p>
<p>在编程式事务中有以下几个重要的了接口：</p>
<ul>
<li>TransactionDefinition：定义了Spring兼容的<strong>事务属性</strong>(比如事务隔离级别、事务传播、事务超时、是否只读状态)</li>
<li>TransactionStatus：代表了事务的具体<strong>运行状态</strong>(获取事务运行状态的信息，也可以通过该接口<strong>间接</strong>回滚事务等操作)</li>
<li>PlatformTransactionManager：事务管理器接口(定义了一组行为，具体实现交由不同的持久化框架来完成—<strong>类比</strong>JDBC)</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000018075081?w=1498&h=796" alt="PlatformTransactionManager解析"></p>
<p>在声明式事务中，除了TransactionStatus和PlatformTransactionManager接口，还有几个重要的接口：</p>
<ul>
<li>TransactionProxyFactoryBean：生成代理对象</li>
<li>TransactionInterceptor：实现对象的拦截</li>
<li>TransactionAttrubute：事务配置的数据</li>
</ul>
<p>参考资料：</p>
<ul>
<li>那些年，我们一起追的Spring<ul>
<li><a href="https://zhuanlan.zhihu.com/p/41961670" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41961670</a></li>
</ul>
</li>
<li>《精通Spring 4.x 企业应用开发实战》</li>
<li>《Spring技术内幕》</li>
</ul>
<h2 id="Spring-与设计模式"><a href="#Spring-与设计模式" class="headerlink" title="Spring 与设计模式"></a>Spring 与设计模式</h2><p><strong>IoC(Inversion of Control,控制翻转)</strong>是Spring中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring中的IOC容器)实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><strong>Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong>IOC容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<blockquote>
<p>在实际项目中一个Service类如果有几百甚至上千个类作为它的底层，我们需要实例化这个Service，你可能要每次都要搞清这个Service所有底层类的构造函数，这可能会把人逼疯。如果利用IOC的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC的理解，推荐看这一下<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">知乎的一个回答</a>，非常不错。</p>
</blockquote>
<p><strong>控制翻转怎么理解呢?</strong>举个例子：”对象a依赖了对象b，当对象a需要使用对象b的时候必须自己去创建。但是当系统引入了IOC容器后，对象a和对象b之前就失去了直接的联系。这个时候，当对象a需要使用对象b的时候，我们可以指定IOC容器去创建一个对象b注入到对象a中”。对象a获得依赖对象b的过程，由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p>Spring使用工厂模式可以通过<code>BeanFactory</code>或<code>ApplicationContext</code>创建bean对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code>：延迟注入(使用到某个bean的时候才会注入)，相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code>：容器启动的时候，不管你用没用到，一次性创建所有bean 。<code>BeanFactory</code>仅提供了最基本的依赖注入支持，<code>ApplicationContext</code>扩展了<code>BeanFactory</code>，除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li><code>FileSystemXmlApplication</code>：从文件系统中的XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">                <span class="string">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);</span><br><span class="line">        HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">"helloApplicationContext"</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC 压力，缩短GC 停顿时间。</li>
</ul>
<p><strong>Spring中bean的默认作用域就是singleton(单例)的。</strong>除了singleton作用域，Spring中bean还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<p><strong>Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>将SpringIOC相关知识点整理了一遍，要想知道哪些知识点是比较重要的。很简单，我们去找找相关的面试题就知道了，如果该面试题是常见的，那么说明这个知识点还是相对比较重要的啦！</p>
<p>以下的面试题从各种博客上摘抄下来，摘抄量较大的会注明出处的~</p>
<h3 id="1什么是spring"><a href="#1什么是spring" class="headerlink" title="1什么是spring?"></a>1什么是spring?</h3><blockquote>
<p>什么是spring?</p>
</blockquote>
<p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架<strong>目标是简化Java企业级应用开发</strong>，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h3 id="2使用Spring框架的好处是什么？"><a href="#2使用Spring框架的好处是什么？" class="headerlink" title="2使用Spring框架的好处是什么？"></a>2使用Spring框架的好处是什么？</h3><blockquote>
<p>使用Spring框架的好处是什么？</p>
</blockquote>
<ul>
<li><strong>轻量</strong>：Spring 是轻量的，基本的版本大约2MB。</li>
<li><strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li><strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li><strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li><strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h3 id="3Spring由哪些模块组成"><a href="#3Spring由哪些模块组成" class="headerlink" title="3Spring由哪些模块组成?"></a>3Spring由哪些模块组成?</h3><blockquote>
<p>Spring由哪些模块组成?</p>
</blockquote>
<p>简单可以分成6大模块：</p>
<ul>
<li>Core</li>
<li>AOP</li>
<li>ORM</li>
<li>DAO</li>
<li>Web</li>
<li>Spring EE</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000014979733?w=804&h=623" alt="img"></p>
<h3 id="4BeanFactory-实现举例"><a href="#4BeanFactory-实现举例" class="headerlink" title="4BeanFactory 实现举例"></a>4BeanFactory 实现举例</h3><blockquote>
<p>BeanFactory 实现举例</p>
</blockquote>
<p>Bean工厂是工厂模式的一个实现，提供了控制反转功能，<strong>用来把应用的配置和依赖从正真的应用代码中分离</strong>。</p>
<p>在spring3.2之前最常用的是XmlBeanFactory的，但现在被废弃了，取而代之的是：XmlBeanDefinitionReader和DefaultListableBeanFactory</p>
<h3 id="5什么是Spring的依赖注入？"><a href="#5什么是Spring的依赖注入？" class="headerlink" title="5什么是Spring的依赖注入？"></a>5什么是Spring的依赖注入？</h3><blockquote>
<p>什么是Spring的依赖注入？</p>
</blockquote>
<p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你<strong>不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务</strong>，之后一个容器（IOC容器）负责把他们组装起来。</p>
<h3 id="6有哪些不同类型的IOC（依赖注入）方式？"><a href="#6有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="6有哪些不同类型的IOC（依赖注入）方式？"></a>6有哪些不同类型的IOC（依赖注入）方式？</h3><blockquote>
<p>有哪些不同类型的IOC（依赖注入）方式？</p>
</blockquote>
<ul>
<li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li>
<li><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li>
<li>工厂注入：这个是遗留下来的，很少用的了！</li>
</ul>
<h3 id="7哪种依赖注入方式你建议使用，构造器注入，还是-Setter方法注入？"><a href="#7哪种依赖注入方式你建议使用，构造器注入，还是-Setter方法注入？" class="headerlink" title="7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？"></a>7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</h3><blockquote>
<p>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</p>
</blockquote>
<p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是<strong>用构造器参数实现强制依赖，setter方法实现可选依赖</strong>。</p>
<h3 id="8什么是Spring-beans"><a href="#8什么是Spring-beans" class="headerlink" title="8什么是Spring beans?"></a>8什么是Spring beans?</h3><blockquote>
<p>什么是Spring beans?</p>
</blockquote>
<p>Spring beans 是那些<strong>形成Spring应用的主干的java对象</strong>。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<code>&lt;bean/&gt;</code>的形式定义。</p>
<p>这里有四种重要的方法给Spring容器<strong>提供配置元数据</strong>。</p>
<ul>
<li>XML配置文件。</li>
<li>基于注解的配置。</li>
<li>基于java的配置。</li>
<li>Groovy DSL配置</li>
</ul>
<h3 id="9解释Spring框架中bean的生命周期"><a href="#9解释Spring框架中bean的生命周期" class="headerlink" title="9解释Spring框架中bean的生命周期"></a>9解释Spring框架中bean的生命周期</h3><blockquote>
<p>解释Spring框架中bean的生命周期</p>
</blockquote>
<ul>
<li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li>
<li>Spring根据bean的定义填充所有的属性。</li>
<li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li>
<li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li>
<li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li>
<li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li>
<li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li>
<li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li>
</ul>
<h3 id="10解释不同方式的自动装配"><a href="#10解释不同方式的自动装配" class="headerlink" title="10解释不同方式的自动装配"></a>10解释不同方式的自动装配</h3><blockquote>
<p>解释不同方式的自动装配</p>
</blockquote>
<ul>
<li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li>
<li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
<li>byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li>
<li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li>
<li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>
</ul>
<p>只用注解的方式时，<strong>注解默认是使用byType的</strong>！</p>
<h3 id="11IOC的优点是什么？"><a href="#11IOC的优点是什么？" class="headerlink" title="11IOC的优点是什么？"></a>11IOC的优点是什么？</h3><blockquote>
<p>IOC的优点是什么？</p>
</blockquote>
<p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<strong>最小的代价和最小的侵入性使松散耦合得以实现</strong>。IOC容器支持加载服务时的<strong>饿汉式初始化和懒加载</strong>。</p>
<h3 id="12哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#12哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="12哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>12哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><blockquote>
<p>哪些是重要的bean生命周期方法？ 你能重载它们吗？</p>
</blockquote>
<p>有两个重要的bean 生命周期方法，第一个是<code>setup</code>， 它是在容器加载bean的时候被调用。第二个方法是 <code>teardown</code>它是在容器卸载类的时候被调用。</p>
<p>The bean 标签有两个重要的属性（<code>init-method</code>和<code>destroy-method</code>）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（<code>@PostConstruct</code>和<code>@PreDestroy</code>）。</p>
<h3 id="13怎么回答面试官：你对Spring的理解？"><a href="#13怎么回答面试官：你对Spring的理解？" class="headerlink" title="13怎么回答面试官：你对Spring的理解？"></a>13怎么回答面试官：你对Spring的理解？</h3><blockquote>
<p>怎么回答面试官：你对Spring的理解？</p>
</blockquote>
<p>来源：</p>
<ul>
<li><a href="https://www.zhihu.com/question/48427693?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/48427693?sort=created</a></li>
</ul>
<p>下面我就截几个答案：</p>
<p>一、</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979734" alt="img"></p>
<p>二、</p>
<p><img src="https://segmentfault.com/img/remote/1460000014979735" alt="img"></p>
<h3 id="14Spring框架中的单例Beans是线程安全的么？"><a href="#14Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="14Spring框架中的单例Beans是线程安全的么？"></a>14Spring框架中的单例Beans是线程安全的么？</h3><blockquote>
<p>Spring框架中的单例Beans是线程安全的么？</p>
</blockquote>
<p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。<strong>如果你的bean有多种状态的话</strong>（比如 View Model 对象），就<strong>需要自行保证线程安全</strong>。</p>
<p>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”</p>
<h3 id="15FileSystemResource和ClassPathResource有何区别？"><a href="#15FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="15FileSystemResource和ClassPathResource有何区别？"></a>15FileSystemResource和ClassPathResource有何区别？</h3><blockquote>
<p>FileSystemResource和ClassPathResource有何区别？</p>
</blockquote>
<p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource文件放在ClassPath下。</p>
<p>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</p>
<p>简而言之，<strong>ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件</strong>。</p>
<h3 id="synchronized锁问题"><a href="#synchronized锁问题" class="headerlink" title="synchronized锁问题"></a>synchronized锁问题</h3><ul>
<li><a href="https://www.zhihu.com/question/277812143" target="_blank" rel="noopener">https://www.zhihu.com/question/277812143</a></li>
</ul>
<blockquote>
<p>开启10000个线程，每个线程给员工表的money字段【初始值是0】加1，没有使用悲观锁和乐观锁，但是在业务层方法上加了synchronized关键字，问题是代码执行完毕后数据库中的money 字段不是10000，而是小于10000 问题出在哪里？</p>
</blockquote>
<p>Service层代码：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182343" alt="代码"></p>
<p>SQL代码(没有加悲观/乐观锁)：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182344?w=600&h=143" alt="SQL代码(没有加悲观/乐观锁)"></p>
<p>用1000个线程跑代码：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182345" alt="用1000个线程跑代码："></p>
<p>简单来说：多线程跑一个使用<strong>synchronized</strong>关键字修饰的方法，方法内操作的是数据库，按正常逻辑应该最终的值是1000，但经过多次测试，结果是<strong>低于</strong>1000。这是为什么呢？</p>
<h3 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h3><p>既然测试出来的结果是低于1000，那说明这段代码<strong>不是线程安全</strong>的。不是线程安全的，那问题出现在哪呢？众所周知，synchronized方法能够保证所修饰的<code>代码块、方法</code>保证<code>有序性、原子性、可见性</code>。</p>
<p>讲道理，以上的代码跑起来，问题中<code>Service</code>层的<code>increaseMoney()</code>是<code>有序的、原子的、可见的</code>，所以<strong>断定</strong>跟synchronized应该没关系。</p>
<p>(参考我之前写过的synchronize锁笔记：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484198&idx=1&sn=4d8e372165bb49987a6243f17153a9b4&chksm=ebd74227dca0cb31311886f835092c9360d08a9f0a249ece34d4b1e49a31c9ec773fa66c8acc&scene=21#wechat_redirect" target="_blank" rel="noopener">Java锁机制了解一下</a>)</p>
<p>既然Java层面上找不到原因，那分析一下数据库层面的吧(因为方法内操作的是数据库)。在<code>increaseMoney()</code>方法前加了<code>@Transcational</code>注解，说明这个方法是带有<strong>事务</strong>的。事务能保证同组的SQL要么同时成功，要么同时失败。讲道理，如果没有报错的话，应该每个线程都对money值进行<code>+1</code>。从理论上来说，结果应该是1000的才对。</p>
<p>(参考我之前写过的Spring事务：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=5&sn=67467f35a9e9314aa3d1c07ff250af6b&chksm=ebd74430dca0cd26c94daf2d3e34806c29d05583de2255b98d20d34cd86e12ae94624d33be1b&token=1885756144&lang=zh_CN#rd" target="_blank" rel="noopener">一文带你看懂Spring事务！</a>)</p>
<p>根据上面的分析，我怀疑是<strong>提问者没测试好</strong>(hhhh，逃)，于是我也跑去测试了一下，发现是以提问者的方式来使用<strong>是真的有问题</strong>。</p>
<p>首先贴一下我的测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; employeeService.addEmployee()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查出ID为8的记录，然后每次将年龄增加一</span></span><br><span class="line">        Employee employee = employeeRepository.getOne(<span class="number">8</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        Integer age = employee.getAge();</span><br><span class="line">        employee.setAge(age + <span class="number">1</span>);</span><br><span class="line">        employeeRepository.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单地打印了每次拿到的employee值，并且拿到了SQL执行的顺序，如下(贴出小部分)：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182346" alt="SQL执行的顺序"></p>
<p>从打印的情况我们可以得出：多线程情况下并<strong>没有串行</strong>执行<code>addEmployee()</code>方法。这就导致对同一个值做<strong>重复</strong>的修改，所以最终的数值比1000要少。</p>
<h3 id="图解出现的原因"><a href="#图解出现的原因" class="headerlink" title="图解出现的原因"></a>图解出现的原因</h3><p>发现并不是<strong>同步</strong>执行的，于是我就怀疑<code>synchronized</code>关键字和Spring肯定有点冲突。于是根据这两个关键字搜了一下，找到了问题所在。</p>
<p>我们知道Spring事务的底层是Spring AOP，而Spring AOP的底层是动态代理技术。跟大家一起回顾一下动态代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    Object target ;</span><br><span class="line">    Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), Main<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 但凡带有@Transcational注解的方法都会被拦截</span></span><br><span class="line">            <span class="comment">// 1... 开启事务</span></span><br><span class="line">            method.invoke(target);</span><br><span class="line">            <span class="comment">// 2... 提交事务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(详细请参考我之前写过的动态代理：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1&scene=21#wechat_redirect" target="_blank" rel="noopener">给女朋友讲解什么是代理模式</a>)</p>
<p>实际上Spring做的处理跟以上的思路是一样的，我们可以看一下TransactionAspectSupport类中<code>invokeWithinTransaction()</code>：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182347" alt="Spring事务管理是如何实现的"></p>
<p>调用方法<strong>前</strong>开启事务，调用方法<strong>后</strong>提交事务</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182348" alt="Spring事务和synchronized锁互斥问题"></p>
<p>在多线程环境下，就可能会出现：<strong>方法执行完了(synchronized代码块执行完了)，事务还没提交，别的线程可以进入被synchronized修饰的方法，再读取的时候，读到的是还没提交事务的数据，这个数据不是最新的</strong>，所以就出现了这个问题。</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182349?w=1353&h=684" alt="事务未提交，别的线程读取到旧数据"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>从上面我们可以发现，问题所在是因为<code>@Transcational</code>注解和<code>synchronized</code>一起使用了，<strong>加锁的范围没有包括到整个事务</strong>。所以我们可以这样做：</p>
<p>新建一个名叫SynchronizedService类，让其去调用<code>addEmployee()</code>方法，整个代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SynchronizedService synchronizedService ;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; synchronizedService.synchronizedAddEmployee()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建的Service类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService ;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedAddEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        employeeService.addEmployee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;  </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查出ID为8的记录，然后每次将年龄增加一</span></span><br><span class="line">        Employee employee = employeeRepository.getOne(<span class="number">8</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + employee);</span><br><span class="line">        Integer age = employee.getAge();</span><br><span class="line">        employee.setAge(age + <span class="number">1</span>);</span><br><span class="line">        employeeRepository.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将synchronized锁的范围<strong>包含到整个Spring事务上</strong>，这就不会出现线程安全的问题了。在测试的时候，我们可以发现1000个线程跑起来<strong>比之前要慢得多</strong>，当然我们的数据是正确的：</p>
<p><img src="https://segmentfault.com/img/remote/1460000018182350" alt="正确的数据"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java-spring/" rel="tag"># java spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/22/JAVA-Web/" rel="next" title="JAVA-Web">
                <i class="fa fa-chevron-left"></i> JAVA-Web
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/27/JAVA-ReflectionAnnotation/" rel="prev" title="JAVA-ReflectionAnnotation">
                JAVA-ReflectionAnnotation <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Mr.Zhang" />
            
              <p class="site-author-name" itemprop="name">Mr.Zhang</p>
              <p class="site-description motion-element" itemprop="description">爱学习的小学生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhangwell" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhangwell0323@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://google.com" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringIOC"><span class="nav-number">1.1.</span> <span class="nav-text">SpringIOC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖倒置原则、IOC、DI、IOC容器"><span class="nav-number">1.1.2.</span> <span class="nav-text">依赖倒置原则、IOC、DI、IOC容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC容器"><span class="nav-number">1.1.3.</span> <span class="nav-text">IOC容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核心接口"><span class="nav-number">1.1.4.</span> <span class="nav-text">核心接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanFactory接口"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">BeanFactory接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationContext接口"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">ApplicationContext接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析"><span class="nav-number">1.1.5.</span> <span class="nav-text">案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#案例一："><span class="nav-number">1.1.5.1.</span> <span class="nav-text">案例一：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#案例二：注解方式"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">案例二：注解方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean装载案例："><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Bean装载案例：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bean依赖注入案例："><span class="nav-number">1.1.5.4.</span> <span class="nav-text">Bean依赖注入案例：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getBean-解析"><span class="nav-number">1.1.6.</span> <span class="nav-text">getBean()解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-的作用域"><span class="nav-number">1.1.7.</span> <span class="nav-text">Bean 的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean-的生命周期"><span class="nav-number">1.1.8.</span> <span class="nav-text">Bean 的生命周期</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringAOP"><span class="nav-number">1.2.</span> <span class="nav-text">SpringAOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java动态代理"><span class="nav-number">1.3.</span> <span class="nav-text">Java动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">1.3.1.</span> <span class="nav-text">应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-DAO模块"><span class="nav-number">2.</span> <span class="nav-text">Spring DAO模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾对模版代码优化过程"><span class="nav-number">2.1.</span> <span class="nav-text">回顾对模版代码优化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Spring的JDBC"><span class="nav-number">2.2.</span> <span class="nav-text">使用Spring的JDBC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JdbcTemplate查询"><span class="nav-number">2.3.</span> <span class="nav-text">JdbcTemplate查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务控制概述"><span class="nav-number">2.4.</span> <span class="nav-text">事务控制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编程式事务控制"><span class="nav-number">2.4.1.</span> <span class="nav-text">编程式事务控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#声明式事务控制"><span class="nav-number">2.4.2.</span> <span class="nav-text">声明式事务控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明式事务控制-1"><span class="nav-number">2.5.</span> <span class="nav-text">声明式事务控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搭建配置环境"><span class="nav-number">2.5.1.</span> <span class="nav-text">搭建配置环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML方式实现声明式事务控制"><span class="nav-number">2.5.2.</span> <span class="nav-text">XML方式实现声明式事务控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用注解的方法实现事务控制"><span class="nav-number">2.5.3.</span> <span class="nav-text">使用注解的方法实现事务控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务属性"><span class="nav-number">2.6.</span> <span class="nav-text">事务属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务传播行为"><span class="nav-number">2.6.1.</span> <span class="nav-text">事务传播行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当事务传播行为是Propagation-REQUIRED"><span class="nav-number">2.6.2.</span> <span class="nav-text">当事务传播行为是Propagation.REQUIRED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#现在有一个日志类，它的事务传播行为是Propagation-REQUIRED"><span class="nav-number">2.6.3.</span> <span class="nav-text">现在有一个日志类，它的事务传播行为是Propagation.REQUIRED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当事务传播行为是Propagation-REQUIRED-NEW"><span class="nav-number">2.6.4.</span> <span class="nav-text">当事务传播行为是Propagation.REQUIRED_NEW</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-IOC总结"><span class="nav-number">3.</span> <span class="nav-text">Spring IOC总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC和DI概述"><span class="nav-number">3.1.</span> <span class="nav-text">IOC和DI概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC容器的原理"><span class="nav-number">3.2.</span> <span class="nav-text">IOC容器的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC容器装配Bean"><span class="nav-number">3.3.</span> <span class="nav-text">IOC容器装配Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#装配Bean方式"><span class="nav-number">3.3.1.</span> <span class="nav-text">装配Bean方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖注入方式"><span class="nav-number">3.3.2.</span> <span class="nav-text">依赖注入方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象之间关系"><span class="nav-number">3.3.3.</span> <span class="nav-text">对象之间关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean的作用域"><span class="nav-number">3.3.4.</span> <span class="nav-text">Bean的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理自动装配的歧义性"><span class="nav-number">3.3.5.</span> <span class="nav-text">处理自动装配的歧义性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用属性文件以及Bean属性"><span class="nav-number">3.3.6.</span> <span class="nav-text">引用属性文件以及Bean属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合配置文件"><span class="nav-number">3.3.7.</span> <span class="nav-text">组合配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装配Bean总结"><span class="nav-number">3.3.8.</span> <span class="nav-text">装配Bean总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP总结"><span class="nav-number">4.</span> <span class="nav-text">Spring AOP总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP概述"><span class="nav-number">4.1.</span> <span class="nav-text">AOP概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP原理"><span class="nav-number">4.2.</span> <span class="nav-text">Spring AOP原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP的实现者"><span class="nav-number">4.3.</span> <span class="nav-text">AOP的实现者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP的术语"><span class="nav-number">4.4.</span> <span class="nav-text">AOP的术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring对AOP的支持"><span class="nav-number">4.5.</span> <span class="nav-text">Spring对AOP的支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于注解和命名空的AOP编程"><span class="nav-number">4.6.</span> <span class="nav-text">基于注解和命名空的AOP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用引介-引入功能实现为Bean引入新方法"><span class="nav-number">4.6.1.</span> <span class="nav-text">使用引介/引入功能实现为Bean引入新方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在XML中声明切面"><span class="nav-number">4.6.2.</span> <span class="nav-text">在XML中声明切面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">4.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-事务"><span class="nav-number">5.</span> <span class="nav-text">Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础知识"><span class="nav-number">5.1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个不靠谱直觉的例子"><span class="nav-number">5.2.</span> <span class="nav-text">两个不靠谱直觉的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一个例子"><span class="nav-number">5.2.1.</span> <span class="nav-text">第一个例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二个例子"><span class="nav-number">5.2.2.</span> <span class="nav-text">第二个例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#再延伸一下"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">再延伸一下</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring事务传播机制"><span class="nav-number">5.3.</span> <span class="nav-text">Spring事务传播机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程问题"><span class="nav-number">5.4.</span> <span class="nav-text">多线程问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#啥是BPP？"><span class="nav-number">5.5.</span> <span class="nav-text">啥是BPP？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么特意讲BPP？"><span class="nav-number">5.5.1.</span> <span class="nav-text">为什么特意讲BPP？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#认识Spring事务几个重要的接口"><span class="nav-number">5.6.</span> <span class="nav-text">认识Spring事务几个重要的接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-与设计模式"><span class="nav-number">6.</span> <span class="nav-text">Spring 与设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂设计模式"><span class="nav-number">6.1.</span> <span class="nav-text">工厂设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例设计模式"><span class="nav-number">6.2.</span> <span class="nav-text">单例设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式"><span class="nav-number">6.3.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式在-AOP-中的应用"><span class="nav-number">6.3.1.</span> <span class="nav-text">代理模式在 AOP 中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-AOP-和-AspectJ-AOP-有什么区别"><span class="nav-number">6.3.2.</span> <span class="nav-text">Spring AOP 和 AspectJ AOP 有什么区别?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">7.</span> <span class="nav-text">QA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1什么是spring"><span class="nav-number">7.1.</span> <span class="nav-text">1什么是spring?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2使用Spring框架的好处是什么？"><span class="nav-number">7.2.</span> <span class="nav-text">2使用Spring框架的好处是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3Spring由哪些模块组成"><span class="nav-number">7.3.</span> <span class="nav-text">3Spring由哪些模块组成?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4BeanFactory-实现举例"><span class="nav-number">7.4.</span> <span class="nav-text">4BeanFactory 实现举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5什么是Spring的依赖注入？"><span class="nav-number">7.5.</span> <span class="nav-text">5什么是Spring的依赖注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6有哪些不同类型的IOC（依赖注入）方式？"><span class="nav-number">7.6.</span> <span class="nav-text">6有哪些不同类型的IOC（依赖注入）方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7哪种依赖注入方式你建议使用，构造器注入，还是-Setter方法注入？"><span class="nav-number">7.7.</span> <span class="nav-text">7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8什么是Spring-beans"><span class="nav-number">7.8.</span> <span class="nav-text">8什么是Spring beans?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9解释Spring框架中bean的生命周期"><span class="nav-number">7.9.</span> <span class="nav-text">9解释Spring框架中bean的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10解释不同方式的自动装配"><span class="nav-number">7.10.</span> <span class="nav-text">10解释不同方式的自动装配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11IOC的优点是什么？"><span class="nav-number">7.11.</span> <span class="nav-text">11IOC的优点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12哪些是重要的bean生命周期方法？-你能重载它们吗？"><span class="nav-number">7.12.</span> <span class="nav-text">12哪些是重要的bean生命周期方法？ 你能重载它们吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13怎么回答面试官：你对Spring的理解？"><span class="nav-number">7.13.</span> <span class="nav-text">13怎么回答面试官：你对Spring的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14Spring框架中的单例Beans是线程安全的么？"><span class="nav-number">7.14.</span> <span class="nav-text">14Spring框架中的单例Beans是线程安全的么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15FileSystemResource和ClassPathResource有何区别？"><span class="nav-number">7.15.</span> <span class="nav-text">15FileSystemResource和ClassPathResource有何区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized锁问题"><span class="nav-number">7.16.</span> <span class="nav-text">synchronized锁问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我的思考"><span class="nav-number">7.17.</span> <span class="nav-text">我的思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图解出现的原因"><span class="nav-number">7.18.</span> <span class="nav-text">图解出现的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决问题"><span class="nav-number">7.19.</span> <span class="nav-text">解决问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
