<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Crash Course Computer Science</title>
      <link href="/2019/12/09/Crash-Course-Computer-Science/"/>
      <url>/2019/12/09/Crash-Course-Computer-Science/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p><a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">计算机科学速成课</a></p></blockquote><a id="more"></a><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209102345330.png" alt="image-20191209102345330"></p><h2 id="第-1-集：计算机早期历史"><a href="#第-1-集：计算机早期历史" class="headerlink" title="第 1 集：计算机早期历史"></a>第 1 集：计算机早期历史</h2><p>提到的设备：算盘 → 步进计算器 → 差分机 → 分析机 → 打孔卡片制表机<br>提到的人名：Charles Babbage, Ada Lovelace</p><p>02:27 最早的计算设备是算盘，举例如何使用<br>04:31 Computer 从指代职业变成指代机器<br>04:57 机器里有名的是：步进计算器。第一个可以做加减乘除的机器<br>06:44 炮弹为了精准，要计算弹道，二战是查表来做。但每次改设计了就需要做一张新表<br>07:30 Charles Babbage 提出了 “差分机”, 在构造差分机期间，想出了分析机, 分析机是通用计算机<br>08:50 Lovelace 给分析机写了假想程序，因此成为了第一位程序员<br>09:25 人口普查 10 年一次. Herman Hollerith 的打孔卡片制表机大大提升了效率</p><h2 id="第-2-集：电子计算机"><a href="#第-2-集：电子计算机" class="headerlink" title="第 2 集：电子计算机"></a>第 2 集：电子计算机</h2><p>提到的设备：继电器 → 真空管 → 晶体管</p><p>00:17 20世纪的发展要求更强的计算能力。柜子大小的计算机发展到房间大小<br>01:06 哈佛 Mark 1 号，IBM 1944 年做的<br>02:25 继电器，继电器一秒最多 50 次开关<br>03:24 继电器出 bug<br>03:49 1904 年，热电子管出现，第一个真空管。改进后变成和继电器的功能一样<br>05:34 “巨人1号” 计算机在英国 布莱切利园 首次大规模使用真空管。但编程麻烦，还要配置<br>06:40 1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机<br>07:36 1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管<br>09:27 硅谷的典故：很多晶体管和半导体的开发都是这里做的。而生产半导体最常见的材料是硅<br>09:41 肖克利半导体 → 仙童半导体 → 英特尔</p><h2 id="第-3-集：布尔逻辑和逻辑门"><a href="#第-3-集：布尔逻辑和逻辑门" class="headerlink" title="第 3 集：布尔逻辑和逻辑门"></a>第 3 集：布尔逻辑和逻辑门</h2><p>01:00 什么是二进制, 为什么用二进制, 布尔逻辑<br>02:46 3个基本操作：NOT，AND，OR<br>02:51 解释3个基本操作<br>07:11 XOR 异或</p><h2 id="第-4-集：二进制"><a href="#第-4-集：二进制" class="headerlink" title="第 4 集：二进制"></a>第 4 集：二进制</h2><p>00:46 用十进制举例二进制的原理，演示二进制加法。存储单位 MB GB TB 等<br>05:30 正数，负数，整数，浮点数的表示<br>07:20 美国信息交换标准代码 - ASCII, 用来表示字符<br>09:00 UNICODE 1992 年诞生，是字符编码标准， 解决 ASCII 不够表达所有语言的问题</p><h2 id="第-5-集：算数逻辑单元-ALU"><a href="#第-5-集：算数逻辑单元-ALU" class="headerlink" title="第 5 集：算数逻辑单元 - ALU"></a>第 5 集：算数逻辑单元 - ALU</h2><p>00:03 简单介绍 ALU ，英特尔 74181<br>01:24 ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元</p><p>01:32 算术单元<br>半加器 (处理1个 bit，2个输入)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091108226.png" alt="image-20191209091108226"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091134336.png" alt="image-20191209091134336"></p><p>全加器 (处理1个 bit，3个输入)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091320872.png" alt="image-20191209091320872"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091401064.png" alt="image-20191209091401064"></p><p>8 bit 加法 (1个半加器，7个全加器）</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091505711.png" alt="image-20191209091505711"></p><p>溢出的概念，吃豆人的例子<br>乘法除法</p><p>07:32 逻辑单元<br>检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）<br>ALU 抽象成一个 V 符号<br>Flag 标志（是否相等，是否小于，是否溢出等等）</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092043700.png" alt="image-20191209092043700"></p><h2 id="第-6-集：寄存器和内存"><a href="#第-6-集：寄存器和内存" class="headerlink" title="第 6 集：寄存器和内存"></a>第 6 集：寄存器和内存</h2><p>本集重点是 Memory （存储 / 内存 两种含义）</p><p>03:30 存 1 位 (Gated Latch - 锁存器）</p><p>永久存1（逻辑与输出接回输入）：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092532043.png" alt="image-20191209092532043"></p><p>永久存0（逻辑和输出接回输入）：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092711762.png" alt="image-20191209092711762"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092737143.png" alt="image-20191209092737143"></p><p>将电路连接起来：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092802131.png" alt="image-20191209092802131"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209094109974.png" alt="image-20191209094109974"></p><p>换个方式</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209095304803.png" alt="image-20191209095304803"></p><p>数据输入线：设为0或者1来存储值<br>启动线：允许启动或关闭存储</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100017621.png" alt="image-20191209100017621"></p><p>向上抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209095704584.png" alt="image-20191209095704584"></p><p>允许写入线的开关控制数据输入线的值能否存储入门锁中。</p><p>04:48 存 8 位 (Register - 寄存器)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100142534.png" alt="image-20191209100142534"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100219842.png" alt="image-20191209100219842"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100256357.png" alt="image-20191209100256357"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100315457.png" alt="image-20191209100315457"></p><p>05:46 16x16 的矩阵存 256 位</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100449795.png"><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100515128.png" alt></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100433081.png" alt="image-20191209100433081"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100830634.png" alt="image-20191209100830634"></p><p>数据选择器/多路复用器 (Multiplexer) 解码 8 位地址，定位到单个锁存器</p><p>07:38 4 位代表行， 4 位代表列</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101103207.png" alt="image-20191209101103207"></p><p>08:16 组合 256 位内存 + 多路复用器<br>09:01 可寻址的 256 字节 内存</p><p>向上抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101217062.png" alt="image-20191209101217062"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101313055.png" alt="image-20191209101313055"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101340409.png" alt="image-20191209101340409"></p><p>再次抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101509140.png" alt="image-20191209101509140"><br><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101548861.png" alt="image-20191209101548861"></p><p>一条1980年代的内存，1M 大小</p><p>10:14 8个模块，每个模块有32个小方块，<br>每个小方块有 4 个小块，每个小块是 128 位 x 64 位</p><h2 id="第-7-集：中央处理器（CPU"><a href="#第-7-集：中央处理器（CPU" class="headerlink" title="第 7 集：中央处理器（CPU)"></a>第 7 集：中央处理器（CPU)</h2><p>重点</p><ol><li>拼个 CPU 出来</li><li>CPU 怎么执行命令</li></ol><p>01:00 RAM + 寄存器 + ALU 做个 CPU</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209214658376.png" alt="image-20191209214658376"></p><p>04:00 解释 “取指令→解释→执行” 这个循环</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209214742706.png" alt="image-20191209214742706"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215049890.png" alt="image-20191209215049890"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215257090.png" alt="image-20191209215257090"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215331027.png" alt="image-20191209215331027"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215530912.png" alt="image-20191209215530912"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215620939.png" alt="image-20191209215620939"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215726423.png" alt="image-20191209215726423"></p><p>上述就完成了将RAM中的值14存入寄存器A中</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215924813.png" alt="image-20191209215924813"></p><p>开始执行下一条指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220015449.png" alt="image-20191209220015449"></p><p>向上抽象后，完成下一条指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220218556.png" alt="image-20191209220218556"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220434146.png" alt="image-20191209220434146"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220528278.png" alt="image-20191209220528278"></p><p>整个过程是从内存中加载两个数据，相加后，结果再存到内存中</p><p>08:00 时钟是什么, 时钟速度和赫兹</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220743313.png" alt="image-20191209220743313"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220822119.png" alt="image-20191209220822119"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209221031800.png" alt="image-20191209221031800"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209221118156.png" alt="image-20191209221118156"></p><p>10:00 超频提升性能, 降频省电</p><h2 id="第-8-集：指令和程序"><a href="#第-8-集：指令和程序" class="headerlink" title="第 8 集：指令和程序"></a>第 8 集：指令和程序</h2><p>本集重点：一步步带你运行一遍程序</p><p>00:45 回顾上集的例子程序，一步步讲解。介绍”指令集”的概念<br>LOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令<br>05:16 带条件跳转，JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP<br>08:00 真正现代 CPU 用更多指令集。位数更长。<br>09:07 1971年的英特尔 4004 处理器，有 46 个指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209222131963.png" alt="image-20191209222131963"></p><p>09:36 如今英特尔酷睿 i7, 有上千条指令</p><h2 id="第-9-集：高级-CPU-设计"><a href="#第-9-集：高级-CPU-设计" class="headerlink" title="第 9 集：高级 CPU 设计"></a>第 9 集：高级 CPU 设计</h2><p>00:24 早期是加快晶体管切换速度，来提升 CPU 速度<br>01:20 给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码<br>02:28 给 CPU 加缓存，提高数据存取速度，更快喂给 CPU，用计算餐馆销售额举例<br>05:13 脏位 - Dirty bit</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095155264.png" alt="image-20191210095155264"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095216725.png" alt="image-20191210095216725"></p><p>05:33 流水线设计，用 1 个洗衣机和 1 个干燥机举例</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095351622.png" alt="image-20191210095351622"></p><p>06:01 并行处理 - parallelize</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095507564.png" alt="image-20191210095507564"></p><p>07:33 乱序执行 - out-of-order execution<br>08:21 推测执行 - speculative execution<br>08:50 分支预测 - branch prediction<br>09:34 多个 ALU</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095800619.png" alt="image-20191210095800619"></p><p>09:54 多核 (Core)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095840819.png" alt="image-20191210095840819"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095908362.png" alt="image-20191210095908362"></p><p>10:11 多个独立 CPU<br>10:52 超级计算机，中国的”神威 太湖之光”</p><h2 id="第-10-集：早期的编程方式"><a href="#第-10-集：早期的编程方式" class="headerlink" title="第 10 集：早期的编程方式"></a>第 10 集：早期的编程方式</h2><p>本集重点：早期计算机如何编程<br>打孔纸卡 → 插线板 → 面板拨开关</p><p>00:00 开头说本集重点：程序如何进入计算机<br>00:53 拿纺织业举例，给机器编程的需求远在计算机出现前就有了<br>01:41 打孔纸卡 - Punched card<br>02:36 插线板 - Plugboard<br>04:20 冯诺依曼架构 - Von Neumann Architecture<br>07:00 面板编程 - Panel programming<br>07:29 第一款取得商业成功的家用计算机: Altair 8800<br>08:15 编程依然很困难，人们需要更友好更简单的方式编程<br>08:44 下周主题：编程语言</p><h2 id="第-11-集：编程语言发展史"><a href="#第-11-集：编程语言发展史" class="headerlink" title="第 11 集：编程语言发展史"></a>第 11 集：编程语言发展史</h2><p>编程：二进制 → 助记符（汇编器）→ A-0（编译器）→ FORTRAIN</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210101157518.png" alt="image-20191210101157518"></p><p>01:45 二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了<br>02:28 用 “助记符” 写代码（LOAD_A 14）为了把助记符转二进制，汇编器诞生 (Assembler)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210101410840.png" alt="image-20191210101410840"></p><p>04:32 葛丽丝·霍普 (Grace Hopper) - 哈佛1号计算机首批程序员, 海军军官<br>05:13 Grace 设计了编程语言 A-0<br>05:29 Grace 1952 年做了第一个编译器 (Compiler)，实现 A-0<br>06:29 变量 (Variables)<br>07:01 FORTRAN<br>08:18 COBOL<br>09:25 新语言<br>1960 年代：ALGOL，LISP，BASIC<br>1970 年代：Pascal，C，Smalltalk<br>1980 年代：C++，Objective-C，Perl<br>1990 年代：Python，Ruby，Java</p><h2 id="第-12-集：编程基础-语句和函数"><a href="#第-12-集：编程基础-语句和函数" class="headerlink" title="第 12 集：编程基础 - 语句和函数"></a>第 12 集：编程基础 - 语句和函数</h2><p>00:50 变量, 赋值语句<br>02:08 Grace Hopper 拍虫子游戏<br>02:52 if 判断<br>04:19 while 循环<br>05:48 for 循环<br>07:00 函数<br>11:11 下集介绍算法</p><h2 id="第-13-集：算法入门"><a href="#第-13-集：算法入门" class="headerlink" title="第 13 集：算法入门"></a>第 13 集：算法入门</h2><p>03:00 选择排序 - Selection sort<br>03:52 大 O 表示法 - Big O notation<br>04:31 归并排序 - Merge sort<br>08:03 Dijkstra 算法</p><h2 id="第-14-集：数据结构"><a href="#第-14-集：数据结构" class="headerlink" title="第 14 集：数据结构"></a>第 14 集：数据结构</h2><p>00:39 数组 - Array<br>02:06 字符串 - String<br>03:12 矩阵 - Matrix<br>04:05 结构体 - Struct<br>04:46 指针 - Pointer<br>04:44 节点 - Node<br>04:53 链表 - Linked List<br>06:21 队列 - Queue<br>06:21 栈 - Stack<br>07:31 树 - Tree<br>08:01 二叉树 - Binary Tree<br>08:26 图 - Graph<br>08:50 没时间讲红黑树和堆, 不同数据结构适用不同场景</p>]]></content>
      
      
      <categories>
          
          <category> Online Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jiao Qing</title>
      <link href="/2019/12/02/Jiao-Qing/"/>
      <url>/2019/12/02/Jiao-Qing/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>无聊的摘抄</p></blockquote><a id="more"></a><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p><a href="https://www.zhihu.com/question/295424569/answer/660635912" target="_blank" rel="noopener">房东和租客的故事</a></p><h3 id="迅哥儿"><a href="#迅哥儿" class="headerlink" title="迅哥儿"></a>迅哥儿</h3><ol><li>从来如此，便对么？</li><li>猛兽总是独行，牛羊才成群结队。</li><li>假使牡丹是中国的“国花”，那么，“他妈的！”就可以算是中国的“国骂”了。</li><li>自由固不是钱所能买到的，但能够为钱而卖掉。</li><li>勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。</li><li>面具戴太久，就会长到脸上，再想揭下来，除非伤筋动骨扒皮。</li><li>有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇。</li><li>当我沉默的时候，我觉得很充实，当我开口说话，就感到了空虚。</li><li>我家门前有两棵树，一棵是枣树，另一棵也是枣树。</li><li>社会上崇敬名人，于是以为名人的话就是名言，却忘记了他之所以得名是那一种学问或事业。</li><li>哪里有天才，我是把别人喝咖啡的工夫都用在了工作上。</li><li>“急不择言”的病源，并不在没有想的功夫，而在有功夫的时候没有想。</li><li>浪费别人的时间等于谋财害命。</li><li>无刺的蔷薇是没有的，然而没有蔷薇的刺却很多。</li><li>父母之于子女，应该健全的产生，尽力的教育，完全的解放。</li><li>贪安稳就没有自由，要自由就要历些危险，只有这两条路。</li><li>小的时候不把他当人，大了以后也做不了人。</li><li>试到公园去，大概总可以遇见祖母带着她孙女儿在玩的。这位祖母的模样，就预示着那娃儿的未来。所以倘有谁要预知令夫人日后的丰姿，也只要看丈母。不同是当然要有些不同的，但总归相去不远。</li><li>希望是本无所谓有，无所谓无的。正如地上的路，其实地上本没有路，走的人多了，也便成了路。</li></ol><h3 id="云村"><a href="#云村" class="headerlink" title="云村"></a>云村</h3><h3 id="散落"><a href="#散落" class="headerlink" title="散落"></a>散落</h3><ol><li>少年就是少年，他们看春风不喜，看夏蝉不烦，看秋风不悲，看冬雪不叹，看满身富贵懒察觉，看不公不允敢面对，只因他们是少年。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘抄 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA NOTES</title>
      <link href="/2019/12/02/JAVA-NOTES/"/>
      <url>/2019/12/02/JAVA-NOTES/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java学习散落的知识点</p></blockquote><a id="more"></a><h2 id="Java-Compar-接口"><a href="#Java-Compar-接口" class="headerlink" title="Java Compar**接口"></a>Java Compar**接口</h2><h3 id="Comparable-是排序接口"><a href="#Comparable-是排序接口" class="headerlink" title="Comparable 是排序接口"></a>Comparable 是排序接口</h3><p>若一个类实现了Comparable接口，就意味着“<strong>该类支持排序</strong>”。  即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 若返回“负数”，意味着“x比y小”；返回“正数”，意味着“x大于y”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparator-是比较器接口"><a href="#Comparator-是比较器接口" class="headerlink" title="Comparator 是比较器接口"></a>Comparator 是比较器接口</h3><p>我们若需要控制某个类的次序，而该类本身不支持排序（即没有实现Comparable接口）；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。</p><p>也就是说，我们可以通过“<strong>实现Comparator类来新建一个比较器</strong>”，然后通过该比较器对类进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 若返回“负数”，意味着“x比y小”；返回“正数”，意味着“x大于y”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="comment">// 数值等同==，未重写表示对象引值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：若一个类要实现Comparator接口，它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。因为任何类，默认都是已经实现了equals(Object obj)的。</p></blockquote><h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><p>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。<br>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: "Comparator"和“Comparable”的比较汇总程序。</span></span><br><span class="line"><span class="comment"> * (01) "Comparable"</span></span><br><span class="line"><span class="comment"> * 它是一个排序接口，只包含一个函数compareTo()。</span></span><br><span class="line"><span class="comment"> * 一个类实现了Comparable接口，就意味着“该类本身支持排序”，它可以直接通过Arrays.sort() 或 Collections.sort()进行排序。</span></span><br><span class="line"><span class="comment"> * (02) "Comparator"</span></span><br><span class="line"><span class="comment"> * 它是一个比较器接口，包括两个函数：compare() 和 equals()。</span></span><br><span class="line"><span class="comment"> * 一个类实现了Comparator接口，那么它就是一个“比较器”。其它的类，可以根据该比较器去排序。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 综上所述：Comparable是内部比较器，而Comparator是外部比较器。</span></span><br><span class="line"><span class="comment"> * 一个类本身实现了Comparable比较器，就意味着它本身支持排序；若它本身没实现Comparable，也可以通过外部比较器Comparator进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建ArrayList(动态数组)</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        <span class="comment">// 添加对象到ArrayList中</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ccc"</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"AAA"</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"bbb"</span>, <span class="number">10</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ddd"</span>, <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印list的原始序列</span></span><br><span class="line">        System.out.printf(<span class="string">"Original  sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list进行排序</span></span><br><span class="line">        <span class="comment">// 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.printf(<span class="string">"Name      sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过“比较器(AscAgeComparator)”，对list进行排序</span></span><br><span class="line">        <span class="comment">// AscAgeComparator的排序方式是：根据“age”的升序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> AscAgeComparator());</span><br><span class="line">        System.out.printf(<span class="string">"Asc(age)  sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过“比较器(DescAgeComparator)”，对list进行排序</span></span><br><span class="line">        <span class="comment">// DescAgeComparator的排序方式是：根据“age”的降序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> DescAgeComparator());</span><br><span class="line">        System.out.printf(<span class="string">"Desc(age) sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个person是否相等</span></span><br><span class="line">        testEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 测试两个Person比较是否相等。</span></span><br><span class="line"><span class="comment">     * 由于Person实现了equals()函数：若两person的age、name都相等，则认为这两个person相等。</span></span><br><span class="line"><span class="comment">     * 所以，这里的p1和p2相等。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * TODO：若去掉Person中的equals()函数，则p1不等于p2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1.equals(p2)) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s NOT EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">     * Person实现了Comparable接口，这意味着Person本身支持排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">" - "</span> + age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。</span></span><br><span class="line"><span class="comment">         * 这里是通过“person的名字”进行比较的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.compareTo(person.name);</span><br><span class="line">            <span class="comment">//return this.name - person.name;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> AscAgeComparator比较器</span></span><br><span class="line"><span class="comment">     * 它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AscAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> DescAgeComparator比较器</span></span><br><span class="line"><span class="comment">     * 它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DescAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>private：只有本类中可以访问</p><p>default：只能在本包中可以访问，在其他包即使是继承也不能访问</p><p>protected：比较繁琐，不常用，总结为<strong>不跨包不影响访问，可以看做是public，跨包视为private</strong></p><p>public：均可访问</p><h2 id="SpringBoot与SSM"><a href="#SpringBoot与SSM" class="headerlink" title="SpringBoot与SSM"></a>SpringBoot与SSM</h2><p>首先看搭建 SSM 框架时，我们需要哪些步骤</p><ol><li><p>加相关的 jar 包</p></li><li><p>配置 web.xml，加载 Spring，SpringMVC</p></li><li><p>配置数据库连接，spring 事务</p></li><li><p>配置加载配置文件的读取，开启注解</p></li><li><p>配置日志文件</p></li><li><p>配置完成，部署 tomcat 调试</p></li></ol><p>而这些配置 SpringBoot 都帮我们做好了：</p><p><img src="/2019/12/02/JAVA-NOTES/926090-20190324114958133-488948960.png" alt="img"></p><p>就是这些 starter 依赖，帮我们做了很多配置。</p><p>springboot 框架使用 starter 依赖主要帮我们做了两点：</p><p>1.引入相关的 jar</p><p>2.自动完成 bean 配置。</p><p>总结：</p><ol><li><p>Springboot 将原有的 xml 配置，简化为 java 注解</p></li><li><p>使用 IDE 可以很方便的搭建一个 springboot 项目，选择对应的 maven 依赖，简化Spring应用的初始搭建以及开发过程</p></li><li><p>springboot 有内置的 tomcat 服务器，可以 jar 形式启动一个服务,可以快速部署发布 web 服务</p></li><li><p>springboot 使用 starter 依赖自动完成 bean 配置，，解决 bean 之间的冲突，并引入相关的 jar 包（这一点最重要）</p></li></ol><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="并发编程需要解决的问题"><a href="#并发编程需要解决的问题" class="headerlink" title="并发编程需要解决的问题"></a>并发编程需要解决的问题</h3><blockquote><p>线程间<strong>通信</strong>&amp;线程间<strong>同步</strong></p></blockquote><p>线程之间通信机制分为两种：<strong>共享内存</strong>、<strong>消息传递</strong></p><p> <strong>共享内存</strong>通信与同步</p><table><thead><tr><th>操作类型</th><th>实现方式</th></tr></thead><tbody><tr><td>通信</td><td>线程之间共享程序的公共状态，通过写－读内存中的变量的公共状态进行隐式通信</td></tr><tr><td>同步</td><td>显式进行同步，必须显式制定某个方法或某段代码需要在线程之间互斥执行</td></tr></tbody></table><p><strong>消息传递</strong>通信与同步</p><table><thead><tr><th>操作类型</th><th>实现方式</th></tr></thead><tbody><tr><td>通信</td><td>线程之间没有公共状态，线程之间通过发送消息显式进行通信</td></tr><tr><td>同步</td><td>隐式进行同步，消息发送必须在消息发送之前</td></tr></tbody></table><p>注意：<strong>java并发采用的是共享内存模型</strong>，java线程之间的通信总是隐式进行的。</p><h3 id="内存模型概念"><a href="#内存模型概念" class="headerlink" title="内存模型概念"></a>内存模型概念</h3><ul><li><p>在Java中所有的实例对象、静态数据域、和数组元素都存储在堆内存当中，堆内存在线程之间是共享的。 ——堆中数据域是线程共享的</p></li><li><p>局部变量、方法定义参数、和异常处理器参数不会在线程之间共享、他们不会有内存可见性问题，也不受内存模型的影响。——线程独享的</p></li></ul><h4 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h4><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。(可见性保证)</p><blockquote><p>JMM同步规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ul></blockquote><ul><li>由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行看。</li><li>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</li><li>内存模型图</li></ul><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20190416211412.png" alt="搜狗截图20190416211412"></p><h2 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>是 Java 虚拟机提供的轻量级的同步机制</p></blockquote><ul><li>保证可见性</li><li>禁止指令排序</li><li>不保证原子性</li></ul><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li><p>可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data.addOne();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" updated..."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data.a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// looping</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" job is done..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新线程修改a值后，可通知main线程，即可见性</span></span><br></pre></td></tr></table></figure><p>如果不加 volatile 关键字，则主线程会进入死循环，加 volatile 则主线程能够退出，说明加了 volatile 关键字变量，当有一个线程修改了值，会马上被另一个线程感知到，当前值作废，从新从主内存中获取值。对其他线程可见，这就叫可见性。</p></li><li><p>原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// test01();</span></span><br><span class="line">       test02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    data.addOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认有 main 线程和 gc 线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并不能输入 20000</p></li></ul><h4 id="禁止指令排序"><a href="#禁止指令排序" class="headerlink" title="禁止指令排序"></a>禁止指令排序</h4><p>volatile 实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象</p><p>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，他的作用有两个：</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0e75180bf35c40e2921493d0bf6bd684_th.png" alt="0e75180bf35c40e2921493d0bf6bd684_th"></p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21ebc7e8190c4966948c4ef4424088be_th.png" alt="21ebc7e8190c4966948c4ef4424088be_th"></p><h4 id="线程安全性保证"><a href="#线程安全性保证" class="headerlink" title="线程安全性保证"></a>线程安全性保证</h4><ul><li>工作内存与主内存同步延迟现象导致可见性问题<ul><li>可以使用 synchronzied 或 volatile 关键字解决，它们可以使用一个线程修改后的变量立即对其他线程可见</li></ul></li><li>对于指令重排导致可见性问题和有序性问题<ul><li>可以利用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排序优化</li></ul></li></ul><h3 id="你在哪些地方用到过-volatile"><a href="#你在哪些地方用到过-volatile" class="headerlink" title="你在哪些地方用到过 volatile"></a>你在哪些地方用到过 volatile</h3><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><ul><li><p>多线程环境下可能存在的安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton01.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现构造器里的内容会多次输出</p></li><li><p>双重锁单例</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton02 instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton01<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton02.getInstance());</span><br><span class="line">      &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有加 volatile 就不一定是线程安全的，原因是指令重排序的存在，加入 volatile 可以禁止指令重排。</p></li><li><p>原因是在于某一个线程执行到第一次检测，读取到的 instance 不为 null 时，<strong>instance 的引用对象可能还没有完成初始化。</strong></p></li><li><p><code>instance = new Singleton()</code> 可以分为以下三步完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null</span></span><br></pre></td></tr></table></figure></li><li><p>步骤 2 和步骤 3 不存在依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种优化是允许的。</p></li><li><p>发生重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null，但对象还没有初始化完成</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br></pre></td></tr></table></figure></li><li><p>所以不加 volatile 返回的实例不为空，但可能是未初始化的实例</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experimental points</title>
      <link href="/2019/12/02/Experimental-points/"/>
      <url>/2019/12/02/Experimental-points/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>论文实验要点，一些简要的安装、执行和debug命令行记录</p></blockquote><a id="more"></a><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><h4 id="训练环境"><a href="#训练环境" class="headerlink" title="训练环境"></a>训练环境</h4><p>服务器：<code>192.168.71.215</code>，用户：<code>root</code>，文件位置：<code>home/zw/</code>，硬件：<code>Tesla P40</code>，conda虚拟环境：<code>zw</code>，版本：<code>python=3.6</code>，<code>tensorflow-gpu=1.14</code></p><h4 id="展示环境"><a href="#展示环境" class="headerlink" title="展示环境"></a>展示环境</h4><p>本机，conda虚拟环境：<code>zw</code>，版本：<code>python=3.6</code>，<code>tensorflow-gpu=1.12</code></p><h3 id="CNN迁移学习要点"><a href="#CNN迁移学习要点" class="headerlink" title="CNN迁移学习要点"></a>CNN迁移学习要点</h3><p><strong>1.模型训练</strong></p><p><strong>2.模型精度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential,load_model</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_generator = test_datagen.flow_from_directory(<span class="string">'/home/zw/isic_2019_dataset/test'</span>,target_size=(<span class="number">448</span>, <span class="number">448</span>),batch_size=<span class="number">64</span>,shuffle=<span class="literal">False</span>)</span><br><span class="line">nsteps=len(test_generator)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model = load_model("model/BCNN_keras/model-9c.h5")</span></span><br><span class="line"><span class="comment"># model.load_weights('./model/BCNN_keras/model-9c.h5')</span></span><br><span class="line"></span><br><span class="line">test_loss, test_acc = model.evaluate_generator(test_generator, steps=nsteps) </span><br><span class="line"><span class="comment"># test_loss, test_acc = model.evaluate(test_generator, steps=5) </span></span><br><span class="line">print(<span class="string">'test acc:'</span>, test_acc)</span><br></pre></td></tr></table></figure><p><strong>3.结果指标</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_generator = test_datagen.flow_from_directory(<span class="string">'/home/zw/isic_2019_dataset/test'</span>,target_size=(<span class="number">448</span>, <span class="number">448</span>),batch_size=<span class="number">64</span>,shuffle=<span class="literal">False</span>)</span><br><span class="line">nsteps=len(test_generator)</span><br><span class="line"></span><br><span class="line">y_true=test_generator.classes</span><br><span class="line">class_label=test_generator.class_indices.keys()</span><br><span class="line">test_generator.reset()</span><br><span class="line">y_pred = model.predict_generator(test_generator,steps=nsteps)</span><br><span class="line">y_pred_final = np.argmax(y_pred, axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Confusion Matrix'</span>)</span><br><span class="line">cm=confusion_matrix(y_true, y_pred_final)</span><br><span class="line">print(cm)</span><br><span class="line">print(<span class="string">'Classification Report'</span>)</span><br><span class="line">print(classification_report(y_true, y_pred_final, target_names=class_label))</span><br></pre></td></tr></table></figure><p><strong>4.图像展示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(cm, classes,</span></span></span><br><span class="line"><span class="function"><span class="params">                          normalize=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                          title=<span class="string">'Confusion matrix'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                          cmap=plt.cm.Blues)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        cm = cm.astype(<span class="string">'float'</span>) / cm.sum(axis=<span class="number">1</span>)[:, np.newaxis]</span><br><span class="line">        print(<span class="string">"Normalized confusion matrix"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Confusion matrix, without normalization'</span>)</span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">'nearest'</span>, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = <span class="string">'.2f'</span> <span class="keyword">if</span> normalize <span class="keyword">else</span> <span class="string">'d'</span></span><br><span class="line">    thresh = cm.max() / <span class="number">2.</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(range(cm.shape[<span class="number">0</span>]), range(cm.shape[<span class="number">1</span>])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=<span class="string">"center"</span>,</span><br><span class="line">                 color=<span class="string">"white"</span> <span class="keyword">if</span> cm[i, j] &gt; thresh <span class="keyword">else</span> <span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    plt.ylabel(<span class="string">'True label'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Predicted label'</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plot_confusion_matrix(cm, classes=class_label,title=<span class="string">'Confusion matrix, without normalization'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="TensorBoard展示"><a href="#TensorBoard展示" class="headerlink" title="TensorBoard展示"></a>TensorBoard展示</h3><p>本机展示，一行命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activate zw</span><br><span class="line">tensorboard --logdir=F:\CondaProjects\tensorboard\vgg-<span class="number">8</span> --host=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-Sort</title>
      <link href="/2019/11/29/Algorithm-Sort/"/>
      <url>/2019/11/29/Algorithm-Sort/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>八大排序算法</p></blockquote><p>交换排序</p><p>冒泡排序</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShareBike Project</title>
      <link href="/2019/11/25/ShareBike-Project/"/>
      <url>/2019/11/25/ShareBike-Project/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>《共享单车可视化项目》——基于Spring Boot快速构建项目。包含核心的SSM框架即：SpringMVC，Spring，Mybatis，基于Maven项目管理工具。</p></blockquote><a id="more"></a><p><strong>整个流程大致为</strong>：地址栏输入网址，前端控制器（Controller）拦截请求进行处理，调用服务层（Service）方法，服务层再调用数据访问层（Dao/Mapper）与数据库进行交互获取数据，进行返回。</p><h3 id="表结构："><a href="#表结构：" class="headerlink" title="表结构："></a>表结构：</h3><table><thead><tr><th>字段</th><th>类型</th><th>长度</th><th>为空</th><th>说明</th></tr></thead><tbody><tr><td>company_id</td><td>string</td><td>6</td><td>否</td><td>企业标识</td></tr><tr><td>bicycle_id</td><td>string</td><td>14</td><td>否</td><td>车辆标识</td></tr><tr><td>longitude</td><td>decimal</td><td>10</td><td>否</td><td>车辆实时坐标-经度</td></tr><tr><td>latitude</td><td>decimal</td><td>9</td><td>否</td><td>车辆实时坐标-纬度</td></tr><tr><td>lock_status</td><td>number</td><td>1</td><td>否</td><td>车锁状态：车锁实时状态 0-开，1-关</td></tr><tr><td>update_time</td><td>timestamp</td><td>15</td><td>否</td><td>更新时间：当前UTC时间戳</td></tr></tbody></table><p>补充：数据为单车当天采集的一小时内的位置信息。</p><h3 id="sql建表"><a href="#sql建表" class="headerlink" title="sql建表"></a>sql建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`history_bike_status`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`history_bike_status`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`bicycle_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`longitude`</span> <span class="built_in">decimal</span>(<span class="number">11</span>,<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`latitude`</span> <span class="built_in">decimal</span>(<span class="number">11</span>,<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`company_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lock_status`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`upload_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1058621</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sharebike?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.sstl.sharebikevisualization.model</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span></span><br></pre></td></tr></table></figure><h3 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogLatObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double lat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bicycleId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String companyId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLog</span><span class="params">(Double log)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log = log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getLat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLat</span><span class="params">(Double lat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lat = lat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBicycleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bicycleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBicycleId</span><span class="params">(String bicycleId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycleId = bicycleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCompanyId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> companyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompanyId</span><span class="params">(String companyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.companyId = companyId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BikeMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库中单车数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT Count(DISTINCT bicycle_id) FROM history_bike_status"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">getTotalBikeAmount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6.13单车最后位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT longitude lng, latitude lat, bicycle_id "</span>  +</span><br><span class="line">            <span class="string">"FROM "</span> +</span><br><span class="line">            <span class="string">"( SELECT * FROM history_bike_status AS hbs WHERE hbs.company_id = #&#123;companyId&#125; AND "</span>+</span><br><span class="line">            <span class="string">"hbs.upload_time BETWEEN '2018-06-13 00:00:00' AND '2018-06-14 00:00:00' "</span> +</span><br><span class="line">            <span class="string">"    ORDER BY hbs.upload_time DESC "</span> +</span><br><span class="line">            <span class="string">" ) temp "</span>+</span><br><span class="line">            <span class="string">"GROUP BY bicycle_id"</span>)</span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyId</span><span class="params">(String companyId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchBeginDate, String searchEndDate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getAllPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchBeginDate, String searchEndDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis自定义查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getLastPositionByCompanyIdAndTime" resultMap="BaseResultMap"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">    longitude <span class="keyword">log</span>,</span><br><span class="line">    latitude lat,</span><br><span class="line">    bicycle_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        history_bike_status <span class="keyword">AS</span> hbs</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        hbs.company_id = <span class="comment">#&#123;arg0&#125; AND hbs.upload_time BETWEEN #&#123;arg1&#125;</span></span><br><span class="line">        <span class="keyword">AND</span> <span class="comment">#&#123;arg2&#125;</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> hbs.upload_time <span class="keyword">DESC</span></span><br><span class="line">    ) temp</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> bicycle_id</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getAllPositionByCompanyIdAndTime" resultMap="BaseResultMap"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">    longitude <span class="keyword">log</span>,</span><br><span class="line">    latitude lat,</span><br><span class="line">    bicycle_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    history_bike_status <span class="keyword">AS</span> hbs</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">    hbs.company_id = <span class="comment">#&#123;arg0&#125;</span></span><br><span class="line">    <span class="keyword">AND</span> hbs.upload_time <span class="keyword">BETWEEN</span> <span class="comment">#&#123;arg1&#125;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="comment">#&#123;arg2&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BikeServiceImpl</span> <span class="keyword">implements</span> <span class="title">BikeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BikeMapper bikeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTotalBikeAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getTotalBikeAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyId</span><span class="params">(String companyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getLastPositionByCompanyId(companyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchDate)</span> </span>&#123;</span><br><span class="line">        String searchBeginDate = searchDate+<span class="string">" 00:00:00"</span>;</span><br><span class="line">        String searchEndDate = searchDate+<span class="string">" 23:59:59"</span>;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getLastPositionByCompanyIdAndTime(companyId,searchBeginDate,searchEndDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getAllPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchDate)</span> </span>&#123;</span><br><span class="line">        String searchBeginDate = searchDate+<span class="string">" 00:00:00"</span>;</span><br><span class="line">        String searchEndDate = searchDate+<span class="string">" 23:59:59"</span>;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getAllPositionByCompanyIdAndTime(companyId,searchBeginDate,searchEndDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BikeService bikeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String SEARCH_DATE = <span class="string">"2018-06-13"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getOfoLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getOfoData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"05ofo"</span>,SEARCH_DATE);</span><br><span class="line">            System.out.println(SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getMobikeLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getMobikeData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatMobikeObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"07mobike"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatMobikeObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getXqLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getXqData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatXqObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"01xqcx"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatXqObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getOfoAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getOfoAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"05ofo"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getMobikeAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getMobikeAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"07mobike"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getXqAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getXqAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"01xqcx"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面展示基于html实现，展示，分区域，弹窗等基本展示功能就完结。</p><p>下面是一个基于缩放的点聚合优化；</p><h3 id="点聚合优化"><a href="#点聚合优化" class="headerlink" title="点聚合优化"></a>点聚合优化</h3><p>问题：加载大量点时候卡顿</p><p>缘由： 点是否聚合的判断是计算其是否在聚合点的范围内；百度地图开发文档的操作是，是在加点过程中进行DOM操作</p><blockquote><p> document文档 object 对象 model模型，Dom翻译中文：文档对象模型 </p><p> dom操作就是元素节点操作,指的是改变html的标签结构，它有两种情况： </p><ol><li>移动现有标签的位置；</li><li>将新创建的标签插入到现有的标签中 。</li></ol></blockquote><p>解决： addMarker() 方法内不停的去进行dom操作是最主要的弊端，所以在只要批量加点时，屏蔽DOM操作，计算完成后，再一次遍历DOM显示，速度就极大提升。 </p><p>参考链接：<a href="https://www.zhihu.com/question/24023333" target="_blank" rel="noopener"> 知乎 </a>，<a href="https://www.cnblogs.com/hss-blog/p/9040666.html" target="_blank" rel="noopener">博客园</a>，<a href="https://www.cnblogs.com/lightnull/p/6184867.html" target="_blank" rel="noopener">博主</a></p><ul><li><input disabled type="checkbox"> 后续的各种可视化功能也没开发出来</li></ul>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecKill Project</title>
      <link href="/2019/11/25/SecKill-Project/"/>
      <url>/2019/11/25/SecKill-Project/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>基于SpringBoot框架构建热点商品秒杀项目，亮点： Redis实现分布式Session， 页面缓存，RabbitMQ+接口优化， 线上部署</p></blockquote><a id="more"></a><p><a href="https://www.acfun.cn/v/ac10759479" target="_blank" rel="noopener">A站学习视频</a></p>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Algorithm</title>
      <link href="/2019/11/25/Java-Algorithm/"/>
      <url>/2019/11/25/Java-Algorithm/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>关于Java算法与数据结构的汇总栏</p></blockquote><a id="more"></a><ul><li><input disabled type="checkbox"> 递归&amp;分治</li><li><input disabled type="checkbox"> 贪心</li><li><input disabled type="checkbox"> 排序<ul><li><input disabled type="checkbox"> 八大排序</li></ul></li><li><input disabled type="checkbox"> 二分</li><li><input disabled type="checkbox"> 查找<ul><li><input disabled type="checkbox"> DFS</li><li><input disabled type="checkbox"> BFS</li><li><input disabled type="checkbox"> 回溯</li></ul></li><li><input disabled type="checkbox"> 动态规划</li><li><input disabled type="checkbox"> 字符串</li><li><input disabled type="checkbox"> 数据结构<ul><li><input disabled type="checkbox"> 数组</li><li><input disabled type="checkbox"> 栈</li><li><input disabled type="checkbox"> 队列</li><li><input disabled type="checkbox"> 树</li></ul></li><li><input disabled type="checkbox"> 实践<ul><li><input disabled type="checkbox"> <a href="https://zhangwell.github.io/2019/11/25/LeetCode-Top100/" target="_blank" rel="noopener">LeetCode-Top100</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Top100</title>
      <link href="/2019/11/25/LeetCode-Top100/"/>
      <url>/2019/11/25/LeetCode-Top100/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>LeetCode Top100 tags题解</p></blockquote><a id="more"></a><p>学习观看：</p><p><a href="https://www.bilibili.com/video/av51692387" target="_blank" rel="noopener">B站视频题解</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/11/25/Redis/"/>
      <url>/2019/11/25/Redis/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>针对面试中redis问答形式的总结</p><ul><li><input disabled type="checkbox"> 数据库与redis数据一致性问题</li></ul></blockquote><a id="more"></a><h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p><p><strong>1、速度快</strong></p><p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p><blockquote><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p></blockquote><p><strong>2、支持丰富数据类型</strong></p><p>支持 String ，List，Set，Sorted Set，Hash 。</p><blockquote><ul><li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li><li>用他的 Set 可以做高性能的 tag 系统等等。</li></ul></blockquote><p><strong>3、持久化存储</strong></p><p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p><h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul><li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</li></ul><p><strong>TODO网络 IO 模型</strong></p><ul><li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li><li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li></ul><p>TODO 有点看不懂，找亚普表弟确认中。</p><h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/2019/11/25/Redis/image-20191125110950740.png" alt="image-20191125110950740"></p><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="/2019/11/25/Redis/image-20191125111306113.png" alt="image-20191125111306113"></p><ul><li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li></ul><p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。</p><h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul><li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li><li>数据结构简单，操作也就简单；全程使用 hash 结构，读取速度快；</li><li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li><li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li><li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li></ul><h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p><ul><li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li></ul><h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p><ul><li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ul><p><strong>RDB又存在哪些劣势呢？</strong></p><ul><li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>AOF的优势有哪些呢？</strong></p><ul><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul><p><strong>AOF的劣势有哪些呢？</strong></p><ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul><p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p><p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure><p><strong>AOF持久化配置</strong></p><p>在Redis的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p></li><li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p><ul><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p><blockquote><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p></blockquote></li></ul></li></ul><p>在 Redis4.0 版本开始，当使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034" target="_blank" rel="noopener">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。</p><h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul><li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行 Debug Reload</li><li>执行 Shutdown 且没有开启 AOF 持久化</li></ul><p><strong>重要知识：</strong></p><ul><li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li><li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li><li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><p>BGSAVE底层实现方式：</p><p><img src="/2019/11/25/Redis/1566521057383.png" alt="1566521057383"></p><ol><li>查询子进程是否有冲突</li><li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li></ol><p><img src="/2019/11/25/Redis/1566521457362.png" alt="1566521457362"></p><p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p><p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p><h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><p>Redis 提供了 3 种数据过期策略：</p><ul><li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li><li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「数据“淘汰”策略」</a> 。</li></ul><p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html" target="_blank" rel="noopener">《关于 Redis 数据过期策略》</a> 文章。</p><h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p><p>Redis 提供了 6 种数据淘汰策略：</p><ol><li>volatile-lru</li><li>volatile-ttl</li><li>volatile-random</li><li>allkeys-lru</li><li>allkeys-random</li><li>no-enviction</li></ol><p><img src="/2019/11/25/Redis/image-20191125135302360.png" alt="image-20191125135302360"></p><p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">《Redis实战（二） 内存淘汰机制》</a> 。</p><p><strong>Redis LRU 算法</strong></p><p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p><ul><li><p>具体的可以看看 <a href="http://ifeve.com/lru-cache/" target="_blank" rel="noopener">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p><p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p></li></ul><blockquote><p>这个问题的目的是，如何保证热点数据不要被淘汰。</p></blockquote><p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p><p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p><p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p><h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p><p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul><li>数据缓存</li><li>会话缓存</li><li>时效性数据</li><li>访问频率</li><li>计数器</li><li>社交列表</li><li>记录用户判定信息</li><li>交集、并集和差集</li><li>热门列表与排行榜</li><li>最新动态</li><li>消息队列</li><li>分布式锁</li></ul><p>详细的介绍，可以看看如下文章：</p><ul><li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li><li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li><li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li><li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li></ul><p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p><p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p><p>具体的代码实现，可以看看 <a href="https://www.jianshu.com/p/e3abbfc59d77" target="_blank" rel="noopener">《一道 Redis 面试题》</a> 。</p><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p><ul><li><p>Redisson</p><blockquote><p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p></blockquote></li><li><p>Jedis</p><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p><p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><p>Lettuce</p><blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p></blockquote></li></ul><p>Spring Boot 2.x 内置使用 Lettuce 。</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p><ul><li>互斥性：任意时刻，只能有一个客户端获取锁；</li><li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li><li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li><li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li></ul><p><strong>方案一：set 指令</strong></p><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><ul><li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li><li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li></ul><p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span> [EX <span class="keyword">seconds</span>] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/25/Redis/%E5%89%91%E6%8C%87Java%5C1566518903284.png" alt="1566518903284"></p><ul><li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li><li>具体的实现，可以参考 <a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/" target="_blank" rel="noopener">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li></ul><p><strong>方案二：redlock</strong></p><p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p><p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">《Redlock：Redis分布式锁最牛逼的实现》</a></li><li><a href="https://www.jianshu.com/p/f302aa345ca8" target="_blank" rel="noopener">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li></ul><p><strong>对比 Zookeeper 分布式锁</strong></p><ul><li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li><li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li></ul><p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p><h2 id="Redis并发竞争key"><a href="#Redis并发竞争key" class="headerlink" title="Redis并发竞争key"></a>Redis并发竞争key</h2><p>即：多个系统同时对一个 key 进行操作</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><ul><li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li><li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li><li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li><li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li></ul><p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p><p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p><h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p><p><strong>Redis 如何做大量数据插入？</strong></p><p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p><p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">《Redis 大量数据插入》</a> 文章。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p><ul><li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p></li><li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p></li><li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p></li><li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p></li><li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p><blockquote><p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p></blockquote></li></ul><p><strong>如何实现 Redis CAS 操作？</strong></p><p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p><p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26" target="_blank" rel="noopener">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p><h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p><ul><li>1、Redis Sentinel</li><li>2、Redis Cluster</li><li>3、Twemproxy</li><li>4、Codis</li><li>5、客户端分片</li></ul><p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">《Redis 实战（四）集群机制》</a> 这篇文章。</p><p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p><blockquote><p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p><p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></blockquote><p><strong>选择</strong></p><p>目前一般在选型上来说：</p><ul><li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p></li><li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p><p><strong>Redis 集群如何扩容？</strong></p></li></ul><blockquote><p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p></blockquote><ul><li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li><li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li></ul><h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p><p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p><ul><li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li><li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li><li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><p><strong>好处</strong></p><p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p><p>更多详细，可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md" target="_blank" rel="noopener">《Redis 主从架构》</a> 。</p><h2 id="数据与数据库双写一致"><a href="#数据与数据库双写一致" class="headerlink" title="数据与数据库双写一致"></a>数据与数据库双写一致</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通用的读操作</p><ul><li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li><li>最后将数据返回给请求</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>写操作</strong>可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li><p>设置<strong>键的过期时间</strong>，可以保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p></li><li><p>更新操作的细分</p></li></ol><p>执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><blockquote><p>注：这里的缓存操作一般是删除操作。</p></blockquote><p>对比：</p><ul><li>先删除缓存，再更新数据库<ul><li>在高并发下表现不如意，在原子性被破坏时表现优异</li></ul></li><li>先更新数据库，再删除缓存(<code>Cache Aside Pattern</code>设计模式)<ul><li>在高并发下表现优异，在原子性被破坏时表现不如意</li></ul></li></ul><h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">《Redis 哨兵集群实现高可用》</a> 。</p><h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">《Redis 集群教程》</a> 完整版</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md" target="_blank" rel="noopener">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li></ul><p><strong>说说 Redis 哈希槽的概念？</strong></p><p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p><p><strong>Redis Cluster 的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p><p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p><ul><li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li></ul><p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p><p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><p><strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p><p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p><strong>Redis 集群如何选择数据库？</strong></p><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p><blockquote><p>重点问题，仔细理解。</p></blockquote><ul><li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li><li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li><li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li></ul><h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote><p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 集群都有哪些方案？」</a> 是同类问题。</p></blockquote><p>关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html" target="_blank" rel="noopener">《Redis 分区》</a> 文章。</p><ul><li>Redis 分区是什么？</li><li>分区的优势？</li><li>分区的不足？</li><li>分区类型？</li></ul><p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p><ul><li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li><li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li></ul><p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p><p>Redis 分区方案，主要分成两种类型：</p><ul><li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul><li>案例：Redis Cluster 和客户端分区。</li></ul></li><li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul><li>案例：Twemproxy 和 Codis 。</li></ul></li></ul><p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p><p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p><p>如下是网络上的一个大答案：</p><blockquote><p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p></blockquote><ul><li>和飞哥沟通了下，这个操作不是很合理。</li><li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li></ul><h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA" target="_blank" rel="noopener">《Redis 几个重要的健康指标》</a></p><ul><li>存活情况</li><li>连接数</li><li>阻塞客户端数量</li><li>使用内存峰值</li><li>内存碎片率</li><li>缓存命中率</li><li>OPS</li><li>持久化</li><li>失效KEY</li><li>慢日志</li></ul><p><strong>如何提高 Redis 命中率？</strong></p><p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html" target="_blank" rel="noopener">《如何提高缓存命中率（Redis）》</a> 。</p><h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865" target="_blank" rel="noopener">《Redis 的内存优化》</a></p><ul><li><p>redisObject 对象</p></li><li><p>缩减键值对象</p></li><li><p>共享对象池</p></li><li><p>字符串优化</p></li><li><p>编码优化</p></li><li><p>控制 key 的数量</p><p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p></li></ul><p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p><p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p><p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p><p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><ul><li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li><li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li></ul><h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p><ul><li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li><li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li><li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li></ul><p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong></p><p><strong>3、尽量避免在压力很大的主库上增加从库。</strong></p><p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong></p><ul><li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li></ul><p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase</title>
      <link href="/2019/11/24/DataBase/"/>
      <url>/2019/11/24/DataBase/</url>
      
        <content type="html"><![CDATA[<p> 引言：</p><blockquote><p>针对面试的mysql数据库总结</p></blockquote><a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p><strong>客观存在并可相互区别的事物</strong>称之为实体。可以看成是Java类</p><p>例子：(课程关系表)就是一个实体。</p><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p><strong>实体所具有的某一特性</strong>称之为属性。可以看成是Java类的成员变量。属性在数据库中又称为字段（或者是列）</p><p>例子：(课程名)，(课程号)、(学时)就是属性名。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>除含有属性名所在的行之外的其他行称之为元组。</strong></p><p><strong>下面的每一行数据都称之为元组</strong><br>(C401001 数据结构 70)<br>(C401002 操作系统 80)<br>(C402001 计算机原理 60)</p><h3 id="码-Key"><a href="#码-Key" class="headerlink" title="码(Key)"></a>码(Key)</h3><p><strong>码也被称作是关键字。它可以唯一标识一个实体</strong>。</p><p>候选码和主码：</p><ul><li>候选码：如果一组属性集能唯一地标识一个关系中的元组而又不含有多余的属性，则称该属性集为该关系的候选码 。（<strong>候选码可能不止有一个</strong>）</li><li>主码：用户选定的那个候选键称为主键</li></ul><p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p><p>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</p><p>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码</p><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系名和其属性集合的组合称之为关系模式</strong>。</p><p>关系模式例子：课程关系表(课程号,课程名,学时)</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>关系模型要求元组的每一个分量都是原子性的，也就是说，它必须属于某种元素类型，如Integer、String等等，不能是列，集合，记录，数组！</p><p><strong>域就代表着该元组中每个分量的类型</strong>，例如：课程号:string,课程名:string,学时:int</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2019/11/24/DataBase/1566261820297.png" alt="1566261820297"></p><p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p><p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p><p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么使用索引？"><a href="#为什么使用索引？" class="headerlink" title="为什么使用索引？"></a>为什么使用索引？</h3><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p><p><strong>磁盘文件存储</strong></p><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><h3 id="什么样的信息能够称为索引？"><a href="#什么样的信息能够称为索引？" class="headerlink" title="什么样的信息能够称为索引？"></a>什么样的信息能够称为索引？</h3><p>主键，唯一键，普通键，有一定区分性</p><p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p><blockquote><p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p></blockquote><p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p><blockquote><p>唯一键不是主键，但主键有不可重复性</p><p>一张表可以有多个唯一键，但只能有一个主键</p></blockquote><p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p><h3 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h3><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p><p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p><p><img src="/2019/11/24/DataBase/1566261830802.png" alt="1566261830802"></p><p>特性：</p><p><img src="/2019/11/24/DataBase/1566261842897.png" alt="1566261842897"></p><p><img src="/2019/11/24/DataBase/1566261850318.png" alt="1566261850318"></p><p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p><p>B+树：</p><p><img src="/2019/11/24/DataBase/1566261860507.png" alt="1566261860507"></p><p>结论：B+树更适合，原因：</p><ul><li><p><strong>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</strong></p></li><li><p><strong>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</strong></p></li><li><p><strong>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</strong></p></li></ul><p><strong>Hash索引了解一下：</strong></p><p>缺点：</p><ul><li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li><li>无法运用索引值来排序</li><li>不能利用部分索引键查询</li><li>不能避免表扫描，哈希值可能重复，需要全表扫描</li><li>大量hash值相等时，效率很底。</li></ul><p>密集索引和稀疏索引</p><p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列（属性）的数据。</p><blockquote><p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p></blockquote><p>稀疏索引：叶子节点仅保存了键位信息（索引键位）及其主键。</p><p>InnoDB的索引</p><p><img src="/2019/11/24/DataBase/1566261871063.png" alt="1566261871063"></p><h3 id="如何定位并优化sql？"><a href="#如何定位并优化sql？" class="headerlink" title="如何定位并优化sql？"></a>如何定位并优化sql？</h3><ul><li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p><p><img src="/2019/11/24/DataBase/1566262283010.png" alt="1566262283010"></p></li><li><p>使用explain等工具分析sql</p><p><img src="/2019/11/24/DataBase/1566262067821.png" alt="1566262067821"></p><ul><li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li><li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li></ul><p><img src="/2019/11/24/DataBase/1566261930304.png" alt="1566261930304"></p><ul><li>字段：extra，如图</li></ul><p><img src="/2019/11/24/DataBase/1566261963108.png" alt="1566261963108"></p></li><li><p>修改sql或者尽量让sql走索引</p><ul><li>改用索引查</li></ul><p><img src="/2019/11/24/DataBase/1566262116465.png" alt="1566262116465"></p><ul><li>添加索引</li></ul><p><img src="/2019/11/24/DataBase/1566262137053.png" alt="1566262137053"></p></li><li><p>使用fore_index()测试那个索引更好</p></li></ul><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p><img src="/2019/11/24/DataBase/1566262151740.png" alt="1566262151740"></p><p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p><p>索引建立的越多越好吗？</p><p><img src="/2019/11/24/DataBase/1566262159079.png" alt="1566262159079"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>首先需要了解：</p><ul><li>对于<code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li><li><strong>MyISAM</strong>在执行查询语句<code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（<code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li></ul><p>其次需要了解：</p><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><ul><li>也就是说，<strong>InnoDB的行锁是基于索引的</strong>！</li></ul><p>Myisam：表级锁，不支持行级锁</p><p>InnoDB：默认行级锁，支持表级锁，</p><blockquote><p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p></blockquote><p>无论表锁还是行锁，默认都分为共享锁和排他锁</p><p><img src="/2019/11/24/DataBase/1566262385992.png" alt="1566262385992"></p><h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>MyISAM</p><ul><li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li><li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li><li>适合没有事务的</li></ul><p>InnoDB</p><ul><li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li><li>支持事务的系统</li></ul><p>数据库锁分类：</p><ul><li>按粒度划分：表级锁，行级锁，页级锁</li><li>按级别划分：共享锁，排他锁</li><li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li><li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li><li><strong>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</strong></li></ul><h3 id="乐观锁和悲观锁："><a href="#乐观锁和悲观锁：" class="headerlink" title="乐观锁和悲观锁："></a>乐观锁和悲观锁：</h3><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul><li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li><li>实现方式：使用数据库中的锁机制</li></ul></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<ul><li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li><li>实现方式：使用version版本或者时间戳</li></ul></li></ul><h2 id="事务隔离与锁"><a href="#事务隔离与锁" class="headerlink" title="事务隔离与锁"></a>事务隔离与锁</h2><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><p>不同的隔离级别对锁的使用是不同的，<strong>锁的应用最终导致不同事务的隔离级别</strong></p><p>ACID：原子性，一致性，隔离性，持久性</p><p>事务的隔离性以及各级别下的并发问题</p><p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p><p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事务读取另一个事务未提交数据</p><p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p><p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p><p><img src="/2019/11/24/DataBase/1566263834174.png" alt="1566263834174"></p><h3 id="InnoDB引擎的隔离与锁"><a href="#InnoDB引擎的隔离与锁" class="headerlink" title="InnoDB引擎的隔离与锁"></a>InnoDB引擎的隔离与锁</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种<strong>具体方式</strong>，用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别。</p><blockquote><p>而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p></blockquote><blockquote><p>InnoDB<strong>基于行锁</strong>实现了MVCC多版本并发控制，MVCC在隔离级别下的<code>Read committed</code>和<code>Repeatable read</code>下工作。MVCC能够实现<strong>读写不阻塞</strong>！</p></blockquote><h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><ul><li>通过一定机制生成一个数据请求<strong>时间点的一致性数据快照（Snapshot)</strong>，并用这个快照来提供一定级别（<strong>语句级或事务级</strong>）的<strong>一致性读取</strong>。从用户的角度来看，好像是<strong>数据库可以提供同一数据的多个版本</strong>。</li><li>版本号<ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。<ul><li>版本号用来和查询到的每行记录的版本号进行比较。</li></ul></li></ul></li><li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：<ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul></li></ul><h4 id="Read-committed实现"><a href="#Read-committed实现" class="headerlink" title="Read committed实现"></a><code>Read committed</code>实现</h4><p>原理：快照读机制，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><p><code>Read committed</code><strong>避免脏读</strong>的做法其实很简单：</p><ul><li><strong>在读取的时候生成一个版本号，直到事务其他commit被修改了之后，才会有新的版本号</strong>，读取时会对比版本号</li></ul><p>过程：</p><ul><li>事务A读取了记录(生成版本号)</li><li>事务B修改了记录(此时加了写锁)</li><li>事务A再读取的时候，<strong>是依据最新的版本号来读取的</strong>(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据。</li></ul><h4 id="Repeatable-read实现"><a href="#Repeatable-read实现" class="headerlink" title="Repeatable read实现"></a><code>Repeatable read</code>实现</h4><p><code>Read committed</code>会出现不可重复读：<strong>一个事务可以看到其他事务所做的修改</strong>。</p><p>例如，<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样（危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了）</strong></p><blockquote><p><code>Read committed</code>是<strong>语句级别</strong>（执行语句）的快照！<strong>每次读取的都是当前最新的数据行版本</strong>！</p></blockquote><blockquote><p><code>Repeatable read</code>避免不可重复读是<strong>事务级别</strong>的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。</p></blockquote><p>总结：事务开启时使用系统版本作为事务版本号，事务开启时数据行更新后使用最新数据行版本号，<strong>读提交实现</strong>使用数据行版本号的比对，确保每次commit被修改了之后，才会有新的版本号，通过版本号实现隔离；<strong>重复读实现</strong>对比的是快照中的事务版本号，即在 <strong>tempdb</strong> 中存储原始行的副本，和为该行添加事务版本号，通过版本号实现隔离。</p><h3 id="InnoDB在可重复度隔离级别下是如何避免幻读？"><a href="#InnoDB在可重复度隔离级别下是如何避免幻读？" class="headerlink" title="InnoDB在可重复度隔离级别下是如何避免幻读？"></a>InnoDB在可重复度隔离级别下是如何避免幻读？</h3><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><p>表象：快照度（非阻塞读）——伪MVCC</p><p>内在：next-key锁（行锁+gap锁）</p><p><img src="/2019/11/24/DataBase/1566264130165.png" alt="1566264130165"></p><p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p><p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p><p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p><ol><li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li><li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li></ol><p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p><p><img src="/2019/11/24/DataBase/1566265001814.png" alt="1566265001814"></p><p>再次修改为（11，32，45）时会发生：</p><p><img src="/2019/11/24/DataBase/1566264973315.png" alt="1566264973315"></p><ol start="3"><li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li></ol><p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p><p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>next-key锁（record锁+gap锁）</p><ul><li><p>record锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</p></li><li><p>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</p></li><li><p>next-key锁：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10],(10, 11],(11, 13],(13, 20],(20, +∞)</span><br></pre></td></tr></table></figure></li></ul><p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p><p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p><ul><li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li><li>如果where条件部分命中或者未命中，就会加上gap锁</li></ul><p>gap锁会出现在非唯一索引或者不走索引的当前读中</p><p>非唯一索引：</p><p><img src="/2019/11/24/DataBase/1566268250911.png" alt="1566268250911"></p><p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p><p>不走索引</p><p><img src="/2019/11/24/DataBase/1566268427287.png" alt="1566268427287"></p><p>会对所有gap上锁，类似表锁，也能防止幻读。</p><p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><strong>在我们书写SQL语句的时候，其实书写的顺序、策略会影响到SQL的性能，虽然实现的功能是一样的，但是它们的性能会有些许差别。</strong></p><p>因此，下面就讲解在书写SQL的时候，怎么写比较好。</p><hr><h3 id="选择最有效率的表名顺序"><a href="#选择最有效率的表名顺序" class="headerlink" title="选择最有效率的表名顺序"></a>选择最有效率的表名顺序</h3><p>数据库的解析器按照<strong>从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p><p>在FROM子句中包含多个表的情况下：</p><ul><li><strong>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</strong></li><li><strong>也就是说：选择记录条数最少的表放在最后</strong></li></ul><p>如果有3个以上的表连接查询：</p><ul><li><strong>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推</strong>。</li><li><strong>也就是说：被其他表所引用的表放在最后</strong></li></ul><p>例如：查询员工的编号，姓名，工资，工资等级，部门名</p><p><strong>emp表被引用得最多，记录数也是最多，因此放在form字句的最后面</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname</span><br><span class="line"><span class="keyword">from</span> salgrade,dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal)</span><br></pre></td></tr></table></figure><hr><h3 id="WHERE子句中的连接顺序"><a href="#WHERE子句中的连接顺序" class="headerlink" title="WHERE子句中的连接顺序"></a>WHERE子句中的连接顺序</h3><p>数据库采用自<strong>右而左的顺序解析WHERE子句</strong>,根据这个原理,<strong>表之间的连接必须写在其他WHERE条件之左</strong>,那些<strong>可以过滤掉最大数量记录的条件必须写在WHERE子句的之右</strong>。</p><p><strong>emp.sal可以过滤多条记录，写在WHERE字句的最右边</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,dept.dname</span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal &gt; <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="SELECT子句中避免使用-号"><a href="#SELECT子句中避免使用-号" class="headerlink" title="SELECT子句中避免使用*号"></a>SELECT子句中避免使用*号</h3><p>我们当时学习的时候，星号是可以获取表中全部的字段数据的。</p><ul><li><strong>但是它要通过查询数据字典完成的，这意味着将耗费更多的时间</strong></li><li>使用*号写出来的SQL语句也不够直观。</li></ul><hr><h3 id="用TRUNCATE替代DELETE"><a href="#用TRUNCATE替代DELETE" class="headerlink" title="用TRUNCATE替代DELETE"></a>用TRUNCATE替代DELETE</h3><p>这里仅仅是：<strong>删除表的全部记录，除了表结构才这样做</strong>。</p><p><strong>DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快</strong></p><hr><h3 id="多使用内部函数提高SQL效率"><a href="#多使用内部函数提高SQL效率" class="headerlink" title="多使用内部函数提高SQL效率"></a>多使用内部函数提高SQL效率</h3><p><strong>例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。</strong></p><hr><h3 id="使用表或列的别名"><a href="#使用表或列的别名" class="headerlink" title="使用表或列的别名"></a>使用表或列的别名</h3><p><strong>如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了。。。</strong></p><hr><h3 id="多使用commit"><a href="#多使用commit" class="headerlink" title="多使用commit"></a>多使用commit</h3><p>comiit会释放回滚点…</p><hr><h3 id="善用索引"><a href="#善用索引" class="headerlink" title="善用索引"></a>善用索引</h3><p>索引就是为了提高我们的查询数据的，当表的记录量非常大的时候，我们就可以使用索引了。</p><hr><h3 id="SQL写大写"><a href="#SQL写大写" class="headerlink" title="SQL写大写"></a>SQL写大写</h3><p>我们在编写SQL 的时候，官方推荐的是使用大写来写关键字，<strong>因为Oracle服务器总是先将小写字母转成大写后，才执行</strong></p><hr><h3 id="避免在索引列上使用NOT"><a href="#避免在索引列上使用NOT" class="headerlink" title="避免在索引列上使用NOT"></a>避免在索引列上使用NOT</h3><p>因为Oracle服务器遇到NOT后，他就会停止目前的工作，转而执行全表扫描</p><h4 id="避免在索引列上使用计算"><a href="#避免在索引列上使用计算" class="headerlink" title="避免在索引列上使用计算"></a>避免在索引列上使用计算</h4><p>WHERE子句中，<strong>如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢</strong></p><h4 id="用-gt-替代-gt"><a href="#用-gt-替代-gt" class="headerlink" title="用 &gt;= 替代 &gt;"></a>用 <code>&gt;=</code> 替代 <code>&gt;</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">低效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt; <span class="number">3</span>   </span><br><span class="line">首先定位到DEPTNO=<span class="number">3</span>的记录并且扫描到第一个DEPT大于<span class="number">3</span>的记录</span><br><span class="line">高效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;= <span class="number">4</span>  </span><br><span class="line">直接跳到第一个DEPT等于<span class="number">4</span>的记录</span><br></pre></td></tr></table></figure><h4 id="用IN替代OR"><a href="#用IN替代OR" class="headerlink" title="用IN替代OR"></a>用IN替代OR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal = <span class="number">1500</span> <span class="keyword">or</span> sal = <span class="number">3000</span> <span class="keyword">or</span> sal = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span> (<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">800</span>);</span><br></pre></td></tr></table></figure><h4 id="总是使用索引的第一个列"><a href="#总是使用索引的第一个列" class="headerlink" title="总是使用索引的第一个列"></a>总是使用索引的第一个列</h4><p>如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> emp_sal_job_idex</span><br><span class="line"><span class="keyword">on</span> emp(sal,job);</span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp  </span><br><span class="line"><span class="keyword">where</span> job != <span class="string">'SALES'</span>;    </span><br><span class="line"></span><br><span class="line">上边就不使用索引了。</span><br></pre></td></tr></table></figure><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul><li>1）范式优化： 比如消除冗余（节省空间。。）</li><li>2）反范式优化：比如适当加冗余等（减少join）</li><li>3）拆分表： 垂直拆分和水平拆分</li></ul><h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><p>money</p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。<br>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y</p></blockquote><p>总结一下：</p><ul><li>首先要明确的是：范式一到三是越来越严格的。<strong>满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</strong></li><li>第一范式：<strong>字段是最小的的单元不可再分</strong><ul><li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li></ul></li><li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul><li><strong>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的</strong></li><li>学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</li></ul></li><li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul><li><strong>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖</strong></li><li>比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种基于数据表的一种<strong>虚表</strong></p><ul><li>（1）视图是一种虚表</li><li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li><li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li><li>（4）视图向用户提供基表数据的另一种表现形式</li><li>（5）视图没有存储真正的数据，真正的数据还是存储在基表中</li><li>（6）程序员虽然操作的是视图，但最终视图还会转成操作基表</li><li>（7）一个基表可以有0个或多个视图</li></ul><p>有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段…</p><p>那么把全部的字段都都显示给他们看，这是不合理的。</p><p>我们应该做到：<strong>他们想看到什么样的数据，我们就给他们什么样的数据…一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来…</strong></p><p><strong>视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便</strong>…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h4 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h4><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img"></p><h4 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h4><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img"></p><h4 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h4><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img"></p><h4 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h4><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img"></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="MySQL表设计要注意什么？"><a href="#MySQL表设计要注意什么？" class="headerlink" title="MySQL表设计要注意什么？"></a>MySQL表设计要注意什么？</h3><h4 id="主键是用自增还是UUID"><a href="#主键是用自增还是UUID" class="headerlink" title="主键是用自增还是UUID?"></a>主键是用自增还是UUID?</h4><p>肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h4 id="主键为什么不推荐有业务含义"><a href="#主键为什么不推荐有业务含义" class="headerlink" title="主键为什么不推荐有业务含义?"></a>主键为什么不推荐有业务含义?</h4><p>有如下两个原因</p><ul><li>因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</li><li>带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</li></ul><h4 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型?"></a>时间字段用什么类型?</h4><p>(1)<code>varchar</code>，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为<code>2013111</code>的数据，请问这是代表2013年1月11日，还是2013年11月1日？<br>其次，做时间比较运算，你需要用<code>STR_TO_DATE</code>等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p><p>(2)<code>timestamp</code>，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用<code>timestamp</code>类型存储的。<br>但是它有一个优势，<code>timestamp</code>类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TIME_ZONE</span> = <span class="string">"america/new_york"</span>;</span><br></pre></td></tr></table></figure><p>你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p><p>(3)<code>datetime</code>，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p><p>(4)<code>bigint</code>，也是8个字节，自己维护一个时间戳，表示范围比<code>timestamp</code>大多了，就是要自己维护，不大方便。</p><h4 id="为什么不直接存储图片、音频、视频等大容量内容"><a href="#为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="为什么不直接存储图片、音频、视频等大容量内容?"></a>为什么不直接存储图片、音频、视频等大容量内容?</h4><p>我们在实际应用中，都是用<code>HDFS</code>来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是<code>text</code>和<code>blob</code>类型。但是，我们在生产中，基本不用这两个类型！<br>主要原因有如下两点</p><ul><li>(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢</li><li>(2)<code>binlog</code>内容太多。因为你数据内容比较大，就会造成<code>binlog</code>内容比较多。大家也知道，主从同步是靠<code>binlog</code>进行同步，<code>binlog</code>太大了，就会导致主从同步效率问题！</li></ul><p>因此，不推荐使用<code>text</code>和<code>blob</code>类型！</p><h4 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL?"></a>字段为什么要定义为NOT NULL?</h4><p>(1)索引性能不好</p><blockquote><p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。                                                                              </p></blockquote><p>(2)查询会出现一些不可预料的结果<br>这里举一个例子，大家就懂了。假设，表结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>表数据是这样的</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">孤独烟</td></tr><tr><td align="center">3</td><td align="center">null</td></tr><tr><td align="center">5</td><td align="center">肥朝</td></tr><tr><td align="center">7</td><td align="center">null</td></tr></tbody></table><p>你执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> table_2;</span><br></pre></td></tr></table></figure><p>你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。<br>记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.</p><h3 id="索引的特点"><a href="#索引的特点" class="headerlink" title="索引的特点"></a>索引的特点</h3><ul><li><strong>是一种快速查询表中内容的机制，</strong></li><li><strong>运用在表中某个些字段上，但存储时，独立于表之外</strong></li></ul><p>索引的特点</p><ul><li>索引一旦建立, <strong>DB管理系统会对其进行自动维护</strong>, 而且由DB管理系统决定何时使用索引</li><li>用户不用在查询语句中指定使用哪个索引</li><li><strong>在定义primary key或unique约束后系统自动在相应的列上创建索引</strong></li><li>用户也能按自己的需求，对指定单个字段或多个字段，添加索引</li></ul><table><thead><tr><th align="center">什么时候【要】创建索引</th><th align="center">什么时候【不要】创建索引</th></tr></thead><tbody><tr><td align="center">表经常进行 SELECT 操作</td><td align="center">表经常进行 INSERT/UPDATE/DELETE 操作</td></tr><tr><td align="center">表很大(记录超多)，记录内容分布范围很广</td><td align="center">表很小(记录超少)</td></tr><tr><td align="center">列名经常在 WHERE 子句或连接条件中出现</td><td align="center">列名不经常作为连接条件或出现在 WHERE 子句中</td></tr></tbody></table><p><strong>索引优缺点：</strong></p><ul><li>索引加快数据库的检索速度</li><li>索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，<strong>因为大部分数据更新需要同时更新索引</strong>)</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li><li>索引需要占物理和数据空间</li></ul><p>索引分类：</p><ul><li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li><li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li><li><strong>聚集索引</strong>(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li><li><strong>二级索引</strong>(Non-clustered)：二级索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="一个-SQL-执行的很慢？"><a href="#一个-SQL-执行的很慢？" class="headerlink" title="一个 SQL 执行的很慢？"></a>一个 SQL 执行的很慢？</h3><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log （<strong>重做日志</strong>）写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><h3 id="MySQL-基础架构分析"><a href="#MySQL-基础架构分析" class="headerlink" title="MySQL 基础架构分析"></a>MySQL 基础架构分析</h3><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><p><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p><p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p><h3 id="SQL语句执行过程分析"><a href="#SQL语句执行过程分析" class="headerlink" title="SQL语句执行过程分析"></a>SQL语句执行过程分析</h3><p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p><p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog（归档日志）—》redo log commit</p><h3 id="常用的存储引擎"><a href="#常用的存储引擎" class="headerlink" title="常用的存储引擎"></a>常用的存储引擎</h3><ul><li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><table><thead><tr><th align="center"></th><th align="center">Innodb</th><th align="center">MyIASM</th></tr></thead><tbody><tr><td align="center">事务</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">哈希索引</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">全文索引</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">存储容量</td><td align="center">64TB</td><td align="center">无上限</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ComputerNetworks</title>
      <link href="/2019/11/22/ComputerNetworks/"/>
      <url>/2019/11/22/ComputerNetworks/</url>
      
        <content type="html"><![CDATA[<p>引言</p><blockquote><ol><li>记录慕课网《剑指offer》课程中计算机网络部分面试知识</li><li>面试问题记录，涉及的较少</li></ol></blockquote><a id="more"></a><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p> <img src="/2019/11/22/ComputerNetworks/image-20191122201138746.png" alt="image-20191122201138746"> </p><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><ul><li><p>物理层：两台物理机器之间传输比特流，定义物理设备的标准，网卡</p></li><li><p>数据链路层：在传输比特流的过程会产生各种错误，数据链路层应运而生，该层定义了如何格式化数据以进行传输以及控制对物理介质的访问，还提供错误检测和纠正。该层将比特数据组成帧，交换机工作在该层，对帧解码，根据帧中的数据将信息发送到正确的接收方。</p></li></ul><blockquote><p>随着网络节点的增加，点对点间的通信是需要经过多个节点的，如何找到目标节点，如何选择最佳路径是首要需求，此时产生网络层</p></blockquote><ul><li>网络层：其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。发送方综合考虑发送优先权、网络拥塞、服务质量、可选路由的花费决定从网络中一个节点A到另一个网络中B的最佳路径，网络层处理并智能指导数据传送，路由器连接网络各端，所以路由器属于网络层。此层的数据称为数据包。本层关注TCP/IP协议中的IP协议。</li></ul><blockquote><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，可能需要很长时间，网络在通信过程会中断多次，此时为了保证传输文件的准确性，需要对发出去的数据进行切分，切为数据段。当发生数据段络丢失，失序等情况时，传输层应运而生。</p></blockquote><ul><li>传输层：解决主机间的数据传输，和传输质量问题。该层传输协议进行流量控制或是基于接收方可接受数据的快慢程度规定适当的发送速率。同时分割数据包以适应在网络上传输（以太网无法接受大于1500字节的数据包），分割数据为数据片，同时在数据片上给定序号，以便接受时可按序排组。需要关注TCP和UDP协议。</li></ul><blockquote><p>为了不用用户级不要每次调用TCP打包数据，IP协议去寻找路由，现在需要自动收发包，自动寻址的功能，会话层应运而生</p></blockquote><ul><li>会话层：作用是建立和管理应用程序之间的通信。至此可以保证用用程序能够自动收发包和寻址。</li></ul><blockquote><p>考虑各应用程序的环境不同，如window和Linux之间的差异，需要表示层来消除</p></blockquote><ul><li>表示层：解决不同系统之间的通信语法的问题，该层数据将按照网络能够理解的方式进行格式化。此时完成数据转化成相应的字节。</li></ul><blockquote><p>此时发送方知道发送的数据是什么，转换成字节数据有多长，但接收方并不知道，为了发送方和接收方能够理解传输字节的含义，应用层网络协议诞生</p></blockquote><ul><li>应用层：应用层网络协议规定消息发送方和接收方必须使用一个固定长度的一个消息头，消息头必须是固定组成，记录各种信息以方便接收方解析。该层旨在让你能够更方便的从网络中接受数据，没有该层也可以在两台主机间传递，但是我们能了解的就是一堆0101编码的字节数组。需要关注TCP/IP协议中的HTTP协议。</li></ul><p>这是一个框架来协调和组织各层所提供的服务，但是该模型仅是概念模型，来协调进程间通信标准的制定。实际的实现是TCP/IP协议。</p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p> TCP/IP 是 Internet上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。 </p><p><img src="/2019/11/22/ComputerNetworks/image-20191122201724700.png" alt="image-20191122201724700"></p><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><h3 id="传输控制协议-TCP-简介"><a href="#传输控制协议-TCP-简介" class="headerlink" title="传输控制协议 TCP 简介"></a>传输控制协议 TCP 简介</h3><ul><li>面向连接的、可靠的基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的 TCP 层</li><li>数据包都是由序号，对方收到则发送 ACK 确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><p>IP协议是无连接的协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求每条线可以同时满足许多不同计算机之间的通信需要。通过IP协议，消息或者其他数据会被分割为较小的包，并通过因特网在计算机之间传送，IP负责将每个包路由至他的目的地，但是IP协议未作任何事来确认数据包是否安全到达，所以他是不可靠的，需要他的上层协议来控制。传输控制协议TCP是传输层的协议。（简介）</p><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="/2019/11/22/ComputerNetworks/image-20191122204017097.png" alt="image-20191122204017097"></p><ul><li><strong>源端口、目的端口</strong> ：各2个字节，TCP/UDP都是不包含IP地址信息的，两者头部都会有端口号，这是在传输层范畴的知识。两个进程在计算机内部进行通信可以有：管道、内存共享、信号量和消息队列等方法。其中最唯一要求是唯一的表示对方进程，在本地进程中可以使用PID，但是在网络中的不同主机中使用便失效了，解决方式就是在传输层中使用协议端口号，已知在网络层中IP可以唯一标识一个主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样可以利用IP地址+协议+端口号这样的唯一标识去表示网络中的一个进程，这种方式也成为套接字。这样，虽然通信的重点是应用进程，但是我们只要把要传送的报文交到目的主机的某一个合适端口中，剩下的工作就由TCP来完成了。</li><li><strong>seq序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>ack确认号</strong> ：表示期望收到对方下一个报文的第一个字节的序号。例如B收到A发送的报文seq序号是301，全部数据是200字节，B正确收到从A发送的序号到500（301+200-1）的数据，所以B期望收到的A的下一个数据序号是501，于是，B在发送给A的确认报文中，会把ack确认号置为501。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li>连接标志（TCP Flags）：表示控制功能，下面是常见的连接标志。<ul><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=a1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li></ul></li><li><strong>窗口</strong> ：滑动窗口大小，告知发送端接收端的缓存大小（还有多少空间可以接收数据，因为接收方的数据缓存空间是有限的），以此控制发送端发送数据速率，从而达到流量控制。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>当应用程序希望通过TCP和另一个应用程序通信时，会发送一个通信请求，必须有一个确切地址，在双方握手后TCP将在两个程序间建立一个全双工的通信，将占据两个计算机的通信线路，直到双方关闭为止。（三次握手）</p><p><img src="/2019/11/22/ComputerNetworks/1566261217747.png" alt="1566261217747"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><img src="/2019/11/22/ComputerNetworks/1566261228418-1574427053238.png" alt="1566261228418"></p><h3 id="为什么要三次连接"><a href="#为什么要三次连接" class="headerlink" title="为什么要三次连接"></a>为什么要三次连接</h3><p>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><h3 id="关于建连接时SYN超时"><a href="#关于建连接时SYN超时" class="headerlink" title="关于建连接时SYN超时"></a>关于建连接时SYN超时</h3><p>试想一下，如果server端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的TCP会重发 SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p><h3 id="关于SYN-Flood攻击"><a href="#关于SYN-Flood攻击" class="headerlink" title="关于SYN Flood攻击"></a>关于SYN Flood攻击</h3><p>一些恶意的人就为此制造了SYN Flood攻击，给服务器发了一个SYN后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫 <strong>tcp_syncookies</strong> 的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p><p>请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择。</p><ul><li>第一个是：tcp_synack_retries 可以用他来减少重试次数；</li><li>第二个是：tcp_max_syn_backlog，可以增大SYN连接数；</li><li>第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了 ；</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍然未收到响应则中断连接</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>即断开连接时需要客户端和服务端总共发送4各数据包来确认断开连接。</p><p><img src="/2019/11/22/ComputerNetworks/1566261278901.png" alt="1566261278901"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>TCP连接是全双工的，服务端可以发送数据到客户端，客户端也可以发送数据到服务端，发送方和接收方都需要两次挥手才能关闭 。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><img src="/2019/11/22/ComputerNetworks/1566261373431.png" alt="1566261373431"></p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>前面我们说了 TCP 现在我们来认识一下 UDP。</p><h3 id="UPD-的特点"><a href="#UPD-的特点" class="headerlink" title="UPD 的特点"></a>UPD 的特点</h3><ul><li>面向非连接的</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有 8 个字节，额外开销较小</li><li>吞吐量只受限于数据生成率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或则合并</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h2 id="TCP-的滑动窗口"><a href="#TCP-的滑动窗口" class="headerlink" title="TCP 的滑动窗口"></a>TCP 的滑动窗口</h2><p>首先明确：</p><p>TCP滑动窗口分为接受窗口，发送窗口。</p><p>滑动窗口协议是<strong>传输层进行流控</strong>的一种措施，<strong>接收方通过通告发送方自己的窗口大小</strong>，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：</p><ul><li>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</li><li>二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理</li></ul><p><strong>重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。</strong></p><p>发送端窗口的第一个字节序号一定是ACK中期望收到的下一个字节序号，比如下图：</p><p><img src="/2019/11/22/ComputerNetworks/image-20191122205849513.png" alt="image-20191122205849513"></p><p>上图52 53 54 55 字节都是可以新发送的字节序。</p><p>接受端窗口的第一个字节序之前一定是已经完全接收的，后面窗口里面的数据都是希望接受的，窗口后面的数据都是不希望接受的。</p><p>TCP的滑动窗口分为接收窗口和发送窗口 不分析这两种窗口就讨论是不妥当的。 TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>主要特点如下：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持 B/S 及 C/S 模式。</li></ul><p>请求结构：</p><p><img src="/2019/11/22/ComputerNetworks/1566261538473.png" alt="1566261538473"></p><p>响应结构：</p><p><img src="/2019/11/22/ComputerNetworks/1566261644094.png" alt="1566261644094"></p><p>总结：http协议定义了web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端，http协议采用了请求响应模型，客户端向服务器发送一个请求报文，包含请求方法，url，协议版本，请求头部，请求数据；服务器以一个状态行作为响应，响应内容包括，协议版本，错误或成功信息，服务器信息，响应头部和响应数据。</p><ul><li>连接：客户端与web服务器的http端口建立一个TCP套接字连接</li><li>发送请求：即通过套接字客户端向web服务端发送一个文本的请求报文</li><li>响应：服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取</li><li>释放连接：keep-live长连接会保存一段时间，该时间内请求还会响应</li><li>客户端解析：首先解析状态行，查看表明请求是否成功的状态代码，解析响应头，响应头告知以下若干数据为数据信息，客户端按照格式解析数据，在浏览器窗口显示。</li></ul><p>URL输入后的流程？？？</p><ol><li>DNS解析：浏览器会根据url逐层查询DNS服务器缓存，解析url中的域名所对应的IP地址（DNS缓存从近到远为浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存），此时找到IP地址</li><li>TCP连接：找到IP地址后会根据IP地址和对应端口与服务器建立TCP连接（三次握手）</li><li>发送HTTP请求：浏览器会发起读取文件的http请求，</li><li>服务器处理请求并返回HTTP报文：服务器对浏览器请求响应，并把对应的带有http文本的http响应报文发送给浏览器</li><li>浏览器解析渲染页面：浏览器收到报文，解析渲染到浏览器</li><li>释放连接</li></ol><p>状态码</p><p><img src="/2019/11/22/ComputerNetworks/1566261699701.png" alt="1566261699701"></p><h3 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h3><p>从三个层面来解答：</p><ul><li>Http 报文层面：GET 将请求信息放在 URL中，POST 方法报文中</li><li>数据库层面：GET 符合幂等性和安全性，POST 不符合</li><li>其他层面：GET 可以被缓存、被存储（书签），而 POST 不行</li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p><strong>Cookie 简介：</strong></p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把 Cookie 回发给服务端</li><li>服务器接收到后，会解析 Cookie 生成与客户端相对的内容</li></ul><p><strong>Cookiet 的设置以及发送过程：</strong></p><p><img src="/2019/11/22/ComputerNetworks/image-20191122210015905.png" alt="image-20191122210015905"></p><p><strong>Session 简介：</strong></p><ul><li>服务端的机制，在服务端保存的信息</li><li>解析客户端请求并操作 Session id ，按需保存状态信息</li></ul><p><strong>Session 的实现方式：</strong></p><ul><li>使用 Cookie 来实现</li><li>使用 URL 回写来实现，每次在 URL 添加 Session id 信息</li></ul><p><strong>区别</strong>：</p><ul><li>Cookie 数据存放在客户端的浏览器上，Session 数据存放在服务器上</li><li>Session 相对于 Cookie 更安全</li><li>若考虑减轻服务器负担，应当使用 Cookie</li></ul><h3 id="HTTP-和-HTTPs-的区别"><a href="#HTTP-和-HTTPs-的区别" class="headerlink" title="HTTP 和 HTTPs 的区别"></a>HTTP 和 HTTPs 的区别</h3><p><img src="/2019/11/22/ComputerNetworks/image-20191122210051958.png" alt="image-20191122210051958"></p><h4 id="SSL-Security-Sockets-Layer-安全套接层"><a href="#SSL-Security-Sockets-Layer-安全套接层" class="headerlink" title="SSL (Security Sockets Layer) 安全套接层"></a>SSL (Security Sockets Layer) 安全套接层</h4><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的 API，SSL 3.0 更名为 TLS</li><li>采用身份验证和数据加密来保证网络的通信的安全和数据的完整性</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTPS 需要到 CA 申请证书，HTTP 不需要</li><li>HTTPS 密文传输，HTTP 明文传输</li><li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li><li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，较 HTTP 安全</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>唯一标识一个进程：本地中使用PID；</p><p>网络中进程：IP地址+协议+端口号来唯一标识一个网络中的一个进程；</p><p><img src="/2019/11/22/ComputerNetworks/1566261798658.png" alt="1566261798658"></p><p>socket通信流程</p><p><img src="/2019/11/22/ComputerNetworks/1566261805698.png" alt="1566261805698"></p><ul><li><input disabled type="checkbox"> Socket通信编程</li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="OSI与TCP-IP的协议"><a href="#OSI与TCP-IP的协议" class="headerlink" title="OSI与TCP/IP的协议"></a>OSI与TCP/IP的协议</h3><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/NwMQ9mez*i97f2u6JhqrOh14XAag318f8TuAngEDQ8w!/b/dL8AAAAAAAAA&bo=eQJYAXkCWAEDKQw!&rf=viewer_4" alt="五层体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.xn--comoracle-xj3h/" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/" target="_blank" rel="noopener">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h3 id="TCP、UDP-协议的区别"><a href="#TCP、UDP-协议的区别" class="headerlink" title="TCP、UDP 协议的区别"></a>TCP、UDP 协议的区别</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/8Mtws13i04*MNhxm7c6NUQukdKULAlH2ajFaBni3uZc!/b/dDQBAAAAAAAA&bo=YQPbAGED2wADGTw!&rf=viewer_4" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><h4 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h3 id="URL-到网页显示"><a href="#URL-到网页显示" class="headerlink" title="URL 到网页显示"></a>URL 到网页显示</h3><p>图解（图片来源：《图解HTTP》）：</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/krh8m5lpufZU6OX9enXcVdQrVltJTku3irYOENXzFxM!/b/dFMBAAAAAAAA&bo=1AI.AtQCPgIDKQw!&rf=viewer_4" alt="状态码"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="各种协议与HTTP协议"><a href="#各种协议与HTTP协议" class="headerlink" title="各种协议与HTTP协议"></a>各种协议与HTTP协议</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/08ikSdkksqhIeEzyW6wrL6*jbSfpvdT2Kr.BKbEOhO4!/b/dDMBAAAAAAAA&bo=SQOpBEkDqQQDSWw!&rf=viewer_4" alt="各种协议与HTTP协议之间的关系"></p><h3 id="HTTP长连接、短连接"><a href="#HTTP长连接、短连接" class="headerlink" title="HTTP长连接、短连接"></a>HTTP长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p><h3 id="HTTP状态保存机制"><a href="#HTTP状态保存机制" class="headerlink" title="HTTP状态保存机制"></a>HTTP状态保存机制</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><h3 id="Cookie、Session的解析"><a href="#Cookie、Session的解析" class="headerlink" title="Cookie、Session的解析"></a>Cookie、Session的解析</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h4 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span>: text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span>: yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span>: tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sample_page.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.example.org</span><br><span class="line"><span class="attribute">Cookie</span>: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="HTTP-1-0与HTTP-1-1"><a href="#HTTP-1-0与HTTP-1-1" class="headerlink" title="HTTP 1.0与HTTP 1.1"></a>HTTP 1.0与HTTP 1.1</h3><blockquote><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A</a>? 的一些内容。</p></blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/mkJaDOUBzk87ThnK15P3txuYPndh*ZE.fSG4NT7DD0c!/b/dL4AAAAAAAAA&bo=kALdAJAC3QADCSw!&rf=viewer_4" alt="img"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/zJyJco59whskn9W9AoddItbQ6kJgG.hSY470evBfB2A!/b/dL8AAAAAAAAA&bo=wAILAcACCwEDGTw!&rf=viewer_4" alt="img"></p><h3 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h3><ol><li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ol><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure><h4 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h4><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h3 id="HTTP请求的-7-个步骤"><a href="#HTTP请求的-7-个步骤" class="headerlink" title="HTTP请求的 7 个步骤"></a>HTTP请求的 7 个步骤</h3><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Java</title>
      <link href="/2019/11/22/%E5%89%91%E6%8C%87Java/"/>
      <url>/2019/11/22/%E5%89%91%E6%8C%87Java/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
