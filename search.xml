<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA PROMOTE</title>
      <link href="/2020/10/29/JAVA-PROMOTE/"/>
      <url>/2020/10/29/JAVA-PROMOTE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WORK-NOTE</title>
      <link href="/2020/10/14/WORK-NOTE/"/>
      <url>/2020/10/14/WORK-NOTE/</url>
      
        <content type="html"><![CDATA[<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>判空：</p><p>工具类Tools，<code>Tools.isEmpty(); Tools.isNotEmpty();</code>。适用于对象判空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((CharSequence)obj).length() == <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Collection)obj).isEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Map)obj).isEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Object[])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] object = (Object[])((Object[])obj);</span><br><span class="line">        <span class="keyword">if</span> (object.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; object.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isEmpty(object[i])) &#123;</span><br><span class="line">                    empty = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工具类CollectionUtils，<code>CollectionUtils.isEmpty(); CollectionUtils.isNotEmpty();</code>。适用于集合判空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> coll == <span class="keyword">null</span> || coll.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低级示范</span></span><br><span class="line"><span class="keyword">if</span>(list != <span class="keyword">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">    <span class="comment">// 这个里面取list中的值</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 做其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工具类EmptyCheckUtil，<code>EmptyCheckUtil.check(Object obj, boolean exclude, Sring... params); EmptyCheckUtil.checkAll();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Object bean, <span class="keyword">boolean</span> exclude, String... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(DefaultResultStatus.PARAM_NOT_EMPTY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class type = bean.getClass();</span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(type);</span><br><span class="line">        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">boolean</span> needCheck = exclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyDescriptors.length; ++i) &#123;</span><br><span class="line">            PropertyDescriptor descriptor = propertyDescriptors[i];</span><br><span class="line">            String propertyName = descriptor.getName();</span><br><span class="line">            Method readMethod = descriptor.getReadMethod();</span><br><span class="line">            Object result = readMethod.invoke(bean);</span><br><span class="line">            String[] var12 = params;</span><br><span class="line">            <span class="keyword">int</span> var13 = params.length;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; var13; ++var14) &#123;</span><br><span class="line">                String param = var12[var14];</span><br><span class="line">                <span class="keyword">if</span> (param.equals(propertyName)) &#123;</span><br><span class="line">                    needCheck = !exclude;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needCheck &amp;&amp; (result == <span class="keyword">null</span> || <span class="string">""</span>.equals(result))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServiceException(DefaultResultStatus.PARAM_NOT_EMPTY.getStatusCode(), propertyName + <span class="string">"不能为空！"</span>);</span><br><span class="line">                needCheck = exclude;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>字符串判空，标准写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(result == <span class="keyword">null</span> || <span class="string">""</span>.equals(result))&#123;</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>springboot注解</p><p>@Cacheable 缓存注解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RBAC-Project</title>
      <link href="/2020/09/08/RBAC-Project/"/>
      <url>/2020/09/08/RBAC-Project/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>基于SpringBoot框架</p></blockquote><a id="more"></a><p><img src="/2020/09/08/RBAC-Project/image-20200908214313302.png" alt="image-20200908214313302"></p><p><img src="/2020/09/08/RBAC-Project/image-20200908215102170.png" alt="image-20200908215102170"></p><p><img src="/2020/09/08/RBAC-Project/image-20200913204927410.png" alt="image-20200913204927410"></p><ul><li>null字段作为索引的时候会多占一个字节，并且在索引比较的时候更复杂，所以一般设置为NOT NULL，通常可用0，空字符串或者无含义字符作为占位。</li></ul><p><img src="/2020/09/08/RBAC-Project/image-20200913204955138.png" alt="image-20200913204955138"></p>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPC-Project</title>
      <link href="/2020/06/29/SPC-Project/"/>
      <url>/2020/06/29/SPC-Project/</url>
      
        <content type="html"><![CDATA[<blockquote><p>引言：Spring Cloud学习</p></blockquote><a id="more"></a><p><img src="/2020/06/29/SPC-Project/image-20200629223035429.png" alt="image-20200629223035429"></p>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-Notes</title>
      <link href="/2020/05/17/Git-Notes/"/>
      <url>/2020/05/17/Git-Notes/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>Git学习记录</p></blockquote><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>Git的记录<ul><li>git记录所有版本的存储</li><li>三棵树：工作区（你所用到的）、暂存区、git仓库（存放所有版本的数据）</li></ul></li><li>Git的工作流程<ul><li>工作目录的添加修改</li><li>需要进行版本管理的文件放入暂存区域</li><li>暂存区域文件提交到git仓库</li><li>git管理文件的三个状态<ul><li>已修改（modified）</li><li>已暂存（staged）</li><li>已提交（committed）</li></ul></li></ul></li></ul><hr><ul><li>Git操作<ul><li>将工作目录文件刚入git仓库：<ul><li>新建文件夹，命令提示符切换到该目录下</li><li><code>git init</code> 初始化仓库</li><li><code>git add 文件名</code></li><li><code>git commit -m &quot;注释&quot;</code></li></ul></li><li>查看状态<ul><li><code>git status</code></li></ul></li><li>回撤上次操作（谨慎操作）<ul><li><code>git checkout -- 文件名(可选)</code></li><li><code>git reset HEAD  文件名(可选)</code></li></ul></li><li>查看历史状态<ul><li><code>git log</code></li></ul></li></ul></li></ul><p><img src="https://img-blog.csdn.net/20181024154044989" alt="reset和checkout"></p><ul><li><p>reset 命令</p><ul><li><p>reset命令的选项</p><ul><li><p><code>git reset HEAD~</code></p><blockquote><p>移动HEAD的指向，将其指向上一个快照（版本），修改的第三棵树<br>将HEAD移动后指向的快照回滚到暂存区域，修改的第二棵树</p></blockquote></li><li><p><code>git reset --soft HEAD~</code></p><blockquote><p>移动HEAD的指向，将其指向上一个快照（相当于撤销上一次提交）</p></blockquote></li><li><p><code>git reset --hard HEAD~</code>（谨慎操作）</p><blockquote><p>移动HEAD的指向，将其指向上一个快照（状态），修改第一棵树<br>将HEAD移动后指向的快照回滚到暂存区域，修改第二棵树<br>将暂存区域文件还原到工作目录，修改第一棵树</p></blockquote></li></ul></li><li><p>reset命令总结</p><ul><li><code>--soft</code> 移动HEAD的指向，改变第三棵树仓库里面的内容</li><li>默认，是将快照回滚到暂存区域</li><li>将暂存区域内容还原到工作目录（谨慎操作）</li></ul></li><li><p>回滚到指定快照</p><blockquote><p>使用快照的特定哈希，即 <code>git log</code>中的每个操作对应的字符串</p></blockquote></li></ul></li></ul><p>图片解释：工作区完成 README.md(v1) <code>add</code>到暂存区，<code>commit</code>到仓库区，即上左，又完成LICENSE(v1)<code>add</code>和<code>commit</code>，即上中，最后修改完成LICENSE(v2)<code>add</code>和<code>commit</code>，即上右，最新HEAD指向最右；图下显示各时段三棵树状态。</p><p><img src="https://img-blog.csdn.net/20181025152702624" alt="在这里插入图片描述"></p><p>图片解释：执行<code>git reset HEAD~</code>，HEAD就会指向前一个快照（版本），即上中，该指令会将暂存区域内容返回为HEAD移动后指向的快照内容（即上一个版本内容），这是若查看<code>git status</code>则会显示原工作区修改并提交的LICENSE(v2)文件未被git追踪到（之前的<code>add</code>操作以往，文件在命令符中是红色的）</p><p><img src="https://img-blog.csdn.net/20181025152733500" alt="在这里插入图片描述"></p><p>图片解释：这是接着执行<code>git reset --hard HEAD~</code>操作，根据指令HEAD指向上左，且将HEAD移动后指向的快照回滚到暂存区域，且将暂存区域文件还原到工作目录，这里就会出现工作区内容被覆盖，即LICENSE(v2)文件消失。</p><p><img src="https://img-blog.csdn.net/20181025152842102" alt="在这里插入图片描述"></p><ul><li><code>git diff</code>命令<ul><li>会出现<code>diff --git a/filename  b/filename</code>，即对比工作区和暂存区文件差异</li><li><code>---</code>三个减号对应的是暂存区文件（未修改旧文件）</li><li><code>+++</code>三个加号对应工作区文件（修改后文件）</li><li>输入<code>h</code>可获取帮助</li><li>比较两个历史快照<ul><li><code>git diff id1 id2</code>一般写哈希序列的前5、6个值就行了</li></ul></li><li>比较当前工作区与仓库快照<ul><li><code>git diff id</code> 与仓库中某个版本对比</li><li><code>git diff HEAD</code> 与仓库中最新的版本对比</li></ul></li><li>比较暂存区与仓库快照<ul><li><code>git diff --cached</code> 暂存区与仓库中最新版本对比</li><li><code>git diff --cached id</code> 暂存区与仓库中指定版本对比<br>图片解释：<code>git diff</code> 的相关图示</li></ul></li></ul></li></ul><p><img src="https://img-blog.csdn.net/20181025152900485" alt="在这里插入图片描述"></p><p>修改最后一次提交</p><ul><li>状况一、版本<code>commit</code>到仓库后，发现忘记还有文件没有<code>add</code></li><li>状况二、版本<code>commit</code>后发现版本说明写的不够全面</li></ul><blockquote><p>处理方法：使用带 <code>--amend</code> 选项的 <code>commit</code> 提交命令，git 会“更正”最近一次提交（<code>git commit --amend</code> ,）</p></blockquote><p>删除文件</p><ul><li><code>git checkout -- filename</code>恢复误删文件</li><li><code>git rn filename</code>删除误传文件（错误<code>add</code>,<code>commit</code>到仓库的文件），该命令删除的只是工作区和暂存区的文件，也就是取消跟踪，在下次提交时不纳入版本管理，在仓库日志中还收有信息的，加上<code>git reset --soft HEAD~</code>命令后可完全消除记录。</li><li>当对暂存区文件，工作区修改后，想要进行删除，会有提示无法删除，使用<code>git rn -f filename</code> 会同时删除两个文件。</li><li>只想删除暂存区文件：<code>git rn --cached filename</code>可完成</li></ul><p>重命名文件</p><ul><li><code>git nv oldname newname</code>操作</li></ul><hr><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><ul><li><code>git branch 分支名</code> 创建分支</li><li><code>git checkout 分支名</code> 切换分支</li><li><code>git checkout -b feature</code>  创建并且换到分支feature</li><li><code>git log --decorate --oneline --graph --all</code> 图像化显示所有分支</li><li><code>git merge 分支名</code> 合并分支</li><li><code>git branch -d 分支名</code> 删除分支</li></ul><p><img src="https://img-blog.csdnimg.cn/20181026141738267.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20181026141953820.png" alt="在这里插入图片描述"></p><ul><li><p><code>checkout</code>指令的另一些操作</p><ul><li><p>匿名分支：<code>git checkout HEAD~</code> 当 <code>checkout</code> 后面接的不是一个分支名时，git会自动常见一个匿名分支，这个分支操作都一样，但是要合并到主分支后就会自动消失，即你可以当作是一个无成本的实验。</p></li><li><p>从历史快照（或者暂存区）中拷贝文件到工作目录：<code>git checkout HEAD~ 文件名</code>  命令会将上一个快照中的该文件复制到工作目录和暂存区；<code>git checkout 文件名</code>将会从暂存区恢复指定文件到工作目录。</p><blockquote><p>使用<code>git checkout -- 文件名</code>这样的写法是为了防止恢复文件出现和文件名重名的分支名让git无法分辨</p></blockquote></li><li><p>切换分支：上文所说，切换仓库中指针指向，并且将对应的内容覆盖暂存区和工作区。</p></li></ul></li><li><p><code>reset</code>和<code>checout</code>命令的区分</p><ul><li>对于恢复文件，两者都可以回复指定快照的指定文件，并且都不会改变HEAD指针的指向；区别是<code>reset</code>命令只能将文件恢复到暂存区域，<code>checkout</code>命令会同时覆盖暂存区和工作区，此时的<code>reset</code>命令使用<code>--soft/--hard</code>指令对文件无效，总的来，<code>reset</code>恢复文件要更安全点。</li><li>对于回复快照，<code>reset</code>命令是用来回到过去的，根据选项的不同，<code>reset</code>命令将移动HEAD指针（–soft）-&gt; 覆盖暂存区（默认）-&gt; 覆盖工作区（–hard）;<code>checkout</code>命令在分支上也会有类似的操作。区别在于<code>checkout</code>要更安全些，<code>checkout</code>在切换分支前都会检查当前工作状态，而<code>reset --hard</code> 会直接覆盖；另一个，<code>reset</code>命令移动HEAD指针时是在其所在分支上，而<code>checkout</code>会移动HEAD自身到另一个分支上。</li></ul></li></ul><hr><blockquote><p>后记：记录来自网易云课堂上的一篇git教程，附上网址<a href="https://study.163.com/course/courseMain.htm?courseId=1003109018" target="_blank" rel="noopener">有需要可移步</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-Common</title>
      <link href="/2020/05/09/Algorithm-Common/"/>
      <url>/2020/05/09/Algorithm-Common/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>常见题型</p></blockquote><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> common </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog-Notes</title>
      <link href="/2020/05/07/Blog-Notes/"/>
      <url>/2020/05/07/Blog-Notes/</url>
      
        <content type="html"><![CDATA[<p>引言</p><blockquote><p>他山之石记录</p></blockquote><a id="more"></a><h3 id="ArrayList元素删除"><a href="#ArrayList元素删除" class="headerlink" title="ArrayList元素删除"></a>ArrayList元素删除</h3><blockquote><p> 对JAVA集合进行遍历删除时务必要用迭代器</p></blockquote><p>正确方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line">        list.add(<span class="string">"e"</span>);</span><br><span class="line">        list.add(<span class="string">"f"</span>);</span><br><span class="line">        list.add(<span class="string">"g"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; itr = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">            String str = itr.next();</span><br><span class="line">            <span class="comment">// 删除字符 f</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">"f"</span>)) &#123;</span><br><span class="line">                itr.remove();</span><br><span class="line">                <span class="comment">// 错误示范</span></span><br><span class="line">                <span class="comment">// list.remove(str);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查下标索引是是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// ArrayList的修改次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取索引对应的元素值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 获取删除元素后，需要移动的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将元素进行移动拷贝</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 最后将多出的位置设置为空，这样说明是没有引用的对象了</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    <span class="comment">// 返回删除的旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList的删除方法，将指定位置元素删除，然后将当前位置后面的元素向前拷贝的方式移动。但是注意一点细节，modCount++这步操作，将ArrayList的修改次数加1。而后面遍历时发现是通过使用这个字段来判断，当前的集合类是否被并发修改。</p><p>使用Itr提供的remove方法，可以发现modCount的变化，所以是不需要考虑modCount修改次数不一致的问题。</p><p>一段在ArrayList循环中删除元素并返回的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;A&gt; <span class="title">getUserDebitCard</span><span class="params">(A cond)</span> </span>&#123;</span><br><span class="line">    List&lt;A&gt; list = userService.getCard(cond);</span><br><span class="line">    List&lt;A&gt; result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(list! = <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;A&gt;()&#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(A b1, A b2)</span> </span>&#123;  </span><br><span class="line">                <span class="comment">//按时间排序</span></span><br><span class="line">                <span class="keyword">if</span>(Integer.valueOf(b1.getAddTime()) &gt; Integer.valueOf(b2.getAddTime()))&#123;  </span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A bean = getA(cond);</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 将上次的卡放置在第一位</span></span><br><span class="line">            <span class="keyword">for</span> (A card1 : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (card1.getCardNum().equals(bean.getCardNum())) &#123;</span><br><span class="line">                    card1.setAs(<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//直接插入第一位即可</span></span><br><span class="line">                    result.add(<span class="number">0</span>, card1);    </span><br><span class="line">                    <span class="comment">// list.remove(i); //循环过程中删除元素是危险的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    card1.setAs(<span class="number">0</span>);</span><br><span class="line">                    result.add(card1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组转换为ArrayList"><a href="#数组转换为ArrayList" class="headerlink" title="数组转换为ArrayList"></a>数组转换为ArrayList</h3><p>最普遍也是被最多人接受的答案如下：</p><p><code>ArrayList&lt;Element&gt; arrayList = new ArrayList&lt;Element&gt;(Arrays.asList(array));</code></p><h3 id="缓存模式及缓存数据一致性"><a href="#缓存模式及缓存数据一致性" class="headerlink" title="缓存模式及缓存数据一致性"></a>缓存模式及缓存数据一致性</h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&mid=2651487214&idx=2&sn=4be4e3000ec24dcc51799f0acd2224a1&chksm=bd2517918a529e873b4e342535e42f06622536c900e6b8fd3c33316114449f7883d039d4e951&scene=0&xtrack=1&key=12bdf45cc650f772b76ba43b7e0f4f921c55dbbe2e29d5869d54b8d3a3cfc78a55ab90a1ffdd21630366ccafdebef3fd805c138307359a42831f747b80084f68bb459cdbf2e94907b43d5f3f731bbadd&ascene=1&uin=MjgyODAxODYxOA%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=AdCGOSdiUugXaIoDrr4jLEU%3D&pass_ticket=uzgAk7PVBOU4lNTEP4thYM2nCYKazpvP4DqWyTKPEAU3pFwfG5g0XQoBkUTk1kZG" target="_blank" rel="noopener">微信公账号文章连接</a></p></blockquote><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache-Aside"></a>Cache-Aside</h4><p>最常见的一种模式，是一种控制逻辑都实现在应用程序中的模式。缓存不和数据库直接进行交互，而是由应用程序来同时和缓存以及数据库打交道。</p><p><img src="/2020/05/07/Blog-Notes/image-20200514211021016.png" alt="image-20200514211021016"></p><p>读数据时：</p><ol><li>程序需要判断缓存中是否已经存在数据。</li><li>当缓存中已经存在数据(也就是缓存命中，cache hit)，则直接从缓存中返回数据</li><li>当缓存中不存在数据(也就是缓存未命中，cache miss)，则先从数据库里读取数据，并且存入缓存，然后返回数据</li></ol><p><img src="/2020/05/07/Blog-Notes/image-20200514211053053.png" alt="image-20200514211053053"></p><p>写数据时：</p><ol><li>更新数据库</li><li>删除缓存中对应的数据</li></ol><p>有线程安全的问题吗？有，试想一下有两个线程，线程A读，线程B写</p><ol><li>A读数据，由于未命中那么从数据库中取数据</li><li>B写数据库</li><li>B删除缓存</li><li>A由于网络延迟比较慢，将脏数据写入缓存</li></ol><p>但是这种情况可能性非常的小，需要同时满足很多条件，近乎不太可能发生，所以我们一般都采用这种写策略。另外可以对缓存中的数据设置合适的过期时间，即使发生的脏数据的情况，也不会发生很长时间。</p><p>应用场景：</p><p>应用于缓存不支持Read-Through/Write-Through的系统。</p><p>优点：</p><ul><li>缓存仅仅保存被请求的数据，属于懒加载模式(Lazy Loading)，和下文的Write-Through模式相比，避免了任何数据都被写入缓存造成缓存频繁的更新。</li></ul><p>缺点：</p><ul><li>当发生缓存未命中的情况时，则会比较慢，因为要经过三个步骤：查询缓存，从数据库读取，写入缓存。</li><li>复杂的逻辑都在应用程序中，如果实现微服务，多个微服务中会有重复的逻辑代码</li></ul><h4 id="Read-Through-Write-Through"><a href="#Read-Through-Write-Through" class="headerlink" title="Read-Through/Write-Through"></a>Read-Through/Write-Through</h4><p>这种模式中，应用程序将缓存作为主要的数据源，而数据库对于应用程序是透明的，更新数据库和从数据库的读取的任务都交给缓存来代理了，所以对于应用程序来说，简单很多。</p><p><strong>Read-Through</strong></p><p>由缓存配置一个读模块，它知道如何将数据库中的数据写入缓存。在数据被请求的时候，如果未命中，则将数据从数据库载入缓存。</p><p><img src="/2020/05/07/Blog-Notes/image-20200514211107621.png" alt="image-20200514211107621"></p><p><strong>Write-Through</strong></p><p>缓存配置一个写模块，它知道如何将数据写入数据库。当应用要写入数据时，缓存会先存储数据，并调用写模块将数据写入数据库。</p><p><img src="/2020/05/07/Blog-Notes/image-20200514211120085.png" alt="image-20200514211120085"></p><p>应用场景：</p><p>Read Through/Write Through适用于写入之后经常被读取的应用。</p><p>优点：</p><ul><li>缓存不存在脏数据</li><li>相比较Cache-Aside懒加载模式，读取速度更高，因为较少因为缓存未命中而从数据库中查找</li><li>应用程序的逻辑相对简单</li></ul><p>缺点：</p><ul><li>对于总是写入却很少被读取的应用，那么Write-Through会非常浪费性能，因为数据可能更改了很多次，却没有被读取，白白的每次都写入缓存造成写入延迟。</li></ul><p>除了Write-Through以外，我们还有另外的两种写模式可以和Read-Through一起来配合使用，分别是Write-Back和Write-Around。</p><h4 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write-Back"></a>Write-Back</h4><p>又叫做Write-Behind。和Write-Through写入的时机不同，Write-Back将缓存作为可靠的数据源，每次都只写入缓存，而写入数据库则采用异步的方式，比如当数据要被移除出缓存的时候再存储到数据库或者一段时间之后批量更新数据库。</p><p><strong>应用场景</strong></p><p>读写效率都非常好，写的时候因为异步存储到数据库，提升了写的效率，适用于读写密集的应用。</p><p><strong>优点</strong></p><ul><li>写入和读取数据都非常的快，因为都是从缓存中直接读取和写入。</li><li>对于数据库不可用的情况有一定的容忍度，即使数据库暂时不可用，系统也整体可用，当数据库之后恢复的时候，再将数据写入数据库。</li></ul><p><strong>缺点</strong></p><ul><li>有数据丢失的风险，如果缓存挂掉而数据没有及时写到数据库中，那么缓存中的有些数据将永久的丢失了</li></ul><h4 id="Write-Around"><a href="#Write-Around" class="headerlink" title="Write-Around"></a>Write-Around</h4><p>和Write-Through不同，更新的时候只写入数据库，不写入缓存，结合Read-Through或者Cache-Aside使用，只在缓存未命中的情况下写缓存。</p><p><strong>应用场景</strong></p><p>适合于只写入一次而很少被读取的应用。</p><p><strong>优点</strong></p><ul><li>相比较Write-Through写入的时候的效率较高，如果数据写入后很少被读取，缓存也不会被没用到的数据占满。</li></ul><p><strong>缺点</strong></p><ul><li>如果数据会写入多次，那么可能存在缓存和数据库不一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-ReflectionAnnotation</title>
      <link href="/2020/04/27/JAVA-ReflectionAnnotation/"/>
      <url>/2020/04/27/JAVA-ReflectionAnnotation/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java 反射和注解学习笔记</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>当程序有使用某个类时，如果该类还没有被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</p><ul><li><p>加载<br>就是指将<code>class</code>文件读入内存，并为之创建一个<code>Class</code>对象，任何类被使用时系统都会建立一个<code>Class</code>对象</p></li><li><p>连接<br>验证 是否有正确的内部结构，并和其他类协调一致<br>准备 负责为类的静态成员分配内存，并设置默认初始化值<br>解析 将类的二进制数据中的符号引用替换为直接引用</p></li><li><p>初始化</p><p>对类的静态变量，静态代码块执行初始化操作</p></li></ul><h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3><ul><li><p>创建类的实例</p></li><li><p>类的静态变量，或者为静态变量赋值</p></li><li><p>类的静态方法</p></li><li><p>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</p></li><li><p>初始化某个类的子类</p></li><li><p>直接使用<code>java.exe</code>命令来运行某个主类</p></li></ul><h3 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p>负责将<code>.class</code>文件加载到内在中，并为之生成对应的<code>Class</code>对象</p></li><li><p>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p></li></ul><h3 id="类加载器的组成"><a href="#类加载器的组成" class="headerlink" title="类加载器的组成"></a>类加载器的组成</h3><ul><li><p><code>Bootstrap ClassLoader</code> 根类加载器<br>也被称为引导类加载器，负责Java核心类的加载<br>比如<code>System</code>，<code>String</code>等。在 JDK 中 JRE 的 lib 目录下 rt.jar 文件中</p></li><li><p><code>Extension ClassLoader</code>扩展类加载器<br>负责 JRE 的扩展目录中 jar 包的加载。<br>在 JDK 中 JRE 的 lib 目录下 ext 目录</p></li><li><p><code>System ClassLoader</code>系统类加载器<br>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</p></li></ul><p>通过这些描述就可以知道我们常用的类，都是由谁来加载完成的。</p><p>到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?</p><p>这就是我们反射要研究的内容</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法。所以先要获取到每一个字节码文件对应的Class类型的对象。</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>阅读API的<code>Class</code>类得知，<code>Class</code> 没有公共构造方法。<code>Class</code> 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 <code>defineClass</code> 方法自动构造的</p><h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><p>类对象概念： 所有的类，都存在一个类对象，这个类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。</p><p>获取类对象有3种方式：</p><p>方式一：通过<code>Object</code>类中的<code>getObject()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure><p>方式二：通过 类名<code>.class</code> 获取到字节码文件对象（任意数据类型都具备一个<code>class</code>静态属性，看上去要比第一种方式简单）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><p>方式三：通过<code>Class</code>类中的方法（将类名作为字符串传递给<code>Class</code>类中的静态方法<code>forName</code>即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：第三种和前两种的区别</strong></p><p>前两种你必须明确Person类型</p><p>后面是指定这种类型的字符串就行(要包含包名)，这种扩展更强，我不需要知道你的类，我只提供字符串，按照配置文件加载就可以了</p><h4 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"空参数构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">"带有String的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"带有String，int的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        System.out.println(<span class="string">"带有String, int, String的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="comment">// 没有返回值没有参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有返回值没有参数的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有返回值，有参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有返回值，有参数的方法 name= "</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有返回值，没有参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有返回值，没有参数的方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有返回值，有参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"有返回值，有参数的方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"哈哈"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", address="</span> + address+ <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取构造方法"><a href="#反射获取构造方法" class="headerlink" title="反射获取构造方法"></a>反射获取构造方法</h3><p>在反射机制中，把类中的成员（构造方法、成员方法、成员变量）都封装成了对应的类进行表示。其中，构造方法使用类<code>Constructor</code>表示。可通过<code>Class</code>类中提供的方法获取构造方法：</p><ul><li><p>返回一个构造方法</p><ul><li><code>public Constructor getConstructor(Class... parameterTypes)</code> 获取<code>public</code>修饰, 指定参数类型所对应的构造方法</li><li><code>public Constructor getDeclaredConstructor(Class... parameterTypes)</code> 获取指定参数类型所对应的构造方法(包含私有的)</li></ul></li><li><p>返回多个构造方法</p><ul><li><code>public Constructor[] getConstructors()</code>获取所有的<code>public</code> 修饰的构造方法<code>public Constructor&lt;?&gt;[] getDeclaredConstructors()</code>获取所有的构造方法(包含私有的)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象 包名.类</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有构造方法</span></span><br><span class="line">        <span class="comment">// 只包括public</span></span><br><span class="line">        Constructor[] cons = c.getConstructors();</span><br><span class="line">        <span class="comment">// 即包括public也包括private</span></span><br><span class="line">        Constructor[] conss = c.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个构造方法</span></span><br><span class="line">        <span class="comment">// public Person() </span></span><br><span class="line">        Constructor con1 = c.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(con1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public Person(String name)</span></span><br><span class="line">        Constructor con2 = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(con2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// private Person(String name, int age)</span></span><br><span class="line">        Constructor con3 = c.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(con3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public Person(String name, int age, String address)</span></span><br><span class="line">        Constructor con4 = c.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(con4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取构造方法，创建对象"><a href="#反射获取构造方法，创建对象" class="headerlink" title="反射获取构造方法，创建对象"></a>反射获取构造方法，创建对象</h3><p>获取构造方法，步骤如下：</p><ul><li><p>获取到Class对象</p></li><li><p>获取指定的构造方法</p></li><li><p>通过构造方法类<code>Constructor</code>中的方法，创建对象<code>public T newInstance(Object... initargs)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定构造器</span></span><br><span class="line">        Constructor con =  c.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造方法中的Constructor的方法 创建对象</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">"cuzz"</span>, <span class="number">18</span>, <span class="string">"武汉"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);  <span class="comment">// Person [name=cuzz, age=18, address=武汉]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取成员变量"><a href="#反射获取成员变量" class="headerlink" title="反射获取成员变量"></a>反射获取成员变量</h3><p>在反射机制中，把类中的成员变量使用类Field表示。可通过Class类中提供的方法获取成员变量：</p><ul><li><p>返回一个成员变量</p><ul><li><code>public Field getField(String name)</code> 获取指定的<code>public</code>修饰的变量</li><li><code>public Field getDeclaredField(String name)</code> 获取指定的任意变量</li></ul></li><li><p>返回多个成员变量</p><ul><li><code>public Field[] getFields()</code> 获取所有<code>public</code> 修饰的变量<code>public Field[] getDeclaredFields()</code>获取所有的 变量 (包含私有)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取多个成员变量</span></span><br><span class="line">        Field[] fields = c.getFields();</span><br><span class="line">        Field[] fieldss =  c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个变量</span></span><br><span class="line">        <span class="comment">// public int age</span></span><br><span class="line">        Field ageField = c.getField(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(ageField);       <span class="comment">// public int cn.cuzz.Person.age</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// private String address</span></span><br><span class="line">        Field addressField = c.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line">        System.out.println(addressField);   <span class="comment">// private java.lang.String cn.cuzz.Person.address</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射创建对象进行赋值"><a href="#反射创建对象进行赋值" class="headerlink" title="反射创建对象进行赋值"></a>反射创建对象进行赋值</h3><p>获取成员变量，步骤如下：</p><ul><li><p>获取Class对象</p></li><li><p>获取构造方法</p></li><li><p>通过构造方法，创建对象</p></li><li><p>获取指定的成员变量（私有成员变量，通过setAccessible(boolean flag)方法暴力访问）</p></li><li><p>通过方法，给指定对象的指定成员变量赋值或者获取值<code>public void set(Object obj, Object value)</code>在指定对象obj中，将此 Field 对象表示的成员变量设置为指定的新值<code>public Object get(Object obj)</code>返回指定对象obj中，此 Field 对象表示的成员变量的值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法</span></span><br><span class="line">        Constructor con = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造方法 创建对象</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">"cuzz"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定成员变量</span></span><br><span class="line">        <span class="comment">// public String name</span></span><br><span class="line">        Field nameField = c.getField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// public int age</span></span><br><span class="line">        Field ageField = c.getField(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        nameField.set(obj, <span class="string">"Cuzz"</span>);</span><br><span class="line">        ageField.set(obj, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"name = "</span>+ nameField.get(obj)); <span class="comment">// name = Cuzz</span></span><br><span class="line">        System.out.println(<span class="string">"age = "</span>+ ageField.get(obj));   <span class="comment">// age = 23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射获取成员方法并使用"><a href="#反射获取成员方法并使用" class="headerlink" title="反射获取成员方法并使用"></a>反射获取成员方法并使用</h3><p>在反射机制中，把类中的成员方法使用类Method表示。可通过Class类中提供的方法获取成员方法：</p><ul><li><p>返回获取一个方法：</p><ul><li><code>public Method getMethod(String name, Class... parameterTypes)</code> 获取 public 修饰的方法</li><li><code>public Method getDeclaredMethod(String name, Class... parameterTypes)</code> 获取任意的方法，包含私有的</li></ul><p>参数1: name 要查找的方法名称； 参数2： parameterTypes 该方法的参数类型</p></li><li><p>返回获取多个方法：</p><ul><li><code>public Method[] getMethods()</code> 获取本类与父类中所有public 修饰的方法<code>public Method[] getDeclaredMethods()</code>获取本类中所有的方法(包含私有的)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取多个方法</span></span><br><span class="line">        Method[] methods = c.getMethods();</span><br><span class="line">        Method[] methodss = c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个方法：</span></span><br><span class="line">        <span class="comment">// public void method1()</span></span><br><span class="line">        Method method = c.getMethod(<span class="string">"method1"</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// public String method4(String name)&#123;</span></span><br><span class="line">        method = c.getMethod(<span class="string">"method4"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 私有方法</span></span><br><span class="line">        <span class="comment">// private void method5()</span></span><br><span class="line">        method = c.getDeclaredMethod(<span class="string">"method5"</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射，创建对象，调用指定的方法"><a href="#反射，创建对象，调用指定的方法" class="headerlink" title="反射，创建对象，调用指定的方法"></a>反射，创建对象，调用指定的方法</h3><p>获取成员方法，步骤如下：</p><ul><li><p>获取Class对象</p></li><li><p>获取构造方法</p></li><li><p>通过构造方法，创建对象</p></li><li><p>获取指定的方法</p></li><li><p>执行找到的方法(如果获取的是私有方法则要开启暴力访问<code>m5.setAccessible(true)</code>)，<code>public Object invoke(Object obj, Object... args)</code>执行指定对象obj中，当前Method对象所代表的方法，方法要传入的参数通过<code>args</code>指定</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定构造器</span></span><br><span class="line">        Constructor con =  c.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过构造方法中的Constructor的方法 创建对象</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">"cuzz"</span>, <span class="number">18</span>, <span class="string">"武汉"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定的方法</span></span><br><span class="line">        Method m4 = c.getMethod(<span class="string">"method4"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行找到的方法</span></span><br><span class="line">        Object result = m4.invoke(obj, <span class="string">"2018/03/19"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result); <span class="comment">// result = 哈哈2018/03/19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a>反射练习</h2><p>下面展示一下反射的利用场景。</p><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>思考，将已存在的<code>ArrayList</code>集合中添加一个字符串数据，如何实现呢？</p><p>程序编译后产生的<code>.class</code>文件中是没有泛型约束的，这种现象我们称为泛型的擦除。那么，我们可以通过反射技术，来完成向有泛型约束的集合中，添加任意类型的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, SecurityException </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">"cuzz"</span>);</span><br><span class="line"><span class="comment">// list.add(23);  报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射技术，实现添加任意类型的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到add()方法</span></span><br><span class="line">Method addMethod = c.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行add()方法</span></span><br><span class="line">addMethod.invoke(list, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list); <span class="comment">//[cuzz, 23]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射配置文件"><a href="#反射配置文件" class="headerlink" title="反射配置文件"></a>反射配置文件</h3><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>通过配置文件得到类名和要运行的方法名，用反射的操作类名得到对象和调用方法</p><p>实现步骤:</p><ul><li><p>准备配置文件,键值对</p></li><li><p>IO流读取配置文件 Reader</p></li><li><p>文件中的键值对存储到集合中 Properties<br>集合保存的键值对,就是类名和方法名</p></li><li><p>反射获取指定类的class文件对象</p></li><li><p>class文件对象,获取指定的方法</p></li><li><p>运行方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// IO流读取配置文件</span></span><br><span class="line">        FileReader r = <span class="keyword">new</span> FileReader(<span class="string">"config.properties"</span>);</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 调用集合方法load,传递流对象</span></span><br><span class="line">        pro.load(r);</span><br><span class="line">        r.close();</span><br><span class="line">        <span class="comment">// 通过键获取值</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line">        <span class="comment">// 反射获取指定类的class文件对象</span></span><br><span class="line">        Class c = Class.forName(className);</span><br><span class="line">        Object obj = c.newInstance();</span><br><span class="line">        <span class="comment">// 获取指定的方法名</span></span><br><span class="line">        Method method = c.getMethod(methodName);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># className=cn.cuzz.Student</span><br><span class="line"># methodName=study</span><br><span class="line">className=cn.cuzz.Teacher</span><br><span class="line">methodName=teach</span><br><span class="line"># className=cn.cuzz.Worker</span><br><span class="line"># methodName=work</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><ol><li>首先准备两个业务类，这两个业务类很简单，就是各自都有一个业务方法，分别打印不同的字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service1</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"业务方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>当需要从第一个业务方法切换到第二个业务方法的时候，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service1().doService1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//      new Service1().doService1();</span></span><br><span class="line">        <span class="keyword">new</span> Service2().doService2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用反射<br>使用反射方式，首先准备一个配置文件，叫做spring.txt，放在src目录下。 里面存放的是类的名称，和要调用的方法名。<br>在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。</li></ol><p>当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。</p><p>这也是Spring框架的最基本的原理，只是它做的更丰富，安全，健壮。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class=reflection.Service1</span><br><span class="line">method=doService1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从spring.txt中获取类名称和方法名称</span></span><br><span class="line">        File springConfigFile = <span class="keyword">new</span> File(<span class="string">"e:\\project\\j2se\\src\\spring.txt"</span>);</span><br><span class="line">        Properties springConfig= <span class="keyword">new</span> Properties();</span><br><span class="line">        springConfig.load(<span class="keyword">new</span> FileInputStream(springConfigFile));</span><br><span class="line">        String className = (String) springConfig.get(<span class="string">"class"</span>);</span><br><span class="line">        String methodName = (String) springConfig.get(<span class="string">"method"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//根据类名称获取类对象</span></span><br><span class="line">        Class clazz = Class.forName(className);</span><br><span class="line">        <span class="comment">//根据方法名称，获取方法对象</span></span><br><span class="line">        Method m = clazz.getMethod(methodName);</span><br><span class="line">        <span class="comment">//获取构造器</span></span><br><span class="line">        Constructor c = clazz.getConstructor();</span><br><span class="line">        <span class="comment">//根据构造器，实例化出对象</span></span><br><span class="line">        Object service = c.newInstance();</span><br><span class="line">        <span class="comment">//调用对象的指定方法</span></span><br><span class="line">        m.invoke(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>@Override 用在方法上，表示这个方法重写了父类的方法，如toString()。</p><p>@Deprecated 表示这个方法已经过期，不建议开发者使用。(暗示在将来某个不确定的版本，就有可能会取消掉)</p><p>@SuppressWarnings Suppress英文的意思是抑制的意思，这个注解的用处是忽略警告信息。<br>比如使用集合的时候，有时候为了偷懒，会不写泛型，像这样： <code>List heros = new ArrayList();</code>那么就会导致编译器出现警告，而加上<code>@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot; })</code>就对这些警告进行了抑制，即忽略掉这些警告信息。<br>@SuppressWarnings 有常见的值，分别对应如下意思<br>1.deprecation：使用了不赞成使用的类或方法时的警告(使用@Deprecated使得编译器产生的警告)；<br>2.unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告<br>3.fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;<br>4.path：在类路径、源文件路径等中有不存在的路径时的警告;<br>5.serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;<br>6.finally：任何 finally 子句不能正常完成时的警告;<br>7.rawtypes 泛型类型未指明<br>8.unused 引用定义了，但是没有被使用<br>9.all：关于以上所有情况的警告。</p><p>@SafeVarargs注解只能用在参数长度可变的方法或构造方法上，且方法必须声明为static或final，否则会出现编译错误。一个方法使用@SafeVarargs注解的前提是，开发人员必须确保这个方法的实现中对泛型类型参数的处理不会引发类型安全问题。</p><p>@FunctionalInterface这是Java1.8 新增的注解，用于约定函数式接口。<br>函数式接口概念： 如果接口中只有一个抽象方法（可以包含多个默认方法或多个static方法），该接口称为函数式接口。函数式接口其存在的意义，主要是配合Lambda 表达式 来使用。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解 meta annotation用于注解 自定义注解 的注解。元注解有这么几种：<br>@Target<br>@Retention<br>@Inherited<br>@Documented<br>@Repeatable (java1.8 新增)</p><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>可以选择的位置列表如下：</p><p>ElementType.TYPE：能修饰类、接口或枚举类型<br>ElementType.FIELD：能修饰成员变量<br>ElementType.METHOD：能修饰方法<br>ElementType.PARAMETER：能修饰参数<br>ElementType.CONSTRUCTOR：能修饰构造器<br>ElementType.LOCAL_VARIABLE：能修饰局部变量<br>ElementType.ANNOTATION_TYPE：能修饰注解<br>ElementType.PACKAGE：能修饰包</p><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>表示生命周期，可选的值有3个：</p><p><strong>RetentionPolicy.SOURCE：</strong> 注解只在源代码中存在，编译成class之后，就没了。@Override就是这种注解。<br><strong>RetentionPolicy.CLASS：</strong> 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了。@Retention的默认值，即当没有显式指定@Retention的时候，就会是这种类型。<br><strong>RetentionPolicy.RUNTIME：</strong> 注解在运行起来之后依然存在，程序可以通过反射获取这些信息。</p><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>表示该注解具有继承性。</p><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><p>文档注解</p><h5 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h5><p>表示注解在同一个位置可以使用多次。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindFiles</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Target</span>( METHOD)</span><br><span class="line">    <span class="meta">@Retention</span>( RetentionPolicy.RUNTIME )</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> FileTypes &#123;</span><br><span class="line">        FileType[] value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(  METHOD )</span><br><span class="line">    <span class="meta">@Retention</span>( RetentionPolicy.RUNTIME )</span><br><span class="line">    <span class="meta">@Repeatable</span>( FileTypes<span class="class">.<span class="keyword">class</span> )</span></span><br><span class="line"><span class="class">    <span class="title">public</span> @<span class="title">interface</span> <span class="title">FileType</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FileType</span>( <span class="string">".java"</span> )</span><br><span class="line">    <span class="meta">@FileType</span>( <span class="string">".html"</span> )</span><br><span class="line">    <span class="meta">@FileType</span>( <span class="string">".css"</span> )</span><br><span class="line">    <span class="meta">@FileType</span>( <span class="string">".js"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    FileType[] fileTypes= <span class="keyword">this</span>.getClass().getMethod(<span class="string">"work"</span>).getAnnotationsByType(FileType<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(<span class="string">"将从如下后缀名的文件中查找文件内容"</span>);</span><br><span class="line">    <span class="keyword">for</span> (FileType fileType : fileTypes) &#123;</span><br><span class="line">System.out.println(fileType.value());</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(<span class="string">"查找过程略。。。"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> FindFiles().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了紧凑起见，把注解作为内部类的形式放在一个文件里。</p><ol><li>注解FileTypes，其value()返回一个FileType数组</li><li>注解FileType，其@Repeatable的值采用FileTypes</li><li>运用注解：在work方法上重复使用多次@FileType注解</li><li>解析注解： 在work方法内，通过反射获取到本方法上的FileType类型的注解数组，然后遍历本数组</li></ol><h4 id="自定义注解-1"><a href="#自定义注解-1" class="headerlink" title="自定义注解"></a>自定义注解</h4><h4 id="示例一-1"><a href="#示例一-1" class="headerlink" title="示例一"></a>示例一</h4><p>将DBUtil这个类改造成为支持自定义注解的方式。 首先创建一个注解JDBCConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;METHOD,TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JDBCConfig &#123;</span><br><span class="line">    <span class="function">String <span class="title">ip</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">port</span><span class="params">()</span> <span class="keyword">default</span> 3306</span>;</span><br><span class="line">    <span class="function">String <span class="title">database</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">loginName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">password</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解方式DBUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> anno.JDBCConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JDBCConfig</span>(ip = <span class="string">"127.0.0.1"</span>, database = <span class="string">"test"</span>, encoding = <span class="string">"UTF-8"</span>, loginName = <span class="string">"root"</span>, password = <span class="string">"admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原DBUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">3306</span>;</span><br><span class="line">    <span class="keyword">static</span> String database = <span class="string">"test"</span>;</span><br><span class="line">    <span class="keyword">static</span> String encoding = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="keyword">static</span> String loginName = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> String password = <span class="string">"admin"</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String url = String.format(<span class="string">"jdbc:mysql://%s:%d/%s?characterEncoding=%s"</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析注解，接下来就通过反射，获取这个DBUtil这个类上的注解对象。拿到注解对象之后，通过其方法，获取各个注解元素的值，根据这些配置信息得到一个数据库连接Connection实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> anno.JDBCConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JDBCConfig</span>(ip = <span class="string">"127.0.0.1"</span>, database = <span class="string">"test"</span>, encoding = <span class="string">"UTF-8"</span>, loginName = <span class="string">"root"</span>, password = <span class="string">"admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">        JDBCConfig config = DBUtil<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">JDBCConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String ip = config.ip();</span><br><span class="line">        <span class="keyword">int</span> port = config.port();</span><br><span class="line">        String database = config.database();</span><br><span class="line">        String encoding = config.encoding();</span><br><span class="line">        String loginName = config.loginName();</span><br><span class="line">        String password = config.password();</span><br><span class="line"></span><br><span class="line">        String url = String.format(<span class="string">"jdbc:mysql://%s:%d/%s?characterEncoding=%s"</span>, ip, port, database, encoding);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException </span>&#123;</span><br><span class="line">        Connection c = getConnection();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h4><p>参考hibernate的注解配置方式，自定义5个注解，分别对应hibernate中用到的注解：<br>hibernate_annotation.MyEntity 对应 javax.persistence.Entity<br>hibernate_annotation.MyTable 对应 javax.persistence.Table<br>hibernate_annotation.MyId 对应 javax.persistence.Id<br>hibernate_annotation.MyGeneratedValue 对应 javax.persistence.GeneratedValue<br>hibernate_annotation.MyColumn 对应 javax.persistence.Column</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hibernate_annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyEntity &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyId &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyGeneratedValue &#123;</span><br><span class="line">    <span class="function">String <span class="title">strategy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyColumn &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyColumn;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyEntity;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyGeneratedValue;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyId;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyTable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyEntity</span></span><br><span class="line"><span class="meta">@MyTable</span>(name=<span class="string">"hero_"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> damage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> armor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyId</span></span><br><span class="line">    <span class="meta">@MyGeneratedValue</span>(strategy = <span class="string">"identity"</span>)</span><br><span class="line">    <span class="meta">@MyColumn</span>(<span class="string">"id_"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyColumn</span>(<span class="string">"name_"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyColumn</span>(<span class="string">"damage_"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDamage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDamage</span><span class="params">(<span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyColumn</span>(<span class="string">"armor_"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArmor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> armor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArmor</span><span class="params">(<span class="keyword">int</span> armor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.armor = armor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyColumn;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyEntity;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyGeneratedValue;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyId;</span><br><span class="line"><span class="keyword">import</span> hibernate_annotation.MyTable;</span><br><span class="line"><span class="keyword">import</span> pojo.Hero;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseHibernateAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Hero&gt; clazz = Hero<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        MyEntity myEntity = (MyEntity) clazz.getAnnotation(MyEntity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == myEntity) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hero类不是实体类"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Hero类是实体类"</span>);</span><br><span class="line">            MyTable myTable = (MyTable) clazz.getAnnotation(MyTable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            String tableName = myTable.name();</span><br><span class="line">            System.out.println(<span class="string">"其对应的表名是:"</span> + tableName);</span><br><span class="line">            Method[] methods =clazz.getMethods();</span><br><span class="line">            Method primaryKeyMethod = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Method m: methods) &#123;</span><br><span class="line">                MyId myId = m.getAnnotation(MyId<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != myId)&#123;</span><br><span class="line">                    primaryKeyMethod = m;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=primaryKeyMethod)&#123;</span><br><span class="line">                System.out.println(<span class="string">"找到主键："</span> + method2attribute( primaryKeyMethod.getName() ));</span><br><span class="line">                MyGeneratedValue myGeneratedValue =</span><br><span class="line">                    primaryKeyMethod.getAnnotation(MyGeneratedValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"其自增长策略是："</span> +myGeneratedValue.strategy());</span><br><span class="line">                MyColumn myColumn = primaryKeyMethod.getAnnotation(MyColumn<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                System.out.println(<span class="string">"对应数据库中的字段是："</span> +myColumn.value());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"其他非主键属性分别对应的数据库字段如下："</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method m: methods) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m==primaryKeyMethod)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                MyColumn myColumn = m.getAnnotation(MyColumn<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">//那些setter方法上是没有MyColumn注解的</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span>==myColumn)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                System.out.format(<span class="string">"属性： %s\t对应的数据库字段是:%s%n"</span>,method2attribute(m.getName()),myColumn.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">method2attribute</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        String result = methodName; ;</span><br><span class="line">        result = result.replaceFirst(<span class="string">"get"</span>, <span class="string">""</span>);</span><br><span class="line">        result = result.replaceFirst(<span class="string">"is"</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(result.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result.toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> result.substring(<span class="number">0</span>,<span class="number">1</span>).toLowerCase() + result.substring(<span class="number">1</span>,result.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路如下：</p><ol><li>首先获取Hero.class类对象</li><li>判断本类是否进行了MyEntity 注解</li><li>获取注解 MyTable</li><li>遍历所有的方法，如果某个方法有MyId注解，那么就记录为主键方法primaryKeyMethod</li><li>把主键方法的自增长策略注解MyGeneratedValue和对应的字段注解MyColumn 取出来，并打印</li><li>遍历所有非主键方法，并且有MyColumn注解的方法，打印属性名称和字段名称的对应关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Spring</title>
      <link href="/2020/04/24/JAVA-Spring/"/>
      <url>/2020/04/24/JAVA-Spring/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java Spring框架笔记</p></blockquote><a id="more"></a><p>先要看看反射&amp;注解的详细知识。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>家族图谱</p><p>第一阶段Spring Core、Spring Security、Spring Data，实现将单体应用开发服务好。不仅仅提供的便捷的数据库访问，web 中SpringMVC等必要功能。使用IOC、AOP实现应用低耦合、可扩展。</p><p><img src="/2020/04/24/JAVA-Spring/1567131737917.png" alt="1567131737917"></p><blockquote><p>利用工厂模式（DI）和代理模式（AOP）来解耦应用组件，然后实现了web应用的框架（SpringMVC）;</p></blockquote><p>第二阶段推出的SpringBoot不仅仅提高了开发效率，而且将程序由可用变为好用。</p><p><img src="/2020/04/24/JAVA-Spring/1567132198944.png" alt="1567132198944"></p><p>第三阶段的Spring Cloud，推动了微服务架构的落地</p><p><img src="/2020/04/24/JAVA-Spring/1567132290549.png" alt="1567132290549"></p><p>第四阶段：Spring Cloud DataFlow</p><p>DataFlow将实时消息的处理任务和临时运行的任务都作为组件处理，定义这样组件的交互。</p><p><img src="/2020/04/24/JAVA-Spring/1567132348627.png" alt="1567132348627"></p><h3 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/04/24/JAVA-Spring/1567132527700.png" alt="1567132527700"></p><p>IOC是一种思想，使我们从繁琐的对象交互中解脱出来，进而专注于对象本身，更进一步了解面向对对象。</p><p>一般的设计思路：</p><p><img src="/2020/04/24/JAVA-Spring/1567132665135.png" alt="1567132665135"></p><blockquote><p>先设计轮子，根据轮子设计底盘，根据底盘设计箱体…</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567132802864.png" alt="1567132802864"></p><blockquote><p>这里每个类的构造函数都直接调用了底层代码的构造函数，这样底层需求变动时会影响整个上层的代码，是不可取的。</p></blockquote><p>依赖注入的思路</p><p><img src="/2020/04/24/JAVA-Spring/1567133056969.png" alt="1567133056969"></p><p><img src="/2020/04/24/JAVA-Spring/1567133089064.png" alt="1567133089064"></p><p>其思想是<strong>反转资源获取的方向</strong>。传统的资源查找方式要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了 IOC 之后，则是<strong>容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源</strong>。这种行为也被称为查找的被动形式</p><p><img src="/2020/04/24/JAVA-Spring/1567133141092.png" alt="1567133141092"></p><p>DI（Dependency Injection）— IOC 的另一种表述方式：即<strong>组件以一些预先定义好的方式</strong>接受来自如容器的资源注入。</p><ul><li>set：实现特定属性的public set()方法，让IOC容器注入所依赖类型的对象</li><li>接口：实现特定接口，让IOC容器注入所依赖类型的对象</li><li>构造函数：实现特定参数的构造函数，实现在创建对象时让IOC容器注入所依赖类型的对象</li><li>注解：通过Java的注解机制，让IOC容器注入所依赖类型的对象</li></ul><h4 id="依赖倒置原则、IOC、DI、IOC容器"><a href="#依赖倒置原则、IOC、DI、IOC容器" class="headerlink" title="依赖倒置原则、IOC、DI、IOC容器"></a>依赖倒置原则、IOC、DI、IOC容器</h4><p><strong>什么是依赖倒置原则？</strong></p><p>假设我们设计行李箱：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计箱体，最后根据箱体设计好整个箱子。这里就出现了一个“依赖”关系：箱子依赖箱体，箱体依赖底盘，底盘依赖轮子。</p><p><img src="/2020/04/24/JAVA-Spring/1567133889794.png" alt="1567133889794"></p><p>上面的依赖关系是该原则所反对的，该原则的思想为高层模块不应该依赖与底层模块，两者都应该依赖于其抽象。</p><blockquote><p>依赖倒置原则思想的指导才有了IOC的思路，有了IOC的思路则需要DI方法的支撑。Spring框架基于IOC才提出了容器的概念，容器管理着Bean的生命周期，控制着Bean的依赖注入。</p></blockquote><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。这几种概念的关系大概如下：</p><p><img src="https://pic1.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt="img"></p><p>那什么是<strong>控制反转容器(IoC Container)</strong>呢？对行李箱类进行初始化的那段代码发生的地方，就是控制反转容器。</p><p><img src="/2020/04/24/JAVA-Spring/1567134047279.png" alt="1567134047279"></p><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<strong>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化行李箱都要亲手去写那一大段初始化的代码</strong>。这是引入IoC Container的第一个好处。</p><p><strong>IOC的优势：</strong></p><p><img src="/2020/04/24/JAVA-Spring/1567134582679.png" alt="1567134582679"></p><p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p><p><img src="/2020/04/24/JAVA-Spring/1567134623398.png" alt="1567134623398"></p><p>我们就像是工厂的客户。我们只需要向工厂请求一个Luggage实例，然后它就给我们按照Config创建了一个Luggage实例。我们完全不用管这个Luggage实例是怎么一步一步被创建出来。</p><h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>容器：Spring 提供了两种类型的 IOC 容器实现. </p><ul><li>BeanFactory：IOC 容器的基本实现。</li><li>ApplicationContext：提供了更多的高级特性。是 BeanFactory 的子接口（都用这个）</li></ul><p>实际Spring IOC容器是怎么实现对象的创建和依赖的：</p><p><img src="/2020/04/24/JAVA-Spring/1567135465808.png" alt="1567135465808"></p><p>1、Spring启动时读取应用程序提供的Bean配置信息，并在容器生成一份相应的Bean配置注册表</p><p>2、根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</p><blockquote><p>这里利用的是Java语言的反射功能实例化bean、并建立Bean之间的依赖关系</p></blockquote><p>3、将这些准备就绪的Bean放到Map缓存池中，为上层提供就绪的运行环境，等待应用程序执行调用</p><p><img src="/2020/04/24/JAVA-Spring/1567135556369.png" alt="1567135556369"></p><p><img src="/2020/04/24/JAVA-Spring/1567135577177.png" alt="1567135577177"></p><blockquote><p>Spring 作者设计这两个核心接口用以表示容器</p></blockquote><p>相关接口：</p><p><img src="/2020/04/24/JAVA-Spring/1567134859951.png" alt="1567134859951"></p><blockquote><p>Spring容器在启动时会将xml或者注解里的Bean的定义解析为Spring内部的BeanDefinition</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567134968136.png" alt="1567134968136"></p><blockquote><p>Spring 将Bean的定义解析为BeanDefinition后会通过BeanDefinitionRegistry 以BeanName为key，BeanDefinition为value存储到BeanDefinitionMap （这是个ConcurrentHashMap类型的map结构）中。</p></blockquote><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><h5 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h5><p><img src="/2020/04/24/JAVA-Spring/1567135018588.png" alt="1567135018588"></p><blockquote><p>包含Bean的各种定义，以便在接收客户端请求时可以实例化Bean，并在实例化对象时建立Bean 之间的依赖关系，这将使Bean从Bean客户端中解放出来。</p></blockquote><p>BeanFactory源码：</p><p><img src="/2020/04/24/JAVA-Spring/1567137963853.png" alt="1567137963853"></p><blockquote><p>各种getBean()方法，可以看到可以从Spring中按类型 / 按名称获取Bean</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567138042701.png" alt="1567138042701"></p><blockquote><p>判断是否为单例方法，SpringIOC中，默认Bean都是以单例存在的</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567138130281.png" alt="1567138130281"></p><blockquote><p>与上面相反，判断为多例的</p></blockquote><h5 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h5><p><img src="/2020/04/24/JAVA-Spring/1567138269117.png" alt="1567138269117"></p><p><img src="/2020/04/24/JAVA-Spring/1567138332244.png" alt="1567138332244"></p><blockquote><p>3表示可以管理message，4表示可以发布实事件给监听器，实现监听</p><p>可以看出这不单单是个工厂，是整个应用上下文，代表整个大容器的所有功能</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567138744314.png" alt="1567138744314"></p><blockquote><p>SpringBoot的自带启动类的run()方法，深入进去其最终会执行createApplicationContext()方法，会发现其会用Class.forName加载AnnotationConfigServleWebServerApplicationContext类。</p></blockquote><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a>案例一：</h5><p><strong>装载对象</strong></p><ol><li>建Category类</li><li>在src目录下新建applicationContext.xml文件<br>applicationContext.xml是Spring的核心配置文件，通过关键字c即可获取Category对象，该对象获取的时候，即被注入了字符串”category 1“到name属性中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"pojo.Category"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"category 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试<br>演示通过spring获取Category对象，以及该对象被注入的name属性。<br>可以打印出通过Spring拿到的Category对象的name属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">            <span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line"></span><br><span class="line">        Category c = (Category) context.getBean(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注入对象</strong></p><p>上文对Category的name属性注入了”category 1”字符串<br>下面对Product对象，注入一个Category对象</p><ol><li>Product类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对Category对象的setter getter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>applicationContext.xml 配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Product"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"product1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"category"</span> <span class="attr">ref</span>=<span class="string">"c"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例二：注解方式"><a href="#案例二：注解方式" class="headerlink" title="案例二：注解方式"></a>案例二：注解方式</h5><p>对<strong>注入对象行为</strong>的注解案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Category"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"category 1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.how2java.pojo.Product"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"product1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@Autowired</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> category; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123; <span class="keyword">this</span>.category = category; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对Bean进行注解</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.how2java.pojo"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"p"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"product 1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Category category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getCategory</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> category; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCategory</span><span class="params">(Category category)</span> </span>&#123; <span class="keyword">this</span>.category = category; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name=<span class="string">"category 1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2java.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123; <span class="string">"applicationContext.xml"</span> &#125;);</span><br><span class="line">        Product p = (Product) context.getBean(<span class="string">"p"</span>);</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">        System.out.println(p.getCategory().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Bean装载案例："><a href="#Bean装载案例：" class="headerlink" title="Bean装载案例："></a>Bean装载案例：</h5><p>Person Bean：</p><p><img src="/2020/04/24/JAVA-Spring/1567139561022.png" alt="1567139561022"></p><blockquote><p>扫描装配Bean，使用注解@Component（指定要扫描的类进入IOC容器中）@Value()是赋值</p></blockquote><p>启动类：</p><p><img src="/2020/04/24/JAVA-Spring/1567139336948.png" alt="1567139336948"></p><blockquote><p>@SpringBootApplication注解包含了启动扫描的功能。</p></blockquote><h5 id="Bean依赖注入案例："><a href="#Bean依赖注入案例：" class="headerlink" title="Bean依赖注入案例："></a>Bean依赖注入案例：</h5><p><img src="/2020/04/24/JAVA-Spring/1567139966763.png" alt="1567139966763"></p><blockquote><p>装载Dog 类进入IOC容器</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567139981229.png" alt="1567139981229"></p><blockquote><p>注入Pet（Pet是个接口），@Autowired会根据属性类型找到对应的Bean进行注入（最基本是用getBean()方法根据类型注入），这里的Dog类是Pet的一种实现，所以会根据类型查找到Dog，由SpringIOC容器将Dog的实例注入Person中。</p><p>当有多个Pet的实现时（例如还有Cat、Bird类），需要在要注入的类上加上@Primary注解。</p></blockquote><h4 id="getBean-解析"><a href="#getBean-解析" class="headerlink" title="getBean()解析"></a>getBean()解析</h4><p>会调用doGetBean()放法；</p><p><img src="/2020/04/24/JAVA-Spring/1567141357464.png" alt="1567141357464"></p><p><img src="/2020/04/24/JAVA-Spring/1567141421420.png" alt="1567141421420"></p><blockquote><p>1、先获取Bean名称beanName；2、获取一个（共享的）实例；3、试着从缓存或者实例工厂中获取实例；</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567141491889.png" alt="1567141491889"></p><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p><img src="/2020/04/24/JAVA-Spring/1567141574312.png" alt="1567141574312"></p><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p><img src="/2020/04/24/JAVA-Spring/1567141612844.png" alt="1567141612844"></p><blockquote><p>1、实例化Bean对象以及设置属性</p><p>2、 对 Aware 接口的实现，目的是在Bean中设置对IOC容器的感知</p><p>3、Bean的前置初始化方法，对Spring容器完成实例化的Bean添加自定义的处理逻辑</p><p>4、…   5、…</p><p>6、Bena的后置初始化方法，Bean实例初始化后的自定义工作，3、6和AOP相关</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567141729918.png" alt="1567141729918"></p><h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p><img src="/2020/04/24/JAVA-Spring/1567142579843.png" alt="1567142579843"></p><p>分类与合并（织入）</p><p><img src="/2020/04/24/JAVA-Spring/1567142610000.png" alt="1567142610000"></p><blockquote><p>Spring 采用的方式不需要特殊的Java编译器，但性能开销多一些</p></blockquote><p><img src="/2020/04/24/JAVA-Spring/1567143238161.png" alt="1567143238161"></p><p><img src="/2020/04/24/JAVA-Spring/1567143257267.png" alt="1567143257267"></p><p><img src="/2020/04/24/JAVA-Spring/1567143313889.png" alt="1567143313889"></p><p><img src="/2020/04/24/JAVA-Spring/1567143353134.png" alt="1567143353134"></p><p><img src="/2020/04/24/JAVA-Spring/1567144837023.png" alt="1567144837023"></p><h3 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h3><p>所谓静态代理，其实质是自己手写(或者用工具生成)代理类，也就是在程序运行前就已经存在的编译好的代理类。</p><ul><li>但是，如果我们需要很多的代理，每一个都这么去创建实属浪费时间，而且会有大量的重复代码，</li></ul><p><strong>动态代理可以在程序运行期间根据需要动态的创建代理类及其实例来完成具体的功能</strong>。</p><p>总的来说，<strong>根据代理类的创建时机和创建方式的不同，我们可以将代理分为静态代理和动态代理两种形式</strong>。</p><ul><li>代理对象存在的价值主要用于拦截对真实业务对象的访问；</li><li>代理对象应该具有和目标对象(真实业务对象)相同的方法，即实现共同的接口或继承于同一个类；</li><li>代理对象应该是目标对象的增强，否则我们就没有必要使用代理了。</li></ul><p>事实上，<strong>真正的业务功能还是由目标类来实现，代理类只是用于扩展、增强目标类的行为</strong>。例如，在项目开发中我们没有加入缓冲、日志这些功能而后期需要加入，我们就可以使用代理来实现，而没有必要去直接修改已经封装好的目标类。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案。</p><blockquote><p>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></blockquote><p>AOP机制是 Spring 所提供的核心功能之一，其既是Java动态代理机制的经典应用，也是动态AOP实现的代表。Spring AOP默认使用Java动态代理来创建AOP代理，具体通过以下几个步骤来完成：</p><ul><li><p>Spring IOC 容器创建Bean(目标类对象)；</p></li><li><p>Bean创建完成后，Bean后处理器(BeanPostProcessor)根据具体的切面逻辑及Bean本身使用Java动态代理技术生成代理对象；</p></li><li><p>应用程序使用上述生成的代理对象替代原对象来完成业务逻辑，从而达到增强处理的目的。</p></li></ul><blockquote><p>要实现动态代理必须要有接口的，<strong>动态代理是基于接口来代理的</strong>(实现接口的所有方法)，如果没有接口的话我们可以考虑cglib代理。cglib代理也叫子类代理，<strong>从内存中构建出一个子类来扩展目标对象的功能</strong>！</p></blockquote><h2 id="Spring-DAO模块"><a href="#Spring-DAO模块" class="headerlink" title="Spring DAO模块"></a>Spring DAO模块</h2><p><strong>Spring的DAO模块对JDBC的支持，以及Spring对事务的控制</strong>…</p><h3 id="回顾对模版代码优化过程"><a href="#回顾对模版代码优化过程" class="headerlink" title="回顾对模版代码优化过程"></a>回顾对模版代码优化过程</h3><p>我们来回忆一下我们怎么对模板代码进行优化的！</p><ul><li>首先来看一下我们<strong>原生的JDBC：需要手动去数据库的驱动从而拿到对应的连接</strong>..</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    <span class="comment">// 连接对象</span></span><br><span class="line">    con = DriverManager.getConnection(<span class="string">"jdbc:mysql:///hib_demo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    <span class="comment">// 执行命令对象</span></span><br><span class="line">    stmt =  con.createStatement();</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    stmt.execute(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为JDBC是面向接口编程的，因此数据库的驱动都是由数据库的厂商给做到好了，我们<strong>只要加载对应的数据库驱动，便可以获取对应的数据库连接</strong>….因此，我们<strong>写了一个工具类，专门来获取与数据库的连接(Connection)</strong>，当然啦，为了更加灵活，我们的<strong>工具类是读取配置文件的方式来做的</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 连接数据库的driver，url，username，password通过配置文件来配置，可以增加灵活性</span></span><br><span class="line"><span class="comment">    * 当我们需要切换数据库的时候，只需要在配置文件中改以上的信息即可</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  driver = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String  username = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取配置文件的读入流</span></span><br><span class="line">        InputStream inputStream = UtilsDemo.class.getClassLoader().getResourceAsStream("db.properties");</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取配置文件的信息</span></span><br><span class="line">        driver = properties.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">        url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">        username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line">        password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载驱动类</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(url,username,password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>经过上面一层的封装，我们可以<strong>在使用的地方直接使用工具类来得到与数据库的连接…那么比原来就方便很多了！</strong>但是呢，<strong>每次还是需要使用Connection去创建一个Statement对象。并且无论是什么方法，其实就是SQL语句和传递进来的参数不同！</strong></li><li>于是，我们就自定义了一个JDBC的工具类，详情可以看<a href="http://blog.csdn.net/hon_3y/article/details/53760782#t6" target="_blank" rel="noopener">http://blog.csdn.net/hon_3y/article/details/53760782#t6</a></li><li>我们自定义的工具类其实就是以DbUtils组件为模板来写的，因此我们在开发的时候就一直<strong>使用DbUtils组件了</strong>。</li></ul><hr><h3 id="使用Spring的JDBC"><a href="#使用Spring的JDBC" class="headerlink" title="使用Spring的JDBC"></a>使用Spring的JDBC</h3><p>上面已经回顾了一下以前我们的JDBC开发了，那么看看Spring对JDBC又是怎么优化的</p><p>首先，想要使用Spring的JDBC模块，就必须引入两个jar文件：</p><ul><li>引入jar文件<ul><li><strong>spring-jdbc-3.2.5.RELEASE.jar</strong></li><li><strong>spring-tx-3.2.5.RELEASE.jar</strong></li></ul></li><li>首先还是看一下我们原生的JDBC代码：<strong>获取Connection是可以抽取出来的，直接使用dataSource来得到Connection就行了</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">// 连接对象</span></span><br><span class="line">        con = DriverManager.getConnection(<span class="string">"jdbc:mysql:///hib_demo"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">// 执行命令对象</span></span><br><span class="line">        stmt =  con.createStatement();</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        stmt.execute(sql);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值得注意的是，<strong>JDBC对C3P0数据库连接池是有很好的支持的。因此我们直接可以使用Spring的依赖注入，在配置文件中配置dataSource就行了</strong>！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="jdbcUrl" value="jdbc:mysql:///hib_demo"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="user" value="root"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="password" value="root"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="initialPoolSize" value="3"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxPoolSize" value="10"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="maxStatements" value="100"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name="acquireIncrement" value="2"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    <span class="comment">// IOC容器注入</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String sql = <span class="string">"insert into t_dept(deptName) values('test');"</span>;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 连接对象</span></span><br><span class="line">        con = dataSource.getConnection();</span><br><span class="line">        <span class="comment">// 执行命令对象</span></span><br><span class="line">        stmt =  con.createStatement();</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        stmt.execute(sql);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Spring来提供了JdbcTemplate这么一个类给我们使用！它封装了DataSource，也就是说我们可以在Dao中使用JdbcTemplate就行了。</strong></li><li>创建dataSource，创建jdbcTemplate对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///zhongfucheng"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"bb"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 创建JdbcTemplate对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>userDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Spring的自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user(name,password) values('zhoggucheng','123')"</span>;</span><br><span class="line">        template.update(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">    UserDao userDao = (UserDao) ac.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000013751905?w=887&h=870" alt="这里写图片描述"></p><hr><h3 id="JdbcTemplate查询"><a href="#JdbcTemplate查询" class="headerlink" title="JdbcTemplate查询"></a>JdbcTemplate查询</h3><p>我们要是使用JdbcTemplate查询会发现<strong>有很多重载了query()方法</strong></p><p><img src="https://segmentfault.com/img/remote/1460000013751906?w=1097&h=620" alt="这里写图片描述"></p><p>一般地，<strong>如果我们使用queryForMap()，那么只能封装一行的数据，如果封装多行的数据、那么就会报错</strong>！并且，Spring是不知道我们想把一行数据封装成是什么样的，因此返回值是Map集合…我们得到Map集合的话还需要我们自己去转换成自己需要的类型。</p><hr><p>我们一般使用下面这个方法：</p><p><img src="https://segmentfault.com/img/remote/1460000013751907?w=980&h=583" alt="这里写图片描述"></p><p>我们可以<strong>实现RowMapper，告诉Spring我们将每行记录封装成怎么样的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from USER where password=?"</span>;</span><br><span class="line">    List&lt;User&gt; query = template.query(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">        <span class="comment">//将每行记录封装成User对象</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            user.setPassword(resultSet.getString(<span class="string">"password"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,id);</span><br><span class="line">    System.out.println(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000013751908" alt="这里写图片描述"></p><hr><p>当然了，一般我们都是<strong>将每行记录封装成一个JavaBean对象的，因此直接实现RowMapper，在使用的时候创建就好了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResult</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Dept</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 如何封装一行记录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dept <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Dept dept = <span class="keyword">new</span> Dept();</span><br><span class="line">        dept.setDeptId(rs.getInt(<span class="string">"deptId"</span>));</span><br><span class="line">        dept.setDeptName(rs.getString(<span class="string">"deptName"</span>));</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务控制概述"><a href="#事务控制概述" class="headerlink" title="事务控制概述"></a>事务控制概述</h3><p>下面主要讲解Spring的事务控制，如何使用Spring来对程序进行事务控制….</p><ul><li><strong>Spring的事务控制是属于Spring Dao模块的</strong>。</li></ul><p>一般地，我们<strong>事务控制都是在service层做的</strong>。。为什么是在service层而不是在dao层呢？？有没有这样的疑问…</p><p><strong>service层是业务逻辑层，service的方法一旦执行成功，那么说明该功能没有出错</strong>。</p><p>一个<strong>service方法可能要调用dao层的多个方法</strong>，如果在dao层做事务控制的话，一个dao方法出错了，仅仅把事务回滚到当前dao的功能，这样是不合适的[因为我们的业务由多个dao方法组成]。如果没有出错，调用完dao方法就commit了事务，这也是不合适的[导致太多的commit操作]。</p><p>事务控制分为两种：</p><ul><li><strong>编程式事务控制</strong></li><li><strong>声明式事务控制</strong></li></ul><h4 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h4><p><strong>自己手动控制事务，就叫做编程式事务控制。</strong></p><ul><li>Jdbc代码：<ul><li>Conn.setAutoCommite(false); // 设置手动控制事务</li></ul></li><li>Hibernate代码：<ul><li>Session.beginTransaction(); // 开启一个事务</li></ul></li><li><strong>【细粒度的事务控制： 可以对指定的方法、指定的方法的某几行添加事务控制】</strong></li><li><strong>(比较灵活，但开发起来比较繁琐： 每次都要开启、提交、回滚.)</strong></li></ul><h4 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h4><p><strong>Spring提供对事务的控制管理就叫做声明式事务控制</strong></p><p>Spring提供了对事务控制的实现。</p><ul><li>如果用户想要使用Spring的事务控制，<strong>只需要配置就行了</strong>。</li><li>当不用Spring事务的时候，直接移除就行了。</li><li>Spring的事务控制是<strong>基于AOP实现的</strong>。因此它的<strong>耦合度是非常低</strong>的。</li><li>【粗粒度的事务控制： <strong>只能给整个方法应用事务，不可以对方法的某几行应用事务。</strong>】<ul><li>(因为aop拦截的是方法。)</li></ul></li></ul><p><strong>Spring给我们提供了事务的管理器类</strong>，事务管理器类又分为两种，因为<strong>JDBC的事务和Hibernate的事务是不一样的</strong>。</p><ul><li>Spring声明式事务管理器类：<ul><li>Jdbc技术：DataSourceTransactionManager</li><li>Hibernate技术：HibernateTransactionManager</li></ul></li></ul><hr><h3 id="声明式事务控制-1"><a href="#声明式事务控制-1" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><p>我们基于Spring的JDBC来做例子吧</p><p>引入相关jar包</p><ul><li><strong>AOP相关的jar包【因为Spring的声明式事务控制是基于AOP的，那么就需要引入AOP的jar包。】</strong></li><li><strong>引入tx名称空间</strong></li><li><strong>引入AOP名称空间</strong></li><li><strong>引入jdbcjar包【jdbc.jar包和tx.jar包】</strong></li></ul><hr><h4 id="搭建配置环境"><a href="#搭建配置环境" class="headerlink" title="搭建配置环境"></a>搭建配置环境</h4><ul><li>编写一个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>UserDao实现类，使用JdbcTemplate对数据库进行操作！</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Spring的自动装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user(name,password) values('zhong','222')"</span>;</span><br><span class="line">        template.update(sql);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>userService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bean.xml配置：配置数据库连接池、jdbcTemplate对象、扫描注解</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据连接池配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///zhongfucheng"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"3"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"bb"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2. 创建JdbcTemplate对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>前面搭建环境的的时候，是没有任何的事务控制的。</p><p>也就是说，<strong>当我在service中调用两次userDao.save()，即时在中途中有异常抛出，还是可以在数据库插入一条记录的</strong>。</p><ul><li>Service代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">        UserService userService = (UserService) ac.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000013751909?w=1063&h=761" alt="这里写图片描述"></p><hr><h4 id="XML方式实现声明式事务控制"><a href="#XML方式实现声明式事务控制" class="headerlink" title="XML方式实现声明式事务控制"></a>XML方式实现声明式事务控制</h4><p><strong>首先，我们要配置事务的管理器类：因为JDBC和Hibernate的事务控制是不同的。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置事务的管理器类:JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManage"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再而，<strong>配置事务管理器类如何管理事务</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.配置如何管理事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManage"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有的方法，并不是只读--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，<strong>配置拦截哪些方法，</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.配置拦截哪些方法+事务的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* bb.UserService.*(..) )"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成之后，service中的方法都应该被Spring的声明式事务控制了。因此我们再次测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test33</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bb/bean.xml"</span>);</span><br><span class="line">    UserService userService = (UserService) ac.getBean(<span class="string">"userService"</span>);</span><br><span class="line">    userService.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000013751910?w=1051&h=783" alt="这里写图片描述"></p><hr><h4 id="使用注解的方法实现事务控制"><a href="#使用注解的方法实现事务控制" class="headerlink" title="使用注解的方法实现事务控制"></a>使用注解的方法实现事务控制</h4><p>当然了，有的人可能觉得到XML文件上配置太多东西了。<strong>Spring也提供了使用注解的方式来实现对事务控制</strong></p><p>第一步和XML的是一样的，<strong>必须配置事务管理器类：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.配置事务的管理器类:JDBC--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManage"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：开启以注解的方式来实现事务控制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启以注解的方式实现事务控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManage"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后，<strong>想要控制哪个方法事务，在其前面添加@Transactional这个注解就行了！</strong>如果想要控制整个类的事务，那么在类上面添加就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.save();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000013751911" alt="这里写图片描述"></p><hr><h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><p>其实我们<strong>在XML配置管理器类如何管理事务，就是在指定事务的属性！</strong>我们来看一下事务的属性有什么：</p><p><img src="https://segmentfault.com/img/remote/1460000013751912?w=899&h=444" alt="这里写图片描述"></p><p>对于事务的隔离级别，不清楚的朋友可参考之前的博文：<a href="http://blog.csdn.net/hon_3y/article/details/53760782" target="_blank" rel="noopener">http://blog.csdn.net/hon_3y/article/details/53760782</a></p><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>看了上面的事务属性，没有接触过的其实就这么一个：<code>propagation = Propagation.REQUIRED</code>事务的传播行为。</p><p>事务传播行为的属性有以下这么多个，常用的就只有两个：</p><ul><li>Propagation.REQUIRED【如果当前方法已经有事务了，<strong>加入当前方法事务</strong>】</li><li>Propagation.REQUIRED_NEW【如果当前方法有事务了，当前方法事务会挂起。<strong>始终开启一个新的事务</strong>，直到新的事务执行完、当前方法的事务才开始】</li></ul><p><img src="https://segmentfault.com/img/remote/1460000013751913?w=887&h=485" alt="这里写图片描述"></p><h4 id="当事务传播行为是Propagation-REQUIRED"><a href="#当事务传播行为是Propagation-REQUIRED" class="headerlink" title="当事务传播行为是Propagation.REQUIRED"></a>当事务传播行为是Propagation.REQUIRED</h4><ul><li><h4 id="现在有一个日志类，它的事务传播行为是Propagation-REQUIRED"><a href="#现在有一个日志类，它的事务传播行为是Propagation-REQUIRED" class="headerlink" title="现在有一个日志类，它的事务传播行为是Propagation.REQUIRED"></a><strong>现在有一个日志类，它的事务传播行为是Propagation.REQUIRED</strong></h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Log&#123;</span><br><span class="line">    Propagation.REQUIRED  </span><br><span class="line">        insertLog();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>现在，我要在保存之前记录日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Propagation.REQUIRED</span><br><span class="line">    <span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();   </span><br><span class="line">    saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>saveDept()本身就存在着一个事务，当调用insertLog()的时候，insertLog()的事务会加入到saveDept()事务中</strong></p><p>也就是说，<strong>saveDept()方法内始终是一个事务，如果在途中出现了异常，那么insertLog()的数据是会被回滚的【因为在同一事务内】</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();    <span class="comment">// 加入当前事务</span></span><br><span class="line">    .. 异常, 会回滚</span><br><span class="line">        saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="当事务传播行为是Propagation-REQUIRED-NEW"><a href="#当事务传播行为是Propagation-REQUIRED-NEW" class="headerlink" title="当事务传播行为是Propagation.REQUIRED_NEW"></a>当事务传播行为是Propagation.REQUIRED_NEW</h4><ul><li><strong>现在有一个日志类，它的事务传播行为是Propagation.REQUIRED_NEW</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Log&#123;</span><br><span class="line">    Propagation.REQUIRED  </span><br><span class="line">        insertLog();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>现在，我要在保存之前记录日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Propagation.REQUIRED</span><br><span class="line">    <span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();   </span><br><span class="line">    saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行到saveDept()中的insertLog()方法时，<strong>insertLog()方法发现 saveDept()已经存在事务了，insertLog()会独自新开一个事务，直到事务关闭之后，再执行下面的方法</strong></p><p><strong>如果在中途中抛出了异常，insertLog()是不会回滚的，因为它的事务是自己的，已经提交了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void  <span class="title">saveDept</span><span class="params">()</span></span>&#123;</span><br><span class="line">    insertLog();    <span class="comment">// 始终开启事务</span></span><br><span class="line">    .. 异常, 日志不会回滚</span><br><span class="line">        saveDept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-IOC总结"><a href="#Spring-IOC总结" class="headerlink" title="Spring IOC总结"></a>Spring IOC总结</h2><p>结合《Spring 实战 (第4版)》和《精通Spring4.x 企业应用开发实战》两本书的IOC章节将其知识点整理起来~</p><h3 id="IOC和DI概述"><a href="#IOC和DI概述" class="headerlink" title="IOC和DI概述"></a>IOC和DI概述</h3><p>在《精通Spring4.x 企业应用开发实战》中对IOC的定义是这样的：</p><blockquote><p>IoC(Inversion of Control)控制反转，包含了两个方面：一、控制。二、反转</p></blockquote><p>我们可以简单认为：</p><ul><li>控制指的是：<strong>当前对象对内部成员的控制权</strong>。</li><li>反转指的是：这种控制权<strong>不由当前对象管理</strong>了，由其他(类,第三方容器)来管理。</li></ul><blockquote><p>IOC不够开门见山，于是Martin Fowler提出了DI(dependency injection)来替代IoC，即让调用类对某一接口实现类的依赖关系由第三方(容器或协作类)注入，以移除调用类对某一接口实现类的依赖。</p></blockquote><p>在《Spring 实战 (第4版)》中并没有提及到IOC，而是直接来说DI的：</p><blockquote><p>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定，对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去</p></blockquote><p>从书上我们也可以发现：IoC和DI的定义(区别)并不是如此容易就可以说得清楚的了。这里我就<strong>简单摘抄</strong>一下：</p><ul><li>IoC(思想，设计模式)主要的实现方式有两种：依赖查找，<strong>依赖注入</strong>。</li><li>依赖注入是一种更可取的方式(实现的方式)</li></ul><p>对我们而言，其实也没必要分得那么清，混合一谈也不影响我们的理解…</p><p>再通过昨天写过的<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484243&idx=1&sn=972cbe6cdb578256e4d4771e7ca25de3&chksm=ebd74252dca0cb44419903758e8ca52d9ab287562f80be9365e305d6dcc2deaa45b40f9fd2e9#rd" target="_blank" rel="noopener">工厂模式理解了没有？</a>，我们现在就可以很清楚的发现，其实<strong>所谓的IOC容器就是一个大工厂</strong>【第三方容器】(Spring实现的功能很强大！比我们自己手写的工厂要好很多)。</p><p>使用IOC的好处(知乎@Intopass的回答)：</p><ol><li>不用自己组装，拿来就用。</li><li>享受单例的好处，效率高，不浪费空间。</li><li>便于单元测试，方便切换mock组件。</li><li>便于进行AOP操作，对于使用者是透明的。</li><li>统一配置，便于修改。</li></ol><p>参考资料：</p><ul><li><a href="https://www.zhihu.com/question/23277575--Spring" target="_blank" rel="noopener">https://www.zhihu.com/question/23277575--Spring</a> IoC有什么好处呢？</li></ul><h3 id="IOC容器的原理"><a href="#IOC容器的原理" class="headerlink" title="IOC容器的原理"></a>IOC容器的原理</h3><p>从上面就已经说了：IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系。</p><ul><li>原理就是通过Java的<strong>反射技术</strong>来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！</li><li>再通过配置文件(xml)或者注解来<strong>描述</strong>类与类之间的关系</li><li>我们就可以通过这些配置信息和反射技术来<strong>构建</strong>出对应的对象和依赖关系了！</li></ul><p>上面描述的技术只要学过点Java的都能说出来，这一下子可能就会被面试官问倒了，我们<strong>简单</strong>来看看实际Spring IOC容器是怎么实现对象的创建和依赖的：</p><p><img src="https://segmentfault.com/img/remote/1460000014979707" alt="img"></p><ol><li>根据Bean配置信息在容器内部创建Bean定义注册表</li><li>根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</li><li>将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用</li></ol><p>Spring容器(Bean工厂)可简单分成两种：</p><ul><li>BeanFactory<ul><li>这是最基础、面向Spring的</li></ul></li><li>ApplicationContext<ul><li>这是在BeanFactory基础之上，面向使用Spring框架的开发者。提供了一系列的功能！</li></ul></li></ul><p>几乎所有的应用场合<strong>都是</strong>使用ApplicationContext！</p><p>BeanFactory的继承体系：</p><p><img src="https://segmentfault.com/img/remote/1460000014979708" alt="img"></p><p>ApplicationContext的继承体系：</p><p><img src="https://segmentfault.com/img/remote/1460000014979710" alt="img"></p><p>其中在ApplicationContext子类中又有一个比较重要的：WebApplicationContext</p><ul><li>专门为Web应用准备的</li></ul><p><img src="https://segmentfault.com/img/remote/1460000014979711" alt="img"></p><p>Web应用与Spring融合：</p><p><img src="https://segmentfault.com/img/remote/1460000014979712" alt="img"></p><p>我们看看BeanFactory的生命周期：</p><p><img src="https://segmentfault.com/img/remote/1460000014979713" alt="img"></p><p>接下来我们再看看ApplicationContext的生命周期：</p><p><img src="https://segmentfault.com/img/remote/1460000014979714?w=874&h=758" alt="img"></p><p>初始化的过程都是比较长，我们可以<strong>分类</strong>来对其进行解析：</p><ul><li><strong>Bean自身的方法</strong>：如调用 Bean 构造函数实例化 Bean，调用 Setter 设置 Bean 的属性值以及通过<bean>的 init-method 和 destroy-method 所指定的方法；</bean></li><li><strong>Bean级生命周期接口方法</strong>：如 BeanNameAware、 BeanFactoryAware、 InitializingBean 和 DisposableBean，这些接口方法由 Bean 类直接实现；</li><li><strong>容器级生命周期接口方法</strong>：在上图中带“★” 的步骤是由 InstantiationAwareBean PostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“ <strong>后处理器</strong>” 。 后处理器接口一般不由 Bean 本身实现，它们独立于 Bean，实现类以容器附加装置的形式注册到Spring容器中并通过接口反射为Spring容器预先识别。当Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的。当然，用户可以通过合理地编写后处理器，让其仅对感兴趣Bean 进行加工处理</li></ul><p>ApplicationContext和BeanFactory<strong>不同之处</strong>在于：</p><ul><li>ApplicationContext会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、 InstantiationAwareBeanPostProcesso 和BeanFactoryPostProcessor<strong>后置器</strong>，并<strong>自动将它们注册到应用上</strong>下文中。而BeanFactory需要在代码中通过<strong>手工调用</strong><code>addBeanPostProcessor()</code>方法进行注册</li><li>ApplicationContext在<strong>初始化</strong>应用上下文的时候<strong>就实例化所有单实例的Bean</strong>。而BeanFactory在初始化容器的时候并未实例化Bean，<strong>直到</strong>第一次访问某个Bean时<strong>才</strong>实例化目标Bean。</li></ul><p>有了上面的知识点了，我们再来<strong>详细</strong>地看看Bean的初始化过程：</p><p><img src="https://segmentfault.com/img/remote/1460000014979715?w=883&h=588" alt="img"></p><p>简要总结：</p><ul><li>BeanDefinitionReader<strong>读取Resource所指向的配置文件资源</strong>，然后解析配置文件。配置文件中每一个<code>&lt;bean&gt;</code>解析成一个<strong>BeanDefinition对象</strong>，并<strong>保存</strong>到BeanDefinitionRegistry中；</li><li>容器扫描BeanDefinitionRegistry中的BeanDefinition；调用InstantiationStrategy<strong>进行Bean实例化的工作</strong>；使用<strong>BeanWrapper完成Bean属性的设置</strong>工作；</li><li>单例Bean缓存池：Spring 在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例 Bean 的<strong>缓存器</strong>，它是一个用HashMap实现的缓存器，单实例的Bean<strong>以beanName为键保存在这个HashMap</strong>中。</li></ul><h3 id="IOC容器装配Bean"><a href="#IOC容器装配Bean" class="headerlink" title="IOC容器装配Bean"></a>IOC容器装配Bean</h3><h4 id="装配Bean方式"><a href="#装配Bean方式" class="headerlink" title="装配Bean方式"></a>装配Bean方式</h4><p>Spring4.x开始IOC容器装配Bean有<strong>4种</strong>方式：</p><ul><li>XML配置</li><li>注解</li><li>JavaConfig</li><li>基于Groovy DSL配置(这种很少见)</li></ul><p>总的来说：我们以XML配置+注解来装配Bean得多，其中<strong>注解这种方式占大部分</strong>！</p><h4 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h4><p>依赖注入的方式有3种方式：</p><ul><li><strong>属性注入</strong>–&gt;通过<code>setter()</code>方法注入</li><li>构造函数注入</li><li>工厂方法注入</li></ul><p>总的来说使用<strong>属性注入</strong>是比较灵活和方便的，这是大多数人的选择！</p><h4 id="对象之间关系"><a href="#对象之间关系" class="headerlink" title="对象之间关系"></a>对象之间关系</h4><p><code>&lt;bean&gt;</code>对象之间有三种关系：</p><ul><li>依赖–&gt;挺少用的(使用depends-on就是依赖关系了–&gt;前置依赖【依赖的Bean需要初始化之后，当前Bean才会初始化】)</li><li>继承–&gt;可能会用到(指定abstract和parent来实现继承关系)</li><li>引用–&gt;最常见(使用ref就是引用关系了)</li></ul><h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><ul><li>单例Singleton</li><li>多例prototype</li><li>与Web应用环境相关的Bean作用域<ul><li>reqeust</li><li>session</li></ul></li></ul><p>使用到了Web应用环境相关的Bean作用域的话，是需要我们<strong>手动配置代理</strong>的~</p><p><img src="https://segmentfault.com/img/remote/1460000014979716?w=690&h=307" alt="img"></p><p>原因也很简单：因为我们默认的Bean是单例的，为了适配Web应用环境相关的Bean作用域—&gt;每个request都需要一个对象，此时我们<strong>返回一个代理对象</strong>出去就可以完成我们的需求了！</p><p><img src="https://segmentfault.com/img/remote/1460000014979717" alt="img"></p><hr><p>将Bean配置单例的时候还有一个问题：</p><ul><li>如果我们的Bean配置的是单例，而Bean对象里边的<strong>成员对象我们希望是多例的话</strong>。那怎么办呢？？</li><li>默认的情况下我们的Bean单例，返回的成员对象也默认是单例的(因为对象就只有那么一个)！</li></ul><p>此时我们需要用到了<code>lookup</code>方法注入，使用也很简单，看看例子就明白了：</p><p><img src="https://segmentfault.com/img/remote/1460000014979718?w=715&h=146" alt="img"></p><h4 id="处理自动装配的歧义性"><a href="#处理自动装配的歧义性" class="headerlink" title="处理自动装配的歧义性"></a>处理自动装配的歧义性</h4><p>昨天在刷书的时候刚好看到了有人在知乎邀请我回答这个问题：</p><p><img src="https://segmentfault.com/img/remote/1460000014979719" alt="img"></p><p>结合两本书的知识点，可以归纳成两种解决方案：</p><ul><li>使用<code>@Primary</code>注解设置为<strong>首选</strong>的注入Bean</li><li>使用<code>@Qualifier</code>注解设置<strong>特定名称的Bean</strong>来限定注入！<ul><li>也可以使用自定义的注解来标识</li></ul></li></ul><h4 id="引用属性文件以及Bean属性"><a href="#引用属性文件以及Bean属性" class="headerlink" title="引用属性文件以及Bean属性"></a>引用属性文件以及Bean属性</h4><p>之前在写配置文件的时候都是直接将我们的数据库配置信息在里面写死的了：</p><p><img src="https://segmentfault.com/img/remote/1460000014979720?w=1221&h=288" alt="img"></p><p>其实我们有<strong>更优雅的做法</strong>：将这些配置信息写到配置文件上(因为这些配置信息很可能是会变的，而且有可能被多个配置文件引用).</p><ul><li>如此一来，我们<strong>改的时候就十分方便</strong>了。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000014979721?w=1400&h=435" alt="img"></p><p>引用配置文件的数据使用的是<code>${}</code></p><p>除了引用配置文件上的数据，我们还可以<strong>引用Bean的属性</strong>：</p><p><img src="https://segmentfault.com/img/remote/1460000014979722?w=874&h=217" alt="img"></p><p><img src="https://segmentfault.com/img/remote/1460000014979723" alt="img"></p><p>引用Bean的属性使用的是<code>#{}</code></p><p>在这种技术在《Spring 实战 第四版》称之为Spring EL，跟我们之前学过的EL表达式是类似的。主要的功能就是上面的那种，想要更深入了解可参考下面的链接：</p><ul><li><a href="http://www.cnblogs.com/leiOOlei/p/3543222.html" target="_blank" rel="noopener">http://www.cnblogs.com/leiOOlei/p/3543222.html</a></li></ul><h4 id="组合配置文件"><a href="#组合配置文件" class="headerlink" title="组合配置文件"></a>组合配置文件</h4><p>xml文件之间组合：</p><p><img src="https://segmentfault.com/img/remote/1460000014979724?w=1091&h=396" alt="img"></p><p>xml和javaconfig互相组合的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.通过构造函数加载配置类</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConf<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过编码方式注册配置类</span></span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(DaoConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ctx.register(ServiceConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ctx.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过XML组装@Configuration配置类所提供的配置信息</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/conf/beans2.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.通过@Configuration组装XML配置所提供的配置信息</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(LogonAppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.@Configuration的配置类相互引用</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(DaoConfig<span class="class">.<span class="keyword">class</span>,<span class="title">ServiceConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    LogonService logonService = ctx.getBean(LogonService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println((logonService.getLogDao() !=<span class="keyword">null</span>));</span><br><span class="line">    logonService.printHelllo();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种的例子：</p><p><img src="https://segmentfault.com/img/remote/1460000014979725" alt="img"></p><p>第二种的例子：</p><p><img src="https://segmentfault.com/img/remote/1460000014979726?w=859&h=341" alt="img"></p><p><img src="https://segmentfault.com/img/remote/1460000014979727" alt="img"></p><p>第三种的例子：</p><p><img src="https://segmentfault.com/img/remote/1460000014979728?w=1159&h=308" alt="img"></p><p>第四种的例子：</p><p><img src="https://segmentfault.com/img/remote/1460000014979729" alt="img"></p><p>第五种的例子：</p><ul><li>代码由上可见</li></ul><h4 id="装配Bean总结"><a href="#装配Bean总结" class="headerlink" title="装配Bean总结"></a>装配Bean总结</h4><p>总的来说，Spring IOC容器就是在创建Bean的时候有很多的方式给了我们实现，其中也包括了很多关于Bean的配置~</p><p>对于Bean相关的注入教程代码和简化配置(p和c名称空间)我就不一一说明啦，你们去看<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483942&idx=1&sn=f71e1adeeaea3430dd989ef47cf9a0b3&chksm=ebd74327dca0ca3141c8636e95d41629843d2623d82be799cf72701fb02a665763140b480aec#rd" target="_blank" rel="noopener">Spring入门这一篇就够了</a>和<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483946&idx=1&sn=bb21dfd83cf51214b2789c9ae214410f&chksm=ebd7432bdca0ca3ded6ad9b50128d29267f1204bf5722e5a0501a1d38af995c1ee8e37ae27e7#rd" target="_blank" rel="noopener">Spring【依赖注入】就是这么简单</a>就行了。</p><p>总的对比图：</p><p><img src="https://segmentfault.com/img/remote/1460000014979730?w=720&h=159" alt="img"><br><img src="https://segmentfault.com/img/remote/1460000014979731" alt="img"></p><p>分别的应用场景：</p><p><img src="https://segmentfault.com/img/remote/1460000014979732?w=1061&h=316" alt="img"></p><p>至于一些小的知识点：</p><ul><li>方法替换<ul><li>使用某个Bean的方法替换成另一个Bean的方法</li></ul></li><li>属性编辑器<ul><li>Spring可以对基本类型做转换就归结于属性编辑器的功劳！</li></ul></li><li>国际化<ul><li>使用不同语言(英语、中文)的操作系统去显式不同的语言</li></ul></li><li>profile与条件化的Bean<ul><li>满足了某个条件才初始化Bean，这可以方便切换生产环境和开发环境~</li></ul></li><li>容器事件<ul><li>类似于我们的Servlet的监听器，只不过它是在Spring中实现了~</li></ul></li></ul><p>上面这些小知识点比较少情况会用到，这也不去讲解啦。知道有这么一回事，到时候查查就会用啦<del>~</del></p><p>参考资料：</p><ul><li>《Spring 实战》</li><li>《精通Spring4.x 企业应用开发实战》</li><li><a href="https://zhuanlan.zhihu.com/p/29344811--Spring" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29344811--Spring</a> IOC原理总结</li><li><a href="https://blog.csdn.net/u014079773/article/details/52453002---Java面试题集（七）--Spring常见面试问题" target="_blank" rel="noopener">https://blog.csdn.net/u014079773/article/details/52453002---Java面试题集（七）--Spring常见面试问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/31527327--69" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31527327--69</a> 个经典 Spring 面试题和答案</li></ul><h2 id="Spring-AOP总结"><a href="#Spring-AOP总结" class="headerlink" title="Spring AOP总结"></a>Spring AOP总结</h2><p>结合《Spring 实战 (第4版)》和《精通Spring4.x 企业应用开发实战》两本书的AOP章节将其知识点整理起来~</p><h3 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h3><p>AOP称为面向切面编程，那我们怎么理解面向切面编程？？</p><p>我们可以先看看下面这段代码：</p><p><img src="https://segmentfault.com/img/remote/1460000015018891?w=773&h=474" alt="img"></p><p>我们学Java面向对象的时候，如果代码重复了怎么办啊？？可以分成下面几个步骤：</p><ul><li>1：抽取成方法</li><li>2：抽取类</li></ul><p>抽取成类的方式我们称之为：<strong>纵向抽取</strong></p><ul><li>通过继承的方式实现纵向抽取</li></ul><p>但是，我们现在的办法不行：即使抽取成类还是会出现重复的代码，因为这些逻辑(开始、结束、提交事务)<strong>依附在我们业务类的方法逻辑中</strong>！</p><p><img src="https://segmentfault.com/img/remote/1460000015018892" alt="img"></p><p>现在纵向抽取的方式不行了，AOP的理念：就是将<strong>分散在各个业务逻辑代码中相同的代码通过横向切割的方式</strong>抽取到一个独立的模块中！</p><p><img src="https://segmentfault.com/img/remote/1460000015018893" alt="img"></p><p>上面的图也很清晰了，将重复性的逻辑代码横切出来其实很容易(我们简单可认为就是封装成一个类就好了)，但我们要将这些<strong>被我们横切出来的逻辑代码融合到业务逻辑中</strong>，来完成和之前(没抽取前)一样的功能！这就是AOP首要解决的问题了！</p><h3 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h3><blockquote><p>被我们横切出来的逻辑代码融合到业务逻辑中，来完成和之前(没抽取前)一样的功能</p></blockquote><p>没有学Spring AOP之前，我们就可以使用代理来完成。</p><ul><li>如果看过我写的<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1#rd" target="_blank" rel="noopener">给女朋友讲解什么是代理模式</a>这篇文章的话，一定就不难理解上面我说的那句话了</li><li>代理能干嘛？代理可以帮我们<strong>增强对象的行为</strong>！使用动态代理实质上就是<strong>调用时拦截对象方法，对方法进行改造、增强</strong>！</li></ul><p>其实Spring AOP的底层原理就是<strong>动态代理</strong>！</p><p>来源《精通Spring4.x 企业应用开发实战》一段话：</p><blockquote><p>Spring AOP使用纯Java实现，它不需要专门的编译过程，也不需要特殊的类装载器，它在<strong>运行期通过代理方式向目标类织入增强代码</strong>。在Spring中可以无缝地将Spring AOP、IoC和AspectJ整合在一起。</p></blockquote><p>来源《Spring 实战 (第4版)》一句话：</p><blockquote><p>Spring AOP构建在动态代理基础之上，因此，<strong>Spring对AOP的支持局限于方法拦截</strong>。</p></blockquote><p>在Java中动态代理有<strong>两种</strong>方式：</p><ul><li>JDK动态代理</li><li>CGLib动态代理</li></ul><p><img src="https://segmentfault.com/img/remote/1460000015018894?w=485&h=159" alt="img"></p><p>JDK动态代理是需要实现某个接口了，而我们类未必全部会有接口，于是CGLib代理就有了~~</p><ul><li>CGLib代理其生成的动态代理对象是目标类的子类</li><li>Spring AOP<strong>默认是使用JDK动态代理</strong>，如果代理的类<strong>没有接口则会使用CGLib代理</strong>。</li></ul><p>那么JDK代理和CGLib代理我们该用哪个呢？？在《精通Spring4.x 企业应用开发实战》给出了建议：</p><ul><li>如果是<strong>单例的我们最好使用CGLib代理</strong>，如果是多例的我们最好使用JDK代理</li></ul><p>原因：</p><ul><li>JDK在创建代理对象时的性能要高于CGLib代理，而生成代理对象的运行性能却比CGLib的低。</li><li>如果是单例的代理，推荐使用CGLib</li></ul><p>看到这里我们就应该知道什么是Spring AOP(面向切面编程)了：<strong>将相同逻辑的重复代码横向抽取出来，使用动态代理技术将这些重复代码织入到目标对象方法中，实现和原来一样的功能</strong>。</p><ul><li>这样一来，我们就在<strong>写业务时只关心业务代码</strong>，而不用关心与业务无关的代码</li></ul><h3 id="AOP的实现者"><a href="#AOP的实现者" class="headerlink" title="AOP的实现者"></a>AOP的实现者</h3><p>AOP除了有Spring AOP实现外，还有著名的AOP实现者：AspectJ，也有可能大家没听说过的实现者：JBoss AOP~~</p><p>我们下面来说说AspectJ扩展一下知识面：</p><blockquote><p>AspectJ是<strong>语言级别</strong>的AOP实现，扩展了Java语言，定义了AOP语法，能够在<strong>编译期</strong>提供横切代码的织入，所以它有<strong>专门的编译器</strong>用来生成遵守Java字节码规范的Class文件。</p></blockquote><p>而Spring借鉴了AspectJ很多非常有用的做法，<strong>融合了AspectJ实现AOP的功能</strong>。但Spring AOP本质上<strong>底层还是动态代理</strong>，所以Spring AOP是不需要有专门的编辑器的~</p><h3 id="AOP的术语"><a href="#AOP的术语" class="headerlink" title="AOP的术语"></a>AOP的术语</h3><p>嗯，AOP搞了好几个术语出来~~两本书都有讲解这些术语，我会尽量让大家看得明白的：</p><p><strong>连接点</strong>(Join point)：</p><ul><li><strong>能够被拦截的地方</strong>：Spring AOP是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点~</li></ul><p><strong>切点</strong>(Poincut)：</p><ul><li><strong>具体定位的连接点</strong>：上面也说了，每个方法都可以称之为连接点，我们<strong>具体定位到某一个方法就成为切点</strong>。</li></ul><p><strong>增强/通知</strong>(Advice)：</p><ul><li>表示添加到切点的一段<strong>逻辑代码</strong>，并定位连接点的<strong>方位信息</strong>。<ul><li>简单来说就定义了是干什么的，具体是在哪干</li><li>Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用！</li></ul></li></ul><p><strong>织入</strong>(Weaving)：</p><ul><li>将<code>增强/通知</code>添加到目标类的具体连接点上的过程。</li></ul><p><strong>引入/引介</strong>(Introduction)：</p><ul><li><code>引入/引介</code>允许我们<strong>向现有的类添加新方法或属性</strong>。是一种<strong>特殊</strong>的增强！</li></ul><p><strong>切面</strong>(Aspect)：</p><ul><li>切面由切点和<code>增强/通知</code>组成，它既包括了横切逻辑的定义、也包括了连接点的定义。</li></ul><p>在《Spring 实战 (第4版)》给出的总结是这样子的：</p><blockquote><p>通知/增强包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知/增强被应用的具体位置。其中关键的是切点定义了哪些连接点会得到通知/增强。</p></blockquote><p>总的来说：</p><ul><li>这些术语可能翻译过来不太好理解，但对我们正常使用AOP的话<strong>影响并没有那么大</strong>~~看多了就知道它是什么意思了。</li></ul><h3 id="Spring对AOP的支持"><a href="#Spring对AOP的支持" class="headerlink" title="Spring对AOP的支持"></a>Spring对AOP的支持</h3><p>Spring提供了3种类型的AOP支持：</p><ul><li>基于代理的经典SpringAOP<ul><li>需要实现接口，手动创建代理</li></ul></li><li>纯POJO切面<ul><li>使用XML配置，aop命名空间</li></ul></li><li><code>@AspectJ</code>注解驱动的切面<ul><li>使用注解的方式，这是最简洁和最方便的！</li></ul></li></ul><h3 id="基于注解和命名空的AOP编程"><a href="#基于注解和命名空的AOP编程" class="headerlink" title="基于注解和命名空的AOP编程"></a>基于注解和命名空的AOP编程</h3><p>Spring在新版本中对AOP功能进行了增强，体现在这么几个方面：</p><ul><li>在XML配置文件中为AOP提供了aop命名空间</li><li>增加了AspectJ切点表达式语言的支持</li><li>可以无缝地集成AspectJ</li></ul><p>那我们使用<code>@AspectJ</code>来玩AOP的话，学什么？？其实也就是上面的内容，学如何设置切点、创建切面、增强的内容是什么…</p><p><img src="https://segmentfault.com/img/remote/1460000015018903?w=815&h=774" alt="img"></p><p>具体的切点表达式使用还是前往：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483954&idx=1&sn=b34e385ed716edf6f58998ec329f9867&chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4#rd" target="_blank" rel="noopener">Spring【AOP模块】就这么简单</a>看吧~~</p><p>对应的增强注解：</p><p><img src="https://segmentfault.com/img/remote/1460000015018904?w=797&h=726" alt="img"></p><p><img src="https://segmentfault.com/img/remote/1460000015018905" alt="img"></p><h4 id="使用引介-引入功能实现为Bean引入新方法"><a href="#使用引介-引入功能实现为Bean引入新方法" class="headerlink" title="使用引介/引入功能实现为Bean引入新方法"></a>使用引介/引入功能实现为Bean引入新方法</h4><p>其实前置啊、后置啊这些很容易就理解了，整篇文章看下来就只有这个引介/引入切面有点搞头。于是我们就来玩玩吧~</p><p>我们来看一下具体的用法吧，现在我有个服务员的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向客人打招呼</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line">    <span class="comment">// 服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一位年轻服务员实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:greet to "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NeedTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"NaiveWaiter:serving "</span> + clientName + <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我想做的就是：<strong>想这个服务员可以充当售货员的角色，可以卖东西</strong>！当然了，我肯定不会加一个卖东西的方法到Waiter接口上啦，因为这个是暂时的~</p><p>所以，我搞了一个售货员接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖东西</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods, String clientName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个售货员实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartSeller</span> <span class="keyword">implements</span> <span class="title">Seller</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖东西</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sell</span><span class="params">(String goods,String clientName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SmartSeller: sell "</span>+goods +<span class="string">" to "</span>+clientName+<span class="string">"..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们的类图是这样子的：</p><p><img src="https://segmentfault.com/img/remote/1460000015018906?w=785&h=230" alt="img"></p><p>现在我想干的就是：<strong>借助AOP的引入/引介切面，来让我们的服务员也可以卖东西</strong>！</p><p>我们的引入/引介切面具体是这样干的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableSellerAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents</span>(value = <span class="string">"com.smart.NaiveWaiter"</span>,  <span class="comment">// 指定服务员具体的实现</span></span><br><span class="line">    defaultImpl = SmartSeller<span class="class">.<span class="keyword">class</span>) // 售货员具体的实现</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Seller</span> <span class="title">seller</span></span>; <span class="comment">// 要实现的目标接口 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写了这个切面类会发生什么？？</p><ul><li>切面技术将SmartSeller融合到NaiveWaiter中，这样<strong>NaiveWaiter就实现了Seller接口</strong>！！！！</li></ul><p>是不是很神奇？？我也觉得很神奇啊，我们来测试一下：</p><p>我们的<code>bean.xml</code>文件很简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"waiter"</span> <span class="attr">class</span>=<span class="string">"com.smart.NaiveWaiter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.smart.aspectj.basic.EnableSellerAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/smart/aspectj/basic/beans.xml"</span>);</span><br><span class="line">        Waiter waiter = (Waiter) ctx.getBean(<span class="string">"waiter"</span>);</span><br><span class="line">        <span class="comment">// 调用服务员原有的方法</span></span><br><span class="line">        waiter.greetTo(<span class="string">"Java3y"</span>);</span><br><span class="line">        waiter.serveTo(<span class="string">"Java3y"</span>);</span><br><span class="line">        <span class="comment">// 通过引介/引入切面已经将waiter服务员实现了Seller接口，所以可以强制转换</span></span><br><span class="line">        Seller seller = (Seller) waiter;</span><br><span class="line">        seller.sell(<span class="string">"水军"</span>, <span class="string">"Java3y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000015018907?w=508&h=93" alt="img"></p><p>具体的调用过程是这样子的：</p><blockquote><p>当引入接口方法被调用时，代理对象会把此调用委托给实现了新接口的某个其他对象。实际上，一个Bean的实现被拆分到多个类中</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000015018908?w=681&h=425" alt="img"></p><h4 id="在XML中声明切面"><a href="#在XML中声明切面" class="headerlink" title="在XML中声明切面"></a>在XML中声明切面</h4><p>我们知道注解很方便，<strong>但是</strong>，要想使用<strong>注解的方式</strong>使用Spring AOP就<strong>必须要有源码</strong>(因为我们要在切面类上添加注解)。如果没有源码的话，我们就得使用XML来声明切面了~</p><p>其实就跟注解差不多的功能：</p><p><img src="https://segmentfault.com/img/remote/1460000015018909" alt="img"></p><p>我们就直接来个例子终结掉它吧：</p><p>首先我们来测试一下与传统的SpringAOP结合的advisor是怎么用的：</p><p>实现类：</p><p><img src="https://segmentfault.com/img/remote/1460000015018910?w=966&h=293" alt="img"></p><p>xml配置文件：</p><p><img src="https://segmentfault.com/img/remote/1460000015018911?w=1371&h=154" alt="img"></p><p>…….</p><p>一个一个来讲解还是太花时间了，我就一次性用图的方式来讲啦：</p><p><img src="https://segmentfault.com/img/remote/1460000015018912" alt="img"></p><p>最后还有一个切面类型总结图，看完就几乎懂啦：</p><p><img src="https://segmentfault.com/img/remote/1460000015018913" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看起来AOP有很多很多的知识点，其实我们只要记住AOP的核心概念就行啦。</p><p>下面是我的简要总结AOP：</p><ul><li>AOP的底层实际上是动态代理，动态代理分成了JDK动态代理和CGLib动态代理。如果被代理对象没有接口，那么就使用的是CGLIB代理(也可以直接配置使用CBLib代理)</li><li>如果是单例的话，那我们最好使用CGLib代理，因为CGLib代理对象运行速度要比JDK的代理对象要快</li><li>AOP既然是基于动态代理的，那么它只能对方法进行拦截，它的层面上是方法级别的</li><li>无论经典的方式、注解方式还是XML配置方式使用Spring AOP的原理都是一样的，只不过形式变了而已。一般我们使用注解的方式使用AOP就好了。</li><li>注解的方式使用Spring AOP就了解几个切点表达式，几个增强/通知的注解就完事了，是不是贼简单…使用XML的方式和注解其实没有很大的区别，很快就可以上手啦。</li><li>引介/引入切面也算是一个比较亮的地方，可以用代理的方式为某个对象实现接口，从而能够使用借口下的方法。这种方式是非侵入式的~</li><li>要增强的方法还可以接收与被代理方法一样的参数、绑定被代理方法的返回值这些功能…</li></ul><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><ul><li>如果<strong>嵌套调用</strong>含有事务的方法，在Spring事务管理中，这属于哪个知识点？</li><li>我们使用的框架可能是<code>Hibernate/JPA</code>或者是<code>Mybatis</code>，都知道的底层是需要一个<code>session/connection</code>对象来帮我们执行操作的。要保证事务的完整性，我们需要多组数据库操作要使用<strong>同一个</strong><code>session/connection</code>对象，而我们又知道Spring IOC所管理的对象默认都是<strong>单例</strong>的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？</li><li>人家所说的BPP又是啥东西？</li><li>Spring事务管理重要接口有哪几个？</li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>阅读这篇文章的同学我<strong>默认</strong>大家都对Spring事务相关知识有一定的了解了。(ps:如果不了解点解具体的文章去阅读再回到这里来哦)</p><p>我们都知道，Spring事务是Spring AOP的最佳实践之一，所以说<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483954&idx=1&sn=b34e385ed716edf6f58998ec329f9867&chksm=ebd74333dca0ca257a77c02ab458300ef982adff3cf37eb6d8d2f985f11df5cc07ef17f659d4&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP入门基础知识(简单配置，使用)</a>是需要先知道的。如果想更加全面了解AOP可以看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484251&idx=1&sn=f792c5a1835af2c17f260be2055b5776&chksm=ebd7425adca0cb4cc3a4e2ee61bdfa99508ea564e4ba4fd4ed54054b12fed76694b2b3afc26e&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP重要知识点(术语介绍、全面使用)</a>。说到AOP就不能不说<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1&scene=21##wechat_redirect" target="_blank" rel="noopener">AOP底层原理：动态代理设计模式</a>。到这里，对AOP已经有一个基础的认识了。于是我们就可以<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483965&idx=1&sn=2cd6c1530e3f81ca5ad35335755ed287&chksm=ebd7433cdca0ca2a70cb8419306eb9b3ccaa45b524ddc5ea549bf88cf017d6e5c63c45f62c6e&scene=21##wechat_redirect" target="_blank" rel="noopener">使用XML/注解方式来配置Spring事务管理</a>。</p><p>在IOC学习中，可以知道的是<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484247&idx=1&sn=e228e29e344559e469ac3ecfa9715217&chksm=ebd74256dca0cb40059f3f627fc9450f916c1e1b39ba741842d91774f5bb7f518063e5acf5a0&scene=21##wechat_redirect" target="_blank" rel="noopener">Spring中Bean的生命周期(引出BPP对象)</a>并且<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484239&idx=1&sn=6560be96e456b513cb1e4f78a740a258&chksm=ebd7424edca0cb584906fb97679cf2ca557f430fbc87d2c86ce0652d2e3c36c2528466942df5&scene=21##wechat_redirect" target="_blank" rel="noopener">IOC所管理的对象默认都是单例的：单例设计模式</a>，单例对象如果有”<strong>状态</strong>“(有成员变量)，那么多线程访问这个单例对象，可能就造成线程不安全。那么<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484194&idx=1&sn=ed1241fcba5d3e85b6d900d8667f04f6&chksm=ebd74223dca0cb35fe16a267c88ac9e5159825b27c278fb165a8c50d681e1340b73cfd69ae0d&scene=21##wechat_redirect" target="_blank" rel="noopener">何为线程安全？</a>，解决线程安全有很多方式，但其中有一种：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484118&idx=1&sn=da3e4c4cfd0642687c5d7bcef543fe5b&chksm=ebd743d7dca0cac19a82c7b29b5b22c4b902e9e53bd785d066b625b4272af2a6598a0cc0f38e&scene=21##wechat_redirect" target="_blank" rel="noopener">让每一个线程都拥有自己的一个变量：ThreadLocal</a></p><h3 id="两个不靠谱直觉的例子"><a href="#两个不靠谱直觉的例子" class="headerlink" title="两个不靠谱直觉的例子"></a>两个不靠谱直觉的例子</h3><h4 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h4><p>之前朋友问了我一个例子：</p><p>在Service层抛出Exception，在Controller层捕获，那如果在Service中有异常，那会事务回滚吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service方法</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">    employeeRepository.save(employee);</span><br><span class="line">    <span class="comment">// 假设这里出了Exception</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Controller调用</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Employee employee = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        employee = employeeService.addEmployee();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我<strong>第一反应</strong>：不会回滚吧。</p><ul><li>我当时是这样想的：因为Service层已经抛出了异常，由Controller捕获。那是否回滚应该由Controller的catch代码块中逻辑来决定，如果catch代码块没有回滚，那应该是不会回滚。</li></ul><p>但朋友经过测试说，可以回滚阿。(pappapa打脸)</p><p><img src="https://segmentfault.com/img/remote/1460000018075072?w=1189&h=769" alt="发生了运行时Exception，Spring事务管理自动回滚"></p><p>看了一下文档，原来文档有说明：</p><blockquote><p>By default checked exceptions do not result in the transactional interceptor marking the transaction for rollback and instances of RuntimeException and its subclasses do</p></blockquote><p>结论：如果是编译时异常不会自动回滚，<strong>如果是运行时异常，那会自动回滚</strong>！</p><h4 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h4><blockquote><p>第二个例子来源于知乎@柳树文章，文末会给出相应的URL</p></blockquote><p>我们都知道，带有<code>@Transactional</code>注解所包围的方法就能被Spring事务管理起来，那如果我在<strong>当前类下使用一个没有事务的方法去调用一个有事务的方法</strong>，那我们这次调用会怎么样？是否会有事务呢？</p><p>用代码来描述一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有事务的方法去调用有事务的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee2Controller</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addEmployee();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    employeeRepository.deleteAll();</span><br><span class="line">    Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 模拟异常</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我第一直觉是：这跟Spring事务的传播机制有关吧。</p><p>其实这跟Spring事务的传播机制<strong>没有关系</strong>，下面我讲述一下：</p><ul><li>Spring事务管理用的是AOP，AOP底层用的是动态代理。所以如果我们在类或者方法上标注注解<code>@Transactional</code>，那么会生成一个<strong>代理对象</strong>。</li></ul><p>接下来我用图来说明一下：</p><p><img src="https://segmentfault.com/img/remote/1460000018075073?w=888&h=659" alt="Spring会自动生成代理对象"></p><p>显然地，我们拿到的是代理(Proxy)对象，调用<code>addEmployee2Controller()</code>方法，而<code>addEmployee2Controller()</code>方法的逻辑是<code>target.addEmployee()</code>，调用回原始对象(target)的<code>addEmployee()</code>。所以这次的调用<strong>压根就没有事务存在</strong>，更谈不上说Spring事务传播机制了。</p><p>原有的数据：</p><p><img src="https://segmentfault.com/img/remote/1460000018075074" alt="原有的数据"></p><p>测试结果：压根就没有事务的存在</p><p><img src="https://segmentfault.com/img/remote/1460000018075075" alt="没有事务的存在"></p><h5 id="再延伸一下"><a href="#再延伸一下" class="headerlink" title="再延伸一下"></a>再延伸一下</h5><p>从上面的测试我们可以发现：如果是在本类中没有事务的方法来调用标注注解<code>@Transactional</code>方法，最后的结论是没有事务的。那如果我将这个标注注解的方法<strong>移到</strong>别的Service对象上，有没有事务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        employeeRepository.deleteAll();</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="string">"3y"</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 模拟异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line">    <span class="comment">// 没有事务的方法去调用别的类有事务的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">addEmployee2Controller</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testService.addEmployee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://segmentfault.com/img/remote/1460000018075076?w=1300&h=799" alt="抛出了运行时异常，但我们的数据还是存在的！"></p><p>因为我们用的是代理对象(Proxy)去调用<code>addEmployee()</code>方法，那就当然有事务了。</p><h3 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h3><blockquote><p>如果<strong>嵌套调用</strong>含有事务的方法，在Spring事务管理中，这属于哪个知识点？</p></blockquote><p>在当前<strong>含有事务方法内部调用其他的方法</strong>(无论该方法是否含有事务)，这就属于Spring事务传播机制的知识点范畴了。</p><p>Spring事务基于Spring AOP，Spring AOP底层用的动态代理，动态代理有两种方式：</p><ul><li>基于接口代理(JDK代理)<ul><li>基于接口代理，凡是类的方法<strong>非public修饰</strong>，或者<strong>用了static关键字</strong>修饰，那这些方法都不能被Spring AOP增强</li></ul></li><li>基于CGLib代理(子类代理)<ul><li>基于子类代理，凡是类的方法<strong>使用了private、static、final修饰</strong>，那这些方法都不能被Spring AOP增强</li></ul></li></ul><p>值得说明的是：那些不能被Spring AOP增强的方法<strong>并不是不能</strong>在事务环境下工作了。只要它们<strong>被外层的事务方法调用了</strong>，由于Spring事务管理的传播级别，内部方法也可以<strong>工作</strong>在外部方法所启动的<strong>事务上下文中</strong>。</p><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><blockquote><p>我们使用的框架可能是<code>Hibernate/JPA</code>或者是<code>Mybatis</code>，都知道的底层是需要一个<code>session/connection</code>对象来帮我们执行操作的。要保证事务的完整性，我们需要<strong>多组数据库操作要使用同一个</strong><code>session/connection</code>对象，而我们又知道Spring IOC所管理的对象默认都是<strong>单例</strong>的，这为啥我们在使用的时候不会引发线程安全问题呢？内部Spring到底干了什么？</p></blockquote><p>回想一下当年我们学Mybaits的时候，是怎么编写<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247483937&idx=2&sn=28c7827639bb6ac0296746c4c4343c59&chksm=ebd74320dca0ca36b763b3975665fc38a7e921f9ecaef1aaea3a7c757063a29222cd00b3d3b6&scene=21##wechat_redirect" target="_blank" rel="noopener">Session工具类</a>？</p><p><img src="https://segmentfault.com/img/remote/1460000018075077" alt="Mybatis工具类部分代码截图"></p><p>没错，用的就是ThreadLocal，同样地，Spring也是用的ThreadLocal。</p><p>以下内容来源《精通 Spring4.x》</p><blockquote><p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、<strong>TransactionSynchronizationManager</strong>、LocaleContextHolder等）中非线程安全状态的“状态性对象”采用ThreadLocal封装，让它们也成为线程安全的“状态性对象”，因此，有状态的Bean就能够以singleton的方式在多线程中工作。</p></blockquote><p>我们可以试着点一下进去TransactionSynchronizationManager中看一下：</p><p><img src="https://segmentfault.com/img/remote/1460000018075078" alt="全都是ThreadLocal"></p><h3 id="啥是BPP？"><a href="#啥是BPP？" class="headerlink" title="啥是BPP？"></a>啥是BPP？</h3><p>BBP的全称叫做：BeanPostProcessor，一般我们俗称<strong>对象后处理器</strong></p><ul><li>简单来说，通过BeanPostProcessor可以对我们的对象进行“<strong>加工处理</strong>”。</li></ul><p>Spring管理Bean(或者说Bean的生命周期)也是一个<strong>常考</strong>的知识点，我在秋招也<strong>重新</strong>整理了一下步骤，因为比较重要，所以还是在这里贴一下吧：</p><ol><li>ResouceLoader加载配置信息</li><li>BeanDefintionReader解析配置信息，生成一个一个的BeanDefintion</li><li>BeanDefintion由BeanDefintionRegistry管理起来</li><li>BeanFactoryPostProcessor对配置信息进行加工(也就是处理配置的信息，一般通过PropertyPlaceholderConfigurer来实现)</li><li>实例化Bean</li><li>如果该Bean<code>配置/实现</code>了InstantiationAwareBean，则调用对应的方法</li><li>使用BeanWarpper来完成对象之间的属性配置(依赖)</li><li>如果该Bean<code>配置/实现了</code>Aware接口，则调用对应的方法</li><li>如果该Bean配置了BeanPostProcessor的before方法，则调用</li><li>如果该Bean配置了<code>init-method</code>或者实现InstantiationBean，则调用对应的方法</li><li>如果该Bean配置了BeanPostProcessor的after方法，则调用</li><li>将对象放入到HashMap中</li><li>最后如果配置了destroy或者DisposableBean的方法，则执行销毁操作</li></ol><p><img src="https://segmentfault.com/img/remote/1460000018075079?w=1052&h=852" alt="Application中Bean的声明周期"></p><p>其中也有关于BPP图片：</p><p><img src="https://segmentfault.com/img/remote/1460000018075080" alt="BBP所在的位置"></p><h4 id="为什么特意讲BPP？"><a href="#为什么特意讲BPP？" class="headerlink" title="为什么特意讲BPP？"></a>为什么特意讲BPP？</h4><p>Spring AOP编程底层通过的是动态代理技术，在调用的时候肯定用的是<strong>代理对象</strong>。那么Spring是怎么做的呢？</p><blockquote><p>我只需要写一个BPP，在postProcessBeforeInitialization或者postProcessAfterInitialization方法中，对对象进行判断，看他需不需要织入切面逻辑，如果需要，那我就根据这个对象，生成一个代理对象，然后返回这个代理对象，那么最终注入容器的，自然就是代理对象了。</p></blockquote><p>Spring提供了BeanPostProcessor，就是让我们可以对有需要的对象进行“<strong>加工处理</strong>”啊！</p><h3 id="认识Spring事务几个重要的接口"><a href="#认识Spring事务几个重要的接口" class="headerlink" title="认识Spring事务几个重要的接口"></a>认识Spring事务几个重要的接口</h3><p>Spring事务可以分为两种：</p><ul><li>编程式事务(通过代码的方式来实现事务)</li><li>声明式事务(通过配置的方式来实现事务)</li></ul><p>编程式事务在Spring实现相对简单一些，而声明式事务因为封装了大量的东西(一般我们使用简单，里头都非常复杂)，所以声明式事务实现要难得多。</p><p>在编程式事务中有以下几个重要的了接口：</p><ul><li>TransactionDefinition：定义了Spring兼容的<strong>事务属性</strong>(比如事务隔离级别、事务传播、事务超时、是否只读状态)</li><li>TransactionStatus：代表了事务的具体<strong>运行状态</strong>(获取事务运行状态的信息，也可以通过该接口<strong>间接</strong>回滚事务等操作)</li><li>PlatformTransactionManager：事务管理器接口(定义了一组行为，具体实现交由不同的持久化框架来完成—<strong>类比</strong>JDBC)</li></ul><p><img src="https://segmentfault.com/img/remote/1460000018075081?w=1498&h=796" alt="PlatformTransactionManager解析"></p><p>在声明式事务中，除了TransactionStatus和PlatformTransactionManager接口，还有几个重要的接口：</p><ul><li>TransactionProxyFactoryBean：生成代理对象</li><li>TransactionInterceptor：实现对象的拦截</li><li>TransactionAttrubute：事务配置的数据</li></ul><p>参考资料：</p><ul><li>那些年，我们一起追的Spring<ul><li><a href="https://zhuanlan.zhihu.com/p/41961670" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41961670</a></li></ul></li><li>《精通Spring 4.x 企业应用开发实战》</li><li>《Spring技术内幕》</li></ul><h2 id="Spring-与设计模式"><a href="#Spring-与设计模式" class="headerlink" title="Spring 与设计模式"></a>Spring 与设计模式</h2><p><strong>IoC(Inversion of Control,控制翻转)</strong>是Spring中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring中的IOC容器)实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p><p><strong>Spring IOC容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong>IOC容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p><blockquote><p>在实际项目中一个Service类如果有几百甚至上千个类作为它的底层，我们需要实例化这个Service，你可能要每次都要搞清这个Service所有底层类的构造函数，这可能会把人逼疯。如果利用IOC的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC的理解，推荐看这一下<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">知乎的一个回答</a>，非常不错。</p></blockquote><p><strong>控制翻转怎么理解呢?</strong>举个例子：”对象a依赖了对象b，当对象a需要使用对象b的时候必须自己去创建。但是当系统引入了IOC容器后，对象a和对象b之前就失去了直接的联系。这个时候，当对象a需要使用对象b的时候，我们可以指定IOC容器去创建一个对象b注入到对象a中”。对象a获得依赖对象b的过程，由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p><p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p><h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p>Spring使用工厂模式可以通过<code>BeanFactory</code>或<code>ApplicationContext</code>创建bean对象。</p><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code>：延迟注入(使用到某个bean的时候才会注入)，相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code>：容器启动的时候，不管你用没用到，一次性创建所有bean 。<code>BeanFactory</code>仅提供了最基本的依赖注入支持，<code>ApplicationContext</code>扩展了<code>BeanFactory</code>，除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">                <span class="string">"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml"</span>);</span><br><span class="line">        HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">"helloApplicationContext"</span>);</span><br><span class="line">        obj.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><strong>使用单例模式的好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC 压力，缩短GC 停顿时间。</li></ul><p><strong>Spring中bean的默认作用域就是singleton(单例)的。</strong>除了singleton作用域，Spring中bean还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li><li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li></ul><p><strong>Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h4 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>将SpringIOC相关知识点整理了一遍，要想知道哪些知识点是比较重要的。很简单，我们去找找相关的面试题就知道了，如果该面试题是常见的，那么说明这个知识点还是相对比较重要的啦！</p><p>以下的面试题从各种博客上摘抄下来，摘抄量较大的会注明出处的~</p><h3 id="1什么是spring"><a href="#1什么是spring" class="headerlink" title="1什么是spring?"></a>1什么是spring?</h3><blockquote><p>什么是spring?</p></blockquote><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架<strong>目标是简化Java企业级应用开发</strong>，并通过POJO为基础的编程模型促进良好的编程习惯。</p><h3 id="2使用Spring框架的好处是什么？"><a href="#2使用Spring框架的好处是什么？" class="headerlink" title="2使用Spring框架的好处是什么？"></a>2使用Spring框架的好处是什么？</h3><blockquote><p>使用Spring框架的好处是什么？</p></blockquote><ul><li><strong>轻量</strong>：Spring 是轻量的，基本的版本大约2MB。</li><li><strong>控制反转</strong>：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器</strong>：Spring 包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li><strong>事务管理</strong>：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li><strong>异常处理</strong>：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li></ul><h3 id="3Spring由哪些模块组成"><a href="#3Spring由哪些模块组成" class="headerlink" title="3Spring由哪些模块组成?"></a>3Spring由哪些模块组成?</h3><blockquote><p>Spring由哪些模块组成?</p></blockquote><p>简单可以分成6大模块：</p><ul><li>Core</li><li>AOP</li><li>ORM</li><li>DAO</li><li>Web</li><li>Spring EE</li></ul><p><img src="https://segmentfault.com/img/remote/1460000014979733?w=804&h=623" alt="img"></p><h3 id="4BeanFactory-实现举例"><a href="#4BeanFactory-实现举例" class="headerlink" title="4BeanFactory 实现举例"></a>4BeanFactory 实现举例</h3><blockquote><p>BeanFactory 实现举例</p></blockquote><p>Bean工厂是工厂模式的一个实现，提供了控制反转功能，<strong>用来把应用的配置和依赖从正真的应用代码中分离</strong>。</p><p>在spring3.2之前最常用的是XmlBeanFactory的，但现在被废弃了，取而代之的是：XmlBeanDefinitionReader和DefaultListableBeanFactory</p><h3 id="5什么是Spring的依赖注入？"><a href="#5什么是Spring的依赖注入？" class="headerlink" title="5什么是Spring的依赖注入？"></a>5什么是Spring的依赖注入？</h3><blockquote><p>什么是Spring的依赖注入？</p></blockquote><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你<strong>不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务</strong>，之后一个容器（IOC容器）负责把他们组装起来。</p><h3 id="6有哪些不同类型的IOC（依赖注入）方式？"><a href="#6有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="6有哪些不同类型的IOC（依赖注入）方式？"></a>6有哪些不同类型的IOC（依赖注入）方式？</h3><blockquote><p>有哪些不同类型的IOC（依赖注入）方式？</p></blockquote><ul><li><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li><li>工厂注入：这个是遗留下来的，很少用的了！</li></ul><h3 id="7哪种依赖注入方式你建议使用，构造器注入，还是-Setter方法注入？"><a href="#7哪种依赖注入方式你建议使用，构造器注入，还是-Setter方法注入？" class="headerlink" title="7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？"></a>7哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</h3><blockquote><p>哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</p></blockquote><p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是<strong>用构造器参数实现强制依赖，setter方法实现可选依赖</strong>。</p><h3 id="8什么是Spring-beans"><a href="#8什么是Spring-beans" class="headerlink" title="8什么是Spring beans?"></a>8什么是Spring beans?</h3><blockquote><p>什么是Spring beans?</p></blockquote><p>Spring beans 是那些<strong>形成Spring应用的主干的java对象</strong>。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中<code>&lt;bean/&gt;</code>的形式定义。</p><p>这里有四种重要的方法给Spring容器<strong>提供配置元数据</strong>。</p><ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li><li>Groovy DSL配置</li></ul><h3 id="9解释Spring框架中bean的生命周期"><a href="#9解释Spring框架中bean的生命周期" class="headerlink" title="9解释Spring框架中bean的生命周期"></a>9解释Spring框架中bean的生命周期</h3><blockquote><p>解释Spring框架中bean的生命周期</p></blockquote><ul><li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li><li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li><li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li></ul><h3 id="10解释不同方式的自动装配"><a href="#10解释不同方式的自动装配" class="headerlink" title="10解释不同方式的自动装配"></a>10解释不同方式的自动装配</h3><blockquote><p>解释不同方式的自动装配</p></blockquote><ul><li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li><li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li>byType:：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><p>只用注解的方式时，<strong>注解默认是使用byType的</strong>！</p><h3 id="11IOC的优点是什么？"><a href="#11IOC的优点是什么？" class="headerlink" title="11IOC的优点是什么？"></a>11IOC的优点是什么？</h3><blockquote><p>IOC的优点是什么？</p></blockquote><p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。<strong>最小的代价和最小的侵入性使松散耦合得以实现</strong>。IOC容器支持加载服务时的<strong>饿汉式初始化和懒加载</strong>。</p><h3 id="12哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#12哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="12哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>12哪些是重要的bean生命周期方法？ 你能重载它们吗？</h3><blockquote><p>哪些是重要的bean生命周期方法？ 你能重载它们吗？</p></blockquote><p>有两个重要的bean 生命周期方法，第一个是<code>setup</code>， 它是在容器加载bean的时候被调用。第二个方法是 <code>teardown</code>它是在容器卸载类的时候被调用。</p><p>The bean 标签有两个重要的属性（<code>init-method</code>和<code>destroy-method</code>）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（<code>@PostConstruct</code>和<code>@PreDestroy</code>）。</p><h3 id="13怎么回答面试官：你对Spring的理解？"><a href="#13怎么回答面试官：你对Spring的理解？" class="headerlink" title="13怎么回答面试官：你对Spring的理解？"></a>13怎么回答面试官：你对Spring的理解？</h3><blockquote><p>怎么回答面试官：你对Spring的理解？</p></blockquote><p>来源：</p><ul><li><a href="https://www.zhihu.com/question/48427693?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/48427693?sort=created</a></li></ul><p>下面我就截几个答案：</p><p>一、</p><p><img src="https://segmentfault.com/img/remote/1460000014979734" alt="img"></p><p>二、</p><p><img src="https://segmentfault.com/img/remote/1460000014979735" alt="img"></p><h3 id="14Spring框架中的单例Beans是线程安全的么？"><a href="#14Spring框架中的单例Beans是线程安全的么？" class="headerlink" title="14Spring框架中的单例Beans是线程安全的么？"></a>14Spring框架中的单例Beans是线程安全的么？</h3><blockquote><p>Spring框架中的单例Beans是线程安全的么？</p></blockquote><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。<strong>如果你的bean有多种状态的话</strong>（比如 View Model 对象），就<strong>需要自行保证线程安全</strong>。</p><p>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”</p><h3 id="15FileSystemResource和ClassPathResource有何区别？"><a href="#15FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="15FileSystemResource和ClassPathResource有何区别？"></a>15FileSystemResource和ClassPathResource有何区别？</h3><blockquote><p>FileSystemResource和ClassPathResource有何区别？</p></blockquote><p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource文件放在ClassPath下。</p><p>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。</p><p>简而言之，<strong>ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件</strong>。</p><h3 id="synchronized锁问题"><a href="#synchronized锁问题" class="headerlink" title="synchronized锁问题"></a>synchronized锁问题</h3><ul><li><a href="https://www.zhihu.com/question/277812143" target="_blank" rel="noopener">https://www.zhihu.com/question/277812143</a></li></ul><blockquote><p>开启10000个线程，每个线程给员工表的money字段【初始值是0】加1，没有使用悲观锁和乐观锁，但是在业务层方法上加了synchronized关键字，问题是代码执行完毕后数据库中的money 字段不是10000，而是小于10000 问题出在哪里？</p></blockquote><p>Service层代码：</p><p><img src="https://segmentfault.com/img/remote/1460000018182343" alt="代码"></p><p>SQL代码(没有加悲观/乐观锁)：</p><p><img src="https://segmentfault.com/img/remote/1460000018182344?w=600&h=143" alt="SQL代码(没有加悲观/乐观锁)"></p><p>用1000个线程跑代码：</p><p><img src="https://segmentfault.com/img/remote/1460000018182345" alt="用1000个线程跑代码："></p><p>简单来说：多线程跑一个使用<strong>synchronized</strong>关键字修饰的方法，方法内操作的是数据库，按正常逻辑应该最终的值是1000，但经过多次测试，结果是<strong>低于</strong>1000。这是为什么呢？</p><h3 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h3><p>既然测试出来的结果是低于1000，那说明这段代码<strong>不是线程安全</strong>的。不是线程安全的，那问题出现在哪呢？众所周知，synchronized方法能够保证所修饰的<code>代码块、方法</code>保证<code>有序性、原子性、可见性</code>。</p><p>讲道理，以上的代码跑起来，问题中<code>Service</code>层的<code>increaseMoney()</code>是<code>有序的、原子的、可见的</code>，所以<strong>断定</strong>跟synchronized应该没关系。</p><p>(参考我之前写过的synchronize锁笔记：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484198&idx=1&sn=4d8e372165bb49987a6243f17153a9b4&chksm=ebd74227dca0cb31311886f835092c9360d08a9f0a249ece34d4b1e49a31c9ec773fa66c8acc&scene=21#wechat_redirect" target="_blank" rel="noopener">Java锁机制了解一下</a>)</p><p>既然Java层面上找不到原因，那分析一下数据库层面的吧(因为方法内操作的是数据库)。在<code>increaseMoney()</code>方法前加了<code>@Transcational</code>注解，说明这个方法是带有<strong>事务</strong>的。事务能保证同组的SQL要么同时成功，要么同时失败。讲道理，如果没有报错的话，应该每个线程都对money值进行<code>+1</code>。从理论上来说，结果应该是1000的才对。</p><p>(参考我之前写过的Spring事务：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=5&sn=67467f35a9e9314aa3d1c07ff250af6b&chksm=ebd74430dca0cd26c94daf2d3e34806c29d05583de2255b98d20d34cd86e12ae94624d33be1b&token=1885756144&lang=zh_CN#rd" target="_blank" rel="noopener">一文带你看懂Spring事务！</a>)</p><p>根据上面的分析，我怀疑是<strong>提问者没测试好</strong>(hhhh，逃)，于是我也跑去测试了一下，发现是以提问者的方式来使用<strong>是真的有问题</strong>。</p><p>首先贴一下我的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; employeeService.addEmployee()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查出ID为8的记录，然后每次将年龄增加一</span></span><br><span class="line">        Employee employee = employeeRepository.getOne(<span class="number">8</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">        Integer age = employee.getAge();</span><br><span class="line">        employee.setAge(age + <span class="number">1</span>);</span><br><span class="line">        employeeRepository.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地打印了每次拿到的employee值，并且拿到了SQL执行的顺序，如下(贴出小部分)：</p><p><img src="https://segmentfault.com/img/remote/1460000018182346" alt="SQL执行的顺序"></p><p>从打印的情况我们可以得出：多线程情况下并<strong>没有串行</strong>执行<code>addEmployee()</code>方法。这就导致对同一个值做<strong>重复</strong>的修改，所以最终的数值比1000要少。</p><h3 id="图解出现的原因"><a href="#图解出现的原因" class="headerlink" title="图解出现的原因"></a>图解出现的原因</h3><p>发现并不是<strong>同步</strong>执行的，于是我就怀疑<code>synchronized</code>关键字和Spring肯定有点冲突。于是根据这两个关键字搜了一下，找到了问题所在。</p><p>我们知道Spring事务的底层是Spring AOP，而Spring AOP的底层是动态代理技术。跟大家一起回顾一下动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    Object target ;</span><br><span class="line">    Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), Main<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">InvocationHandler</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 但凡带有@Transcational注解的方法都会被拦截</span></span><br><span class="line">            <span class="comment">// 1... 开启事务</span></span><br><span class="line">            method.invoke(target);</span><br><span class="line">            <span class="comment">// 2... 提交事务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(详细请参考我之前写过的动态代理：<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484222&idx=1&sn=5191aca33f7b331adaef11c5e07df468&chksm=ebd7423fdca0cb29cdc59b4c79afcda9a44b9206806d2212a1b807c9f5879674934c37c250a1&scene=21#wechat_redirect" target="_blank" rel="noopener">给女朋友讲解什么是代理模式</a>)</p><p>实际上Spring做的处理跟以上的思路是一样的，我们可以看一下TransactionAspectSupport类中<code>invokeWithinTransaction()</code>：</p><p><img src="https://segmentfault.com/img/remote/1460000018182347" alt="Spring事务管理是如何实现的"></p><p>调用方法<strong>前</strong>开启事务，调用方法<strong>后</strong>提交事务</p><p><img src="https://segmentfault.com/img/remote/1460000018182348" alt="Spring事务和synchronized锁互斥问题"></p><p>在多线程环境下，就可能会出现：<strong>方法执行完了(synchronized代码块执行完了)，事务还没提交，别的线程可以进入被synchronized修饰的方法，再读取的时候，读到的是还没提交事务的数据，这个数据不是最新的</strong>，所以就出现了这个问题。</p><p><img src="https://segmentfault.com/img/remote/1460000018182349?w=1353&h=684" alt="事务未提交，别的线程读取到旧数据"></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>从上面我们可以发现，问题所在是因为<code>@Transcational</code>注解和<code>synchronized</code>一起使用了，<strong>加锁的范围没有包括到整个事务</strong>。所以我们可以这样做：</p><p>新建一个名叫SynchronizedService类，让其去调用<code>addEmployee()</code>方法，整个代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SynchronizedService synchronizedService ;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; synchronizedService.synchronizedAddEmployee()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建的Service类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService ;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedAddEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        employeeService.addEmployee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepository employeeRepository;  </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查出ID为8的记录，然后每次将年龄增加一</span></span><br><span class="line">        Employee employee = employeeRepository.getOne(<span class="number">8</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + employee);</span><br><span class="line">        Integer age = employee.getAge();</span><br><span class="line">        employee.setAge(age + <span class="number">1</span>);</span><br><span class="line">        employeeRepository.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将synchronized锁的范围<strong>包含到整个Spring事务上</strong>，这就不会出现线程安全的问题了。在测试的时候，我们可以发现1000个线程跑起来<strong>比之前要慢得多</strong>，当然我们的数据是正确的：</p><p><img src="https://segmentfault.com/img/remote/1460000018182350" alt="正确的数据"></p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Web</title>
      <link href="/2020/04/22/JAVA-Web/"/>
      <url>/2020/04/22/JAVA-Web/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java Web学习笔记</p></blockquote><a id="more"></a><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h3><p>Tomcat简单的说就是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。</p><h3 id="Tomcat图解"><a href="#Tomcat图解" class="headerlink" title="Tomcat图解"></a>Tomcat图解</h3><p>Tomcat就是<strong>提供能够让别人访问自己写的页面的一个程序</strong></p><ul><li>Tomcat体系结构</li></ul><p><img src="/2020/04/22/JAVA-Web/clip_image002.jpg" alt="img"></p><p><img src="/2020/04/22/JAVA-Web/clip_image002-1587560992120.jpg" alt="img"></p><ul><li>浏览器访问WEB资源的流程图</li></ul><p><img src="/2020/04/22/JAVA-Web/clip_image004-1587560992120.jpg" alt="img"></p><ul><li>URL图示</li></ul><p><img src="/2020/04/22/JAVA-Web/clip_image009.png" alt="img"></p><ul><li>Tomcat结构目录</li></ul><p><img src="/2020/04/22/JAVA-Web/clip_image011.jpg" alt="img"></p><ul><li>web站点目录</li></ul><p><img src="/2020/04/22/JAVA-Web/clip_image016.png" alt="标题: fig:"></p><ul><li>bbs目录代表一个web应用</li><li>bbs目录下的html,jsp文件可以直接被浏览器访问</li><li><strong>WEB-INF</strong>目录下的资源是不能直接被浏览器访问的</li><li>web.xml文件是web程序的主要配置文件</li><li>所有的classes文件都放在classes目录下</li><li>jar文件放在lib目录下</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Servlet 是在服务器上运行的小程序。一个 servlet 就是一个 Java 类，并且可以通过 “请求—响应” 编程模式来访问的这个驻留在服务器内存里的 servlet 程序。</p><p>Java Servlet API 是 Servlet 容器 (tomcat) 和 servlet 之间的接口，它定义了 serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 ServletRequest 和 ServletResponse。所以说我们在编写 servlet 时，需要实现 Servlet 接口，按照其规范进行操作。</p><p>类的继承关系如下：</p><p><img src="/2020/04/22/JAVA-Web/1535532891036.png" alt="img"></p><h3 id="Tomcat-amp-Servlet"><a href="#Tomcat-amp-Servlet" class="headerlink" title="Tomcat &amp; Servlet"></a>Tomcat &amp; Servlet</h3><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。</p><p>从 http 协议中的请求和响应可以得知，浏览器发出的请求是一个请求文本，而浏览器接收到的也应该是一个响应文本。浏览器发送过来的请求也就是 request，响应回去的就用 response，如下图：</p><p><img src="https://frank-lam.github.io/fullstack-tutorial/assets/servlet-tomcat.png" alt="img"></p><p>① Tomcat 将 http 请求文本接收并解析，然后封装成 HttpServletRequest 类型的 request 对象，所有的 HTTP 头数据读可以通过 request 对象调用对应的方法查询到。</p><p>② Tomcat 同时会要响应的信息封装为 HttpServletResponse 类型的 response 对象，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 tomcat，tomcat 就会将其变成响应文本的格式发送给浏览器</p><h3 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h3><p>实现Servlet接口，需要实现5个方法。而HttpServlet类已经实现了Servlet接口的所有方法。实际编写Servlet时，只需要继承HttpServlet，重写你需要的方法即可，并且它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。</p><ul><li>一般都是重写doGet()和doPost()方法的。</li></ul><p>主要描述了从浏览器到服务器，再从服务器到浏览器的整个执行过程</p><h4 id="浏览器请求"><a href="#浏览器请求" class="headerlink" title="浏览器请求"></a>浏览器请求</h4><p><img src="/2020/04/22/JAVA-Web/20180521175251513.png" alt="img"></p><p>浏览器向服务器请求时，服务器不会直接执行我们的类，而是到 web.xml 里寻找路径名</p><ul><li>① 浏览器输入访问路径后，携带了请求行，头，体</li><li>② 根据访问路径找到已注册的 servlet 名称 </li><li>③ 根据映射找到对应的 servlet 名 </li><li>④ 根据根据 servlet 名找到我们全限定类名，既我们自己写的类</li></ul><h4 id="服务器创建对象"><a href="#服务器创建对象" class="headerlink" title="服务器创建对象"></a>服务器创建对象</h4><p><img src="/2020/04/22/JAVA-Web/20180521182037787.png" alt="img"></p><ul><li>① 服务器找到全限定类名后，通过反射创建对象，同时也创建了 servletConfig，里面存放了一些初始化信息（注意服务器只会创建一次 servlet 对象，所以 servletConfig 也只有一个）</li></ul><h4 id="调用-init-方法"><a href="#调用-init-方法" class="headerlink" title="调用 init 方法"></a>调用 init 方法</h4><p><img src="/2020/04/22/JAVA-Web/20180521183945631.png" alt="img"></p><ul><li>① 对象创建好之后，首先要执行 init 方法，但是我们发现我们自定义类下没有 init 方法，所以程序会到其父类 HttpServlet 里找 </li><li>② 我们发现 HttpServlet 里也没有 init 方法，所以继续向上找，既向其父类 GenericServlet 中继续寻找, 在 GenericServlet 中我们发现了 init 方法，则执行 init 方法（对接口 Servlet 中的 init 方法进行了重写）</li></ul><p>注意： 在 GenericServlet 中执行 public void init(ServletConfig config) 方法的时候，又调用了自己无参无方法体的 init() 方法，其目的是为了方便开发者，如果开发者在初始化的过程中需要实现一些功能，可以重写此方法。</p><h4 id="调用-service-方法"><a href="#调用-service-方法" class="headerlink" title="调用 service 方法"></a>调用 service 方法</h4><p><img src="/2020/04/22/JAVA-Web/20180521212619975.png" alt="img"></p><p>接着，服务器会先创建两个对象：ServletRequest 请求对象和 ServletResponse 响应对象，用来封装浏览器的请求数据和封装向浏览器的响应数据 </p><p>① 接着服务器会默认在我们写的类里寻找 service(ServletRequest req, ServletResponse res) 方法，但是 DemoServlet 中不存在，那么会到其父类中寻找 </p><p>② 到父类 HttpServlet 中发现有此方法，则直接调用此方法，并将之前创建好的两个对象传入 </p><p>③ 然后将传入的两个参数强转，并调用 HttpServlet 下的另外个 service 方法 </p><p>④ 接着执行 <code>service(HttpServletRequest req, HttpServletResponse resp)</code>方法，在此方法内部进行了判断请求方式，并执行 doGet 和 doPost，但是 doGet 和 doPost 方法已经被我们自己重写了，所以会执行我们重写的方法 </p><blockquote><p>为什么我们不直接重写 service 方法？ 因为如果重写 service 方法的话，我们需要将强转，以及一系列的安全保护判断重新写一遍，会存在安全隐患</p></blockquote><h4 id="向浏览器响应"><a href="#向浏览器响应" class="headerlink" title="向浏览器响应"></a>向浏览器响应</h4><p><img src="/2020/04/22/JAVA-Web/20180521214423142.png" alt="img"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Servlet 何时创建<ul><li>默认第一次访问servlet时创建该对象（调用<code>init()</code>方法）</li></ul></li><li>Servlet 何时销毁<ul><li>服务器关闭servlet就销毁了（调用<code>destroy()</code>方法）</li></ul></li><li>每次访问必须执行的方法<ul><li><code>public void service(ServletRequest arg0, ServletResponse arg1)</code></li></ul></li><li>为什么Servlet是单例的<br>浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。</li></ul><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p><img src="/2020/04/22/JAVA-Web/1535535812505.png" alt="img"></p><ul><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet的时候，Servlet会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ul><h3 id="Servlet细节"><a href="#Servlet细节" class="headerlink" title="Servlet细节"></a>Servlet细节</h3><h4 id="一个已经注册的Servlet可以被多次映射"><a href="#一个已经注册的Servlet可以被多次映射" class="headerlink" title="一个已经注册的Servlet可以被多次映射"></a>一个已经注册的Servlet可以被多次映射</h4><p>即同一个Servlet可以映射到多个URL上。</p><p>无论访问<a href="http://localhost:8080/Demo1还是http://localhost:8080/zhang。结果都是Demo1。" target="_blank" rel="noopener">http://localhost:8080/Demo1还是http://localhost:8080/zhang。结果都是Demo1。</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>zhangwell.web.Demo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/zhang<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Servlet映射的URL可以使用通配符"><a href="#Servlet映射的URL可以使用通配符" class="headerlink" title="Servlet映射的URL可以使用通配符"></a>Servlet映射的URL可以使用通配符</h4><p>通配符有两种格式：</p><ul><li><code>*.扩展名</code></li><li><code>/*</code></li></ul><h4 id="Servlet是单例的"><a href="#Servlet是单例的" class="headerlink" title="Servlet是单例的"></a>Servlet是单例的</h4><h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。</p><h5 id="每次访问请求对象和响应对象都是新的"><a href="#每次访问请求对象和响应对象都是新的" class="headerlink" title="每次访问请求对象和响应对象都是新的"></a>每次访问请求对象和响应对象都是新的</h5><p>对于每次访问请求，Servlet引擎都会创建一个新的<code>HttpServletRequest</code>请求对象和一个新的<code>HttpServletResponse</code>响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。</p><h5 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h5><p>当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。<br>原则：</p><ol><li><p>如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制<code>synchronized (对象){}</code></p></li><li><p>如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义。这样不会存在线程安全问题</p></li></ol><h4 id="load-on-startup"><a href="#load-on-startup" class="headerlink" title="load-on-startup"></a>load-on-startup</h4><p>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么WEB应用程序在启动时，就会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。</load-on-startup></servlet></p><h4 id="在web访问任何资源都是在访问Servlet"><a href="#在web访问任何资源都是在访问Servlet" class="headerlink" title="在web访问任何资源都是在访问Servlet"></a>在web访问任何资源都是在访问Servlet</h4><p>无论在web中访问什么资源【包括JSP】，都是在访问Servlet。没有手工配置缺省Servlet的时候，访问静态图片，静态网页，缺省Servlet会在你web站点中寻找该图片或网页，如果有就返回给浏览器，没有就报404错误。</p><h3 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h3><h4 id="ServletContext对象-1"><a href="#ServletContext对象-1" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h4><p>当Tomcat启动的时候，就会创建一个ServletContext对象。它代表着当前web站点</p><h4 id="ServletContext有什么用"><a href="#ServletContext有什么用" class="headerlink" title="ServletContext有什么用"></a>ServletContext有什么用</h4><ol><li>ServletContext既然代表着当前web站点，那么所有Servlet都共享着一个ServletContext对象，所以Servlet之间可以通过ServletContext实现通讯。</li><li>ServletConfig获取的是配置的是单个Servlet的参数信息，ServletContext可以获取的是配置整个web站点的参数信息</li><li>利用ServletContext读取web站点的资源文件</li><li>实现Servlet的转发【用ServletContext转发不多，主要用request转发】</li></ol><h4 id="Servlet之间实现通讯"><a href="#Servlet之间实现通讯" class="headerlink" title="Servlet之间实现通讯"></a>Servlet之间实现通讯</h4><p>ServletContext对象可以被称之为域对象（可以简单理解成一个容器【类似于Map集合】）</p><p>实现Servlet之间通讯就要用到ServletContext的<code>setAttribute(String name,Object obj)</code>方法， 第一个参数是关键字，第二个参数是你要存储的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是Demo2的代码</span></span><br><span class="line"><span class="comment">// 获取到ServletContext对象</span></span><br><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">String value = <span class="string">"zhangwell"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyName作为关键字，value作为值存进域对象【类型于Map集合】</span></span><br><span class="line">servletContext.setAttribute(<span class="string">"MyName"</span>, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是Demo3的代码</span></span><br><span class="line"><span class="comment">// 获取ServletContext对象</span></span><br><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字获取存储在域对象的值</span></span><br><span class="line">String value = (String)servletContext.getAttribute(<span class="string">"MyName"</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line"><span class="comment">// zhangwell</span></span><br></pre></td></tr></table></figure><p>访问Demo3可以获取Demo2存储的信息，从而实现多个Servlet之间通讯。</p><h4 id="获取web站点配置的信息"><a href="#获取web站点配置的信息" class="headerlink" title="获取web站点配置的信息"></a>获取web站点配置的信息</h4><p>如果想要让所有的Servlet都能够获取到连接数据库的信息，不可能在web.xml文件中每个Servlet中都配置一下，这样代码量太大了！并且会显得非常冗余。</p><p>方法：<code>web.xml</code>文件支持对整个站点进行配置参数信息【所有Servlet都可以取到该参数信息】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>zhangwell<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo4代码</span></span><br><span class="line"><span class="comment">// 获取到ServletContext对象</span></span><br><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取值</span></span><br><span class="line">String value = servletContext.getInitParameter(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line"><span class="comment">// zhangwell</span></span><br></pre></td></tr></table></figure><h3 id="forward-amp-redirect"><a href="#forward-amp-redirect" class="headerlink" title="forward &amp; redirect"></a>forward &amp; redirect</h3><p>在设计 Web 应用程序时，经常需要把一个系统进行结构化设计，即按照模块进行划分，让不同的 Servlet 来实现不同的功能，例如可以让其中一个 Servlet 接收用户的请求，另外一个 Servlet 来处理用户的请求。为了实现这种程序的模块化，就需要保证在不同的 Servlet 之间可以相互跳转，而 Servlet 中主要有两种实现跳转的方式：forward 与 redirect 方式。</p><p>forward 是服务器内部的重定向，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，而客户端并不知道，因此在客户端浏览器的地址栏中不会显示转向后的地址，还是原来的地址。由于在整个定向的过程中用的是同一个 Request，因此 forward 会将 Request 的信息带到被定向的 JSP 或 Servlet 中使用。</p><p>redirect 则是客户端的重定向，是完全的跳转，即客户端浏览器会获取到跳转后的地址，然后重新发送请求，因此浏览器中会显示跳转后的地址。同事，由于这种方式比 forward 方式多了一次网络请求，因此其效率要低于 forward 方式。需要注意的是，客户端的重定向可以通过设置特定的 HTTP 头或改写 JavaScript 脚本实现。</p><p><img src="/2020/04/22/JAVA-Web/1535537913258.png" alt="img"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="什么是HTPP协议"><a href="#什么是HTPP协议" class="headerlink" title="什么是HTPP协议"></a>什么是HTPP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。它是TCP/IP协议的一个应用层协议</p><p>简单来说，HTTP协议就是客户端和服务器交互的一种通迅的格式。</p><ul><li>例子：在浏览器点击一个链接，浏览器就为我打开这个链接的网页。</li><li>原理：当在浏览器中点击这个链接的时候，浏览器会向服务器发送一段文本，告诉服务器请求打开的是哪一个网页。服务器收到请求后，就返回一段文本给浏览器，浏览器会将该文本解析，然后显示出来。这段文本就是遵循HTTP协议规范的。</li></ul><h3 id="HTTP1-0-amp-HTTP1-1"><a href="#HTTP1-0-amp-HTTP1-1" class="headerlink" title="HTTP1.0 &amp; HTTP1.1"></a>HTTP1.0 &amp; HTTP1.1</h3><ul><li>HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源【短连接，获取资源后就断开连接】</li><li>HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源【保持连接】</li></ul><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>浏览器向服务器请求某个web资源时，称之为浏览器向服务器发送了一个http请求。一个完整http请求应该包含三个部分：</p><ol><li><p>请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号】</p></li><li><p>多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】</p></li><li><p>一个空行</p></li></ol><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>请求行：GET /java.html HTTP/1.1<br>请求行中的GET称之为请求方式，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。<br>常用的有：POST,GET<br>一般来说，当我们点击超链接，通过地址栏访问都是get请求方式。通过表单提交的数据一般是post方式。<br>可以简单理解GET方式用来查询数据,POST方式用来提交数据，get的提交速度比post快<br>GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。<br>POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。</p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】<br>Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】<br>Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】<br>Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】<br>Host: <a href="http://www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】" target="_blank" rel="noopener">www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】</a><br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】<br>Referer: <a href="http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---反盗链】" target="_blank" rel="noopener">http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---反盗链】</a><br>8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】<br>Cookie【浏览器告诉服务器，带来的Cookie是什么】<br>Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】<br>Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 </p><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>一个HTTP响应代表着服务器向浏览器回送数据，一个完整的HTTP响应应该包含四个部分:</p><ol><li>一个状态行【用于描述服务器对请求的处理结果。】</li><li>多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】</li><li>一个空行</li><li>实体内容【服务器向客户端回送的数据】</li></ol><h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>格式： HTTP版本号 状态码 原因叙述<br>状态行：HTTP/1.1 200 OK<br>状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类</p><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>Location: <a href="http://www.it315.org/index.jsp" target="_blank" rel="noopener">http://www.it315.org/index.jsp</a> 【服务器告诉浏览器要跳转到哪个页面】<br>Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】<br>Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】<br>Content-Length: 80 【服务器告诉浏览器回送数据的长度】<br>Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】<br>Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】<br>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】<br>Refresh: 1;url=<a href="http://www.it315.org【服务器告诉浏览器要定时刷新】" target="_blank" rel="noopener">http://www.it315.org【服务器告诉浏览器要定时刷新】</a><br>Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】<br>Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】<br>Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存Cookie】<br>Expires: -1【服务器告诉浏览器不要设置缓存】<br>Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】<br>Pragma: no-cache 【服务器告诉浏览器不要设置缓存】<br>Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】<br>Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】</p><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，<strong>HTTP请求头中的所有信息都封装在这个对象中</strong>，开发人员通过这个对象的方法，可以获得客户信息。<br>简单来说，要得到浏览器信息，就找HttpServletRequest对象</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>获得客户机【浏览器】信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getRequestURL() <span class="comment">// 方法返回客户端发出请求时的完整URL。</span></span><br><span class="line">getRequestURI() <span class="comment">// 方法返回请求行中的资源名部分。</span></span><br><span class="line">getQueryString() <span class="comment">// 方法返回请求行中的参数部分。</span></span><br><span class="line">getPathInfo() <span class="comment">// 方法返回请求URL中的额外路径信息。额外路径信息是请求URL中的位于Servlet的路径之后和查询参数之前的内容，它以“/”开头。</span></span><br><span class="line">getRemoteAddr() <span class="comment">// 方法返回发出请求的客户机的IP地址</span></span><br><span class="line">getRemoteHost() <span class="comment">// 方法返回发出请求的客户机的完整主机名</span></span><br><span class="line">getRemotePort() <span class="comment">// 方法返回客户机所使用的网络端口号</span></span><br><span class="line">getLocalAddr() <span class="comment">// 方法返回WEB服务器的IP地址。</span></span><br><span class="line">getLocalName() <span class="comment">// 方法返回WEB服务器的主机名</span></span><br></pre></td></tr></table></figure><p>获得客户机请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getHeaders() 方法 </span><br><span class="line">getHeaderNames() 方法</span><br></pre></td></tr></table></figure><p>获得客户机请求参数(客户端提交的数据)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getParameter() 方法</span><br><span class="line">getParameterValues(String name)方法</span><br><span class="line">getParameterNames() 方法 </span><br><span class="line">getParameterMap() 方法</span><br></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><p>基本概念：指用户开一个浏览器，访问一个网站，只要不关闭该浏览器，不管该用户点击多少个超链接，访问多少资源，直到用户关闭浏览器，整个这个过程我们称为一次会话。</p><p>会话常用来作为会话跟踪，例如：</p><ul><li>在论坛登陆的时候，很多时候会有一个小框框问你是否要自动登陆，当你下次登陆的时候就不用输入密码了</li></ul><h3 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h3><p>会话跟踪技术有 Cookie 和 Session</p><h4 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h4><p>网页之间的交互是通过HTTP协议传输数据的，而Http协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。</p><p>服务器无法确认用户的信息，于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie</p><blockquote><p>Cookie的流程：</p><p>浏览器访问服务器，如果服务器需要记录该用户的状态，就使用response向浏览器发送一个Cookie，浏览器会把Cookie保存起来。当浏览器再次访问服务器的时候，浏览器会把请求的网址连同Cookie一同交给服务器。</p></blockquote><h4 id="Cookie-API"><a href="#Cookie-API" class="headerlink" title="Cookie API"></a>Cookie API</h4><ul><li>Cookie类用于创建一个Cookie对象</li><li>response接口中定义了一个addCookie方法，它用于在其响应头中增加一个相应的Cookie头字段</li><li>request接口中定义了一个getCookies方法，它用于获取客户端提交的Cookie</li></ul><p>常用的Cookie方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cookie</span><span class="params">(String name,String value)</span></span></span><br><span class="line"><span class="function"><span class="title">setValue</span><span class="params">()</span>、<span class="title">getValue</span><span class="params">()</span>方法 </span></span><br><span class="line"><span class="function"><span class="title">setMaxAge</span><span class="params">()</span>、<span class="title">getMaxAge</span><span class="params">()</span>方法 </span></span><br><span class="line"><span class="function"><span class="title">setPath</span><span class="params">()</span>、<span class="title">getPath</span><span class="params">()</span>方法 </span></span><br><span class="line"><span class="function"><span class="title">setDomain</span><span class="params">()</span>、<span class="title">getDomain</span><span class="params">()</span>方法</span></span><br><span class="line"><span class="function"><span class="title">getName</span><span class="params">()</span>方法</span></span><br></pre></td></tr></table></figure><p>示例：创建Cookie对象，发送Cookie给浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Cookie对象，指定名称和值</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"zhangwell"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Cookie的时间</span></span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向浏览器给一个Cookie</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">response.getWriter().write(<span class="string">"我已经向浏览器发送了一个Cookie"</span>);</span><br></pre></td></tr></table></figure><p>浏览器本身没有任何Cookie</p><p>访问Servlet1，再回到文件夹中，已经发现文件夹中多了个Cookie的文本了</p><h4 id="Cookie细节"><a href="#Cookie细节" class="headerlink" title="Cookie细节"></a>Cookie细节</h4><h5 id="Cookie不可跨域名性"><a href="#Cookie不可跨域名性" class="headerlink" title="Cookie不可跨域名性"></a>Cookie不可跨域名性</h5><p>Cookie具有不可跨域名性。浏览器判断一个网站是否能操作另一个网站的Cookie的依据是域名。所以一般来说，当我访问baidu的时候，浏览器只会把baidu颁发的Cookie带过去，而不会带上google的Cookie。</p><h5 id="Cookie的有效期"><a href="#Cookie的有效期" class="headerlink" title="Cookie的有效期"></a>Cookie的有效期</h5><p>Cookie的有效期是通过<code>setMaxAge()</code>来设置的。</p><p>如果MaxAge为正数，浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆网站时该Cookie就有效【不论关闭了浏览器还是电脑】</p><p>如果MaxAge为负数，Cookie是临时性的，仅在本浏览器内有效，关闭浏览器Cookie就失效了，Cookie不会写到硬盘中（Cookie默认值就是-1）</p><p>如果MaxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie对应的方法，把MaxAge设置为0等同于删除Cookie</p><h5 id="Cookie的修改和删除"><a href="#Cookie的修改和删除" class="headerlink" title="Cookie的修改和删除"></a>Cookie的修改和删除</h5><p>Cookie存储的方式类似于Map集合</p><p>删除方式为有限时间设置为零，修改方式为覆盖Cookie的名称相同的值。删除和修改后都要再添加到浏览器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"用户示例"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对Unicode字符进行编码</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>, URLEncoder.encode(name, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Cookie的时间。，并添加</span></span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">response.getWriter().write(<span class="string">"修改cookie值"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Cookie对象，指定名称和值</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"zhangwell"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Cookie的时间，并添加</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">response.getWriter().write(<span class="string">"删除cookie值"</span>);</span><br></pre></td></tr></table></figure><p>注意：删除，修改Cookie时，新建的Cookie除了value、maxAge之外的所有属性都要与原Cookie相同。如路径、编码等不一致时，浏览器将视为不同的Cookie，不予覆盖，导致删除修改失败！</p><h5 id="Cookie的域名"><a href="#Cookie的域名" class="headerlink" title="Cookie的域名"></a>Cookie的域名</h5><p>Cookie的domain属性决定运行访问Cookie的域名。domain的值规定为“.域名”</p><ul><li>Cookie的隐私安全机制决定Cookie是不可跨域名的。<ul><li>即：<a href="http://www.baidu.com和www.google.com间的Cookie是不可访问" target="_blank" rel="noopener">www.baidu.com和www.google.com间的Cookie是不可访问</a></li></ul></li><li>且同一级域名，不同二级域名也不能交接，<ul><li>即：<a href="http://www.goole.com和www.image.goole.com间cookie也不能" target="_blank" rel="noopener">www.goole.com和www.image.goole.com间cookie也不能</a></li></ul></li></ul><p>如果希望一级域名相同的网页Cookie之间可以相互访问。也就是说<a href="http://www.image.baidu.com可以获取到www.baidu.com的Cookie就需要使用到domain方法。" target="_blank" rel="noopener">www.image.baidu.com可以获取到www.baidu.com的Cookie就需要使用到domain方法。</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>, <span class="string">"zhangwell"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">cookie.setDomain(<span class="string">".test.com"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">printWriter.write(<span class="string">"使用www.test.com域名添加了一个Cookie,只要一级是test.com即可访问"</span>);</span><br></pre></td></tr></table></figure><p>接着，使用<a href="http://www.test.com发布一个Cookie" target="_blank" rel="noopener">www.test.com发布一个Cookie</a></p><p>使用<a href="http://www.image.test.com域名访问一下。发现可以获取到Cookie了" target="_blank" rel="noopener">www.image.test.com域名访问一下。发现可以获取到Cookie了</a></p><h5 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h5><p>Cookie的path属性决定允许访问Cookie的路径。一般地，Cookie发布出来，整个网页的资源都可以使用。若现在只想Servlet1可以获取到Cookie，其他的资源不能获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Servlet2颁发一个Cookie给浏览器，设置路径为"/Servlet1"</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"java"</span>);</span><br><span class="line">cookie.setPath(<span class="string">"/Servlet1"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">1000</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">printWriter.write(<span class="string">"该Cookie只有Servlet1获取得到"</span>);</span><br></pre></td></tr></table></figure><p>使用Servlet3访问服务器，看看浏览器是否把Cookie带上。显然，浏览器访问Servlet3并没有把Cookie带上。</p><p>使用Servlet1访问服务器，看看浏览器是否把Cookie带上。答案是肯定的！</p><h4 id="Cookie的应用"><a href="#Cookie的应用" class="headerlink" title="Cookie的应用"></a>Cookie的应用</h4><h5 id="显示用户上次访问的时间"><a href="#显示用户上次访问的时间" class="headerlink" title="显示用户上次访问的时间"></a>显示用户上次访问的时间</h5><p>按照正常的逻辑来写，程序流程应该是这样子的。先创建Cookie对象，回送Cookie给浏览器。再遍历Cookie，更新Cookie的值。</p><p>但是，按照上面的逻辑是做不到的！因为每次访问Servlet的时候都会覆盖原来的Cookie，取到Cookie的值永远都是当前时间，而不是上次保存的时间。</p><p>于是换一个逻辑写：先检查（遍历）所有Cookie有没有我要的，如果得不到我想要的Cookie，Cookie的值是null，那么就认为是第一次登陆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">PrintWriter printWriter = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取网页上所有的Cookie</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断Cookie的值是否为空</span></span><br><span class="line">String cookieValue = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cookies != <span class="keyword">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到以time为名的Cookie</span></span><br><span class="line">    <span class="keyword">if</span> (cookies[i].getName().equals(<span class="string">"time"</span>)) &#123;</span><br><span class="line">        printWriter.write(<span class="string">"您上次登陆的时间是："</span>);</span><br><span class="line">        cookieValue = cookies[i].getValue();</span><br><span class="line">        printWriter.write(cookieValue);</span><br><span class="line"></span><br><span class="line">        cookies[i].setValue(simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">        response.addCookie(cookies[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//既然已经找到了就可以break循环了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Cookie的值是空的，那么就是第一次访问</span></span><br><span class="line"><span class="keyword">if</span> (cookieValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个Cookie对象，日期为当前时间</span></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"time"</span>, simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Cookie的生命期</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象回送Cookie给浏览器</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    printWriter.write(<span class="string">"您是第一次登陆"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="显示上次浏览过商品"><a href="#显示上次浏览过商品" class="headerlink" title="显示上次浏览过商品"></a>显示上次浏览过商品</h5><p>以书籍为例！首先设计Book对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String id ;</span><br><span class="line"><span class="keyword">private</span> String name ;</span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String id, String name, String author)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">&#125;</span><br><span class="line">...各种set、get方法</span><br></pre></td></tr></table></figure><p>使用LinkedHashMap集合【根据商品的id找书籍所以用Map，删改较多所以用Linked】作为存储数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LinkedHashMap&lt;String, Book&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化开发复杂度，book的id和商品的id相同</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    linkedHashMap.put(<span class="string">"1"</span>, <span class="keyword">new</span> Book(<span class="string">"1"</span>, <span class="string">"javaweb"</span>, <span class="string">"zhong"</span>));</span><br><span class="line">    linkedHashMap.put(<span class="string">"2"</span>, <span class="keyword">new</span> Book(<span class="string">"2"</span>, <span class="string">"java"</span>, <span class="string">"fu"</span>));</span><br><span class="line">    linkedHashMap.put(<span class="string">"3"</span>, <span class="keyword">new</span> Book(<span class="string">"3"</span>, <span class="string">"oracle"</span>, <span class="string">"cheng"</span>));</span><br><span class="line">    linkedHashMap.put(<span class="string">"4"</span>, <span class="keyword">new</span> Book(<span class="string">"4"</span>, <span class="string">"mysql"</span>, <span class="string">"ou"</span>));</span><br><span class="line">    linkedHashMap.put(<span class="string">"5"</span>, <span class="keyword">new</span> Book(<span class="string">"5"</span>, <span class="string">"ajax"</span>, <span class="string">"zi"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到所有书籍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedHashMap <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> linkedHashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网页显示首页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">printWriter.write(<span class="string">"网页上所有的书籍："</span>+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到数据库所有的书</span></span><br><span class="line">LinkedHashMap&lt;String, Book&gt; linkedHashMap = DB.getAll();</span><br><span class="line">Set&lt;Map.Entry&lt;String, Book&gt;&gt; entry = linkedHashMap.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示所有的书到网页上</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123;</span><br><span class="line">    Book book = stringBookEntry.getValue();</span><br><span class="line">    printWriter.write(book.getId() +<span class="string">" "</span>+ book.getName() + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加超链接，对应书籍详情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示所有的书到网页上</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Book&gt; stringBookEntry : entry) &#123;</span><br><span class="line">    Book book = stringBookEntry.getValue();</span><br><span class="line">    printWriter.write(<span class="string">"&lt;a href='/zhangwell/Servlet2?id="</span> + book.getId() + <span class="string">"''target=_blank' +"</span> + book.getName() + <span class="string">"&lt;/a&gt;"</span>);</span><br><span class="line">    printWriter.write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书籍详情页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收id，找到用户想要看哪一本书，输出该书的详细信息</span></span><br><span class="line">String id = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于book的id和商品的id是一致的。获取到用户点击的书</span></span><br><span class="line">Book book = (Book) DB.getAll().get(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出书的详细信息</span></span><br><span class="line">printWriter.write(<span class="string">"书的编号是："</span> + book.getId()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">printWriter.write(<span class="string">"书的名称是："</span> + book.getName()+<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">printWriter.write(<span class="string">"书的作者是："</span> + book.getAuthor()+<span class="string">"&lt;br/&gt;"</span>);</span><br></pre></td></tr></table></figure><p>当用户点击书籍时，服务器就颁发Cookie给浏览器，记住用户点击了该书籍。这里用书籍的id作为Cookie的值，同时还要定义一些规则，定义做多显示三本书，id值使用下划线<code>_</code>作为分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String bookHistory = <span class="keyword">null</span>;</span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cookies != <span class="keyword">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cookies[i].getName().equals(<span class="string">"bookHistory"</span>)) &#123;</span><br><span class="line">        bookHistory = cookies[i].getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出了Cookie的值也分几种情况：</p><ol><li>Cookie的值为null【直接把传入进来的id当做是Cookie的值】</li><li>Cookie的值长度有3个了【把排在最后的id去掉，把传进来的id排在最前边】</li><li>Cookie的值已经包含有传递进来的id了【把已经包含的id先去掉，再把id排在最前面】</li><li>Cookie的值就只有1个或2个，直接把id排在最前边</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bookHistory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果Cookie的值不是null的，那么就分解Cookie的得到之前的id。</span></span><br><span class="line">String[] strings = bookHistory.split(<span class="string">"\\_"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了增删容易并且还要判断id是否存在于该字符串内，使用LinkedList集合装载分解出来的id</span></span><br><span class="line">List list = Arrays.asList(strings);</span><br><span class="line">LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">linkedList.addAll(list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (linkedList.contains(id)) &#123;</span><br><span class="line">    linkedList.remove(id);</span><br><span class="line">    linkedList.addFirst(id);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (linkedList.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        linkedList.removeLast();</span><br><span class="line">        linkedList.addFirst(id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        linkedList.addFirst(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Cookie值就在LinkedList集合里边了。接下来要做的就是把集合中的值取出来，拼接成一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历LinkedList集合，添加个下划线“_”</span></span><br><span class="line"><span class="keyword">for</span> (String s : linkedList) &#123;</span><br><span class="line">    stringBuffer.append(s + <span class="string">"_"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个元素后面就不需要下划线了</span></span><br><span class="line"><span class="keyword">return</span> stringBuffer.deleteCharAt(stringBuffer.length() - <span class="number">1</span>).toString();</span><br></pre></td></tr></table></figure><p>现在已经完成了Cookie值了。接下来设置Cookie的生命周期，回送给浏览器即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String bookHistory = makeHistory(request, id);</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"bookHistory"</span>, bookHistory);</span><br><span class="line">cookie.setMaxAge(<span class="number">30000</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>设置浏览记录显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">printWriter.write(<span class="string">"您曾经浏览过的商品："</span>);</span><br><span class="line">printWriter.write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示用户浏览过的商品</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cookies != <span class="keyword">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cookies[i].getName().equals(<span class="string">"bookHistory"</span>)) &#123;</span><br><span class="line">        <span class="comment">//获取到的bookHistory是2_3_1之类的</span></span><br><span class="line">        String bookHistory = cookies[i].getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆解成每一个id值</span></span><br><span class="line">        String[] ids = bookHistory.split(<span class="string">"\\_"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到每一个id值</span></span><br><span class="line">        <span class="keyword">for</span> (String id : ids) &#123;</span><br><span class="line">            <span class="comment">//通过id找到每一本书</span></span><br><span class="line">            Book book = linkedHashMap.get(id);</span><br><span class="line">            printWriter.write(book.getName());</span><br><span class="line">            printWriter.write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="为什么要使用Session"><a href="#为什么要使用Session" class="headerlink" title="为什么要使用Session"></a>为什么要使用Session</h3><p>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，Cookie只能存储字符串。】。</p><h3 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h3><h4 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h4><p>Session 是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，即Session信息。</p><p>如果说Cookie是检查用户身上的“通行证”来确认用户的身份，那么Session就是通过检查服务器上的“客户明细表”来确认用户的身份的。Session相当于在服务器中建立了一份“客户明细表”。</p><h4 id="Session-API"><a href="#Session-API" class="headerlink" title="Session API"></a>Session API</h4><p>long getCreationTime();【获取Session被创建时间】<br>String getId();【获取Session的id】<br>long getLastAccessedTime();【返回Session最后活跃的时间】<br>ServletContext getServletContext();【获取ServletContext对象】<br>void setMaxInactiveInterval(int var1);【设置Session超时时间】<br>int getMaxInactiveInterval();【获取Session超时时间】<br>Object getAttribute(String var1);【获取Session属性】<br>Enumeration getAttributeNames();【获取Session所有的属性名】<br>void setAttribute(String var1, Object var2);【设置Session属性】<br>void removeAttribute(String var1);【移除Session属性】<br>void invalidate();【销毁该Session】<br>boolean isNew();【该Session是否为新的】</p><h4 id="Session的生命周期和有效期"><a href="#Session的生命周期和有效期" class="headerlink" title="Session的生命周期和有效期"></a>Session的生命周期和有效期</h4><p>Session在用户第一次访问服务器Servlet，jsp等动态资源就会被自动创建，Session对象保存在内存里，这也就为什么可以直接使用request对象获取得到Session对象。如果访问HTML，IMAGE等静态资源Session不会被创建。</p><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，无论是否对Session进行读写，服务器都会认为Session活跃了一次。</p><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除，这个时间也就是Session的超时时间。<br>Session的超时时间默认是30分钟，有三种方式可以对Session的超时时间进行修改</p><h4 id="Session的实现原理"><a href="#Session的实现原理" class="headerlink" title="Session的实现原理"></a>Session的实现原理</h4><p>服务器是如何实现一个session为一个用户浏览器服务的？</p><blockquote><p>为什么服务器能够为不同的用户浏览器提供不同session？</p></blockquote><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。</p><p>于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。其实Session依据Cookie来识别是否是同一个用户。</p><p>简单来说：Session 之所以可以识别不同的用户，依靠的就是Cookie。该Cookie是服务器自动颁发给浏览器的，不用我们手工创建的。其maxAge值默认是-1，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中</p><p>当我们在浏览器种访问Servlet4的时候，服务器就会创建一个Session对象，执行我们的程序代码，并自动颁发个Cookie给用户浏览器，</p><p>当我们用同一个浏览器访问Servlet5的时候，浏览器会把Cookie的值通过http协议带过去给服务器，服务器就知道用哪一Session。</p><p>而当我们使用<strong>新会话</strong>的浏览器访问Servlet5的时候，该新浏览器并没有Cookie，服务器无法辨认使用哪一个Session，所以就获取不到值。</p><h4 id="浏览器禁用Cookie时"><a href="#浏览器禁用Cookie时" class="headerlink" title="浏览器禁用Cookie时"></a>浏览器禁用Cookie时</h4><p>上面说了Session是依靠Cookie来识别用户浏览器的。如果用户浏览器禁用了Cookie了该如何处理。</p><p>Java Web提供了解决方法：URL地址重写。HttpServletResponse类提供了两个URL地址重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURL(String url)</span><br><span class="line">encodeRedirectURL(String url)</span><br></pre></td></tr></table></figure><p>注意：这两个方法会自动判断该浏览器是否支持Cookie，如果支持Cookie，重写后的URL地址就不会带有jsessionid了【即使浏览器支持Cookie，第一次输出URL地址的时候还是会出现jsessionid（因为没有任何Cookie可带）】</p><p>原则：把Session的属性带过去【传递给】另外一个Servlet，都要URL地址重写</p><p>URL地址重写的原理：将Session的信息重写到URL地址中。服务器解析重写后URL，获取Session的信息。这样一来，即使浏览器禁用掉了Cookie，但Session的信息通过服务器端传递，还是可以使用Session来记录用户的状态。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="forward和redirect的区别"><a href="#forward和redirect的区别" class="headerlink" title="forward和redirect的区别"></a>forward和redirect的区别</h3><h4 id="实际发生位置不同，地址栏不同"><a href="#实际发生位置不同，地址栏不同" class="headerlink" title="实际发生位置不同，地址栏不同"></a>实际发生位置不同，地址栏不同</h4><ul><li><strong>转发是发生在服务器的</strong></li></ul><p>转发是由服务器进行跳转的，浏览器的地址栏是没有发生变化的。即使从servlet111 跳转到了 Servlet222 的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。实现转发只是一次的 http 请求<strong>，</strong>一次转发中 request 和 response 对象都是同一个。这也可以解释为什么可以使用 request作为域对象进行Servlet之间的通讯。</p><ul><li><strong>重定向是发生在浏览器的</strong></li></ul><p>重定向是由浏览器进行跳转的，浏览器的地址会发生变化的。由浏览器进行的页面跳转<strong>实现重定向</strong>会发出两个http请求<strong>，</strong>request域对象是无效的，因为它不是同一个request对象。</p><h4 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h4><p>记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发时"/"代表的是本应用程序的根目录【zhangwell】</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/资源名 URI"</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向时"/"代表的是webapps目录</span></span><br><span class="line">response.send(<span class="string">"/web应用/资源名 URI"</span>);</span><br></pre></td></tr></table></figure><h4 id="去往的URL的范围"><a href="#去往的URL的范围" class="headerlink" title="去往的URL的范围"></a>去往的URL的范围</h4><ul><li><p>转发是服务器跳转只能去往当前web应用的资源</p></li><li><p>重定向是服务器跳转，可以去往任何的资源</p></li></ul><h4 id="传递数据类型不同"><a href="#传递数据类型不同" class="headerlink" title="传递数据类型不同"></a>传递数据类型不同</h4><ul><li>转发的request对象可以传递各种类型的数据，包括对象</li><li>重定向只能传递字符串</li></ul><h4 id="跳转的时间不同"><a href="#跳转的时间不同" class="headerlink" title="跳转的时间不同"></a>跳转的时间不同</h4><ul><li>转发时：执行到跳转语句时就会立刻跳转</li><li>重定向：整个页面执行完之后才执行跳转</li></ul><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>转发是带着转发前的请求的参数的。重定向是新的请求</p><p>典型的应用场景：</p><ol><li>转发：访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变</li><li>重定向：提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了</li></ol><h3 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h3><h4 id="简版对比"><a href="#简版对比" class="headerlink" title="简版对比"></a>简版对比</h4><ul><li>Http 报文层面：GET 将请求信息放在 URL中，POST 方法报文中</li><li>数据库层面：GET 符合幂等性和安全性，POST 不符合</li><li>其他层面：GET 可以被缓存、被存储（书签），而 POST 不行</li></ul><h4 id="详版对比"><a href="#详版对比" class="headerlink" title="详版对比"></a>详版对比</h4><p><strong>数据携带</strong></p><ul><li>GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。</li><li>POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。</li></ul><p><strong>请求参数</strong></p><ul><li>GET方式：请求参数放在URL地址后面，以?的方式来进行拼接</li><li>POST方式：请求参数放在HTTP请求包中</li></ul><p><strong>用途</strong></p><ul><li>GET方式一般用来获取数据</li><li>POST方式一般用来提交数据</li><li>原因：<ul><li>首先是因为GET方式携带的数据量比较小，无法带过去很大的数量</li><li>POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决)</li><li>GET方式比POST方式要快</li></ul></li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p><strong>Cookie 简介：</strong></p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把 Cookie 回发给服务端</li><li>服务器接收到后，会解析 Cookie 生成与客户端相对的内容</li></ul><p><strong>Cookiet 的设置以及发送过程：</strong></p><p><img src="/2020/04/22/JAVA-Web/image-20191122210015905.png" alt="image-20191122210015905"></p><p><strong>Session 简介：</strong></p><ul><li>服务端的机制，在服务端保存的信息</li><li>解析客户端请求并操作 Session id ，按需保存状态信息</li></ul><p><strong>Session 的实现方式：</strong></p><ul><li>使用 Cookie 来实现</li><li>使用 URL 回写来实现，每次在 URL 添加 Session id 信息</li></ul><h4 id="简版对比-1"><a href="#简版对比-1" class="headerlink" title="简版对比"></a>简版对比</h4><ul><li>Cookie 数据存放在客户端的浏览器上，Session 数据存放在服务器上</li><li>Session 相对于 Cookie 更安全</li><li>若考虑减轻服务器负担，应当使用 Cookie</li></ul><h4 id="详版对比-1"><a href="#详版对比-1" class="headerlink" title="详版对比"></a>详版对比</h4><p><strong>存储方式</strong></p><ul><li>Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。</li><li>Session可以存储任何类型的数据，可以把Session看成是一个容器</li></ul><p><strong>隐私安全</strong></p><ul><li><strong>Cookie存储在浏览器中，对客户端是可见的</strong>。信息容易泄露出去。如果使用Cookie，最好将Cookie加密</li><li><strong>Session存储在服务器上，对客户端是透明的</strong>。不存在敏感信息泄露问题。</li></ul><p><strong>有效期</strong></p><ul><li>Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的</li><li><strong>Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。</strong></li></ul><p><strong>对服务器的负担</strong></p><ul><li>Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。</li><li>Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。</li></ul><p><strong>浏览器支持</strong></p><ul><li>如果浏览器禁用了Cookie，那么Cookie是无用的了！</li><li>如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。</li></ul><p><strong>跨域名</strong></p><ul><li>Cookie可以设置domain属性来实现跨域名</li><li>Session只在当前的域名内有效，不可跨域名</li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="Tomcat有几种部署方式"><a href="#Tomcat有几种部署方式" class="headerlink" title="Tomcat有几种部署方式"></a>Tomcat有几种部署方式</h3><ol><li>直接把Web项目放在webapps下，Tomcat会自动将其部署</li><li>在server.xml文件上配置<code>&lt;Context&gt;</code>节点，设置相关的属性即可</li><li>通过Catalina来进行配置：进入到confCatalinalocalhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。</li></ol><h3 id="JavaEE中的三层结构和MVC"><a href="#JavaEE中的三层结构和MVC" class="headerlink" title="JavaEE中的三层结构和MVC"></a>JavaEE中的三层结构和MVC</h3><p>做企业应用开发时，经常采用三层架构分层：表示层、业务层、持久层。</p><ul><li>表示层负责接收用户请求、转发请求、显示数据等；</li><li>业务层负责组织业务逻辑；</li><li>持久层负责持久化业务对象。</li></ul><p>这三个分层，每一层都有不同的模式，就是架构模式。表示层最常用的架构模式就是MVC。</p><p>因此，MVC 是三层架构中表示层最常用的架构模式。</p><p>MVC 是客户端的一种设计模式，所以他天然就不考虑数据如何存储的问题。作为客户端，只需要解决用户界面、交互和业务逻辑就好了。在 MVC 模式中，View 负责的是用户界面，Controller 负责交互，Model 负责业务逻辑。至于数据如何存储和读取，当然是由 Model 调用服务端的接口来完成。</p><p>在三层架构中，并没有客户端/服务端的概念，所以表示层、业务层的任务其实和 MVC 没什么区别，而持久层在 MVC 里面是没有的。</p><p>各层次的关系：表现层的控制-&gt;服务层-&gt;数据持久化层。</p><p><img src="/2020/04/22/JAVA-Web/jee-3-ties.bmp" alt="img"></p><h3 id="Tomcat如何创建servlet类实例？"><a href="#Tomcat如何创建servlet类实例？" class="headerlink" title="Tomcat如何创建servlet类实例？"></a>Tomcat如何创建servlet类实例？</h3><ol><li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 <strong>xml文件进行解析，并读取servlet注册信息</strong>。然后，将每个应用中注册的servlet类都进行加载，并通过<strong>反射的方式实例化</strong>。</li><li>在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Concurrency</title>
      <link href="/2020/04/20/JAVA-Concurrency/"/>
      <url>/2020/04/20/JAVA-Concurrency/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java并发学习笔记</p></blockquote><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程是系统进行资源分配的基本单位。每一个进程都有它自己的内存空间和系统资源</strong></p><p>进程的不足在于多处理机环境下的进程调度，分派，切换时，<strong>都需要花费较大的时间和空间开销</strong></p><p>引入线程主要是<strong>为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。</strong>使OS具有更好的并发性</p><ul><li><strong>进程实现多处理</strong>非常耗费CPU的资源，而<strong>引入线程是作为调度的基本单位</strong>（取代进程的部分基本功能<strong>【调度】</strong>）。</li><li>线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并行：</strong></p><ul><li>并行性是指<strong>同一时刻内</strong>（一个时间段）发生两个或多个事件。</li><li>并行是在<strong>不同</strong>实体上的多个事件</li></ul><p><strong>并发：</strong></p><ul><li>并发性是指<strong>同一时间间隔内</strong>发生两个或多个事件。</li><li>并发是在<strong>同一实体</strong>上的多个事件</li></ul><p>由此可见：并行是针对进程的，<strong>并发是针对线程的</strong>。</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li>进程作为资源<strong>分配</strong>的基本单位</li><li>线程作为资源<strong>调度</strong>的基本单位，<strong>是程序的执行单元，执行路径</strong>(单线程：一条执行路径，多线程：多条执行路径)。是程序使用CPU的最基本单位。</li><li><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="/2020/04/20/JAVA-Concurrency/image-20200421094323779.png" alt="image-20200421094323779"></p><h4 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h4><p>创建后尚未启动。</p><h4 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h4><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 运行（Running ） 和 就绪（Ready）。</p><h4 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h4><p>这个状态下，是在多个线程有同步操作的场景，比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是线程在等待进入临界区。</p><p>阻塞可以分为：等待阻塞，同步阻塞，其他阻塞</p><h4 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h4><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><table><thead><tr><th align="left">进入方法</th><th align="left">退出方法</th></tr></thead><tbody><tr><td align="left">没有设置 Timeout 参数的 Object.wait() 方法</td><td align="left">Object.notify() / Object.notifyAll()</td></tr><tr><td align="left">没有设置 Timeout 参数的 Thread.join() 方法</td><td align="left">被调用的线程执行完毕</td></tr><tr><td align="left">LockSupport.park() 方法</td><td align="left">-</td></tr></tbody></table><h4 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h4><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用 “<strong>使一个线程睡眠</strong>” 进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用 “<strong>挂起一个线程</strong>” 进行描述。</p><p><strong>睡眠和挂起</strong>是用来描述<strong>行为</strong>，而<strong>阻塞</strong>和等待用来描述<strong>状态</strong>。</p><p><strong>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</strong></p><table><thead><tr><th align="left">进入方法</th><th align="left">退出方法</th></tr></thead><tbody><tr><td align="left">Thread.sleep() 方法</td><td align="left">时间结束</td></tr><tr><td align="left">设置了 Timeout 参数的 Object.wait() 方法</td><td align="left">时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td align="left">设置了 Timeout 参数的 Thread.join() 方法</td><td align="left">时间结束 / 被调用的线程执行完毕</td></tr><tr><td align="left">LockSupport.parkNanos() 方法</td><td align="left">-</td></tr><tr><td align="left">LockSupport.parkUntil() 方法</td><td align="left">-</td></tr></tbody></table><h4 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h4><ul><li>线程因为 run 方法正常退出而自然死亡</li><li>因为一个没有捕获的异常终止了 run 方法而意外死亡</li></ul><p><img src="/2020/04/20/JAVA-Concurrency/image-20200421110500064.png" alt="image-20200421110500064"></p><p><img src="/2020/04/20/JAVA-Concurrency/image-20200421102640506.png" alt="image-20200421102640506"></p><h3 id="多线程实现方式"><a href="#多线程实现方式" class="headerlink" title="多线程实现方式"></a>多线程实现方式</h3><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>需要实现 run() 方法。</p><p>通过 Thread 调用 start() 方法来启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h4><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h4 id="三种方式的区别"><a href="#三种方式的区别" class="headerlink" title="三种方式的区别"></a>三种方式的区别</h4><ul><li>实现 Runnable 接口可以避免 Java 单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。</li><li>继承 Thread 类和实现 Runnable 方法启动线程都是使用 start() 方法，然后 JVM 虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行 run() 方法。</li><li>实现 Callable 接口要实现 call() 方法，并且线程执行完毕后会有返回值。其他的两种都是重写 run() 方法，没有返回值。</li></ul><h3 id="线程方法介绍"><a href="#线程方法介绍" class="headerlink" title="线程方法介绍"></a>线程方法介绍</h3><h4 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns this thread's name.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  this thread's name.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span>     #setName(String)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myThread.getName();</span></span><br></pre></td></tr></table></figure><h4 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h4><p><strong>isAlive活着的定义是就绪、运行、阻塞状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread is alive;</span></span><br><span class="line"><span class="comment">*          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// myThread.getName();</span></span><br></pre></td></tr></table></figure><h4 id="sleep（当前线程-sleep）"><a href="#sleep（当前线程-sleep）" class="headerlink" title="sleep（当前线程.sleep）"></a>sleep（当前线程.sleep）</h4><p>sleep时持有的锁不会自动释放，sleep时可能会抛出InterruptedException。</p><p> Thread.sleep(long millis) 一定是当前线程调用此方法，当前线程进入TIME_WAIT状态，<strong>但不释放对象锁</strong>，millis后线程自动苏醒进入READY状态。</p><ul><li>作用：给其它线程执行机会的最佳方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">*      the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">*      if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">*      if any thread has interrupted the current thread. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestThread mt = <span class="keyword">new</span> TestThread();</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join（其他线程-join）"><a href="#join（其他线程-join）" class="headerlink" title="join（其他线程.join）"></a>join（其他线程.join）</h4><p><code>t.join()</code>/<code>t.join(long millis)</code> 当前<code>myThread</code>线程里调用<code>otherThread</code>的方法，当前线程进入WAIT状态，<strong>但不释放对象锁</strong>，直到<code>otherThread</code>线程执行完毕或者millis时间到，当前线程进入可运行状态。</p><p> join方法的作用是将分出来的线程合并回去，等待分出来的线程执行完毕后继续执行原有线程。类似于方法调用。（相当于调用thead.run()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this      *    thread to die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait </span></span><br><span class="line"><span class="comment">*    forever.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">*     the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">*     if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">*     if any thread has interrupted the current thread. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// otherThread.join();</span></span><br></pre></td></tr></table></figure><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure><h4 id="yield（当前线程-yield）"><a href="#yield（当前线程-yield）" class="headerlink" title="yield（当前线程.yield）"></a>yield（当前线程.yield）</h4><p><code>myThread.yield()</code>，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。</p><p>作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证<code>yield()</code>达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p>同时<code>myThread.yield()</code>不会使进程进入阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment">* its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="interrupt（其他线程-interrupt）"><a href="#interrupt（其他线程-interrupt）" class="headerlink" title="interrupt（其他线程.interrupt）"></a>interrupt（其他线程.interrupt）</h4><h5 id="函数1-interrupt"><a href="#函数1-interrupt" class="headerlink" title="函数1 interrupt()"></a>函数1 interrupt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interrupts this thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>第11行注释说得很清楚了，<code>interrupt0()</code>方法的作用是”Just to set the interrupt flag”，即方法的作用仅仅是设置中断标识位</li><li>第19行就是<code>interrupt0()</code>方法的原型，由于方法是被<code>native</code>修饰的，很明显这是一个本地方法，是Java虚拟机实现的</li></ul><h5 id="函数2-isInterrupted"><a href="#函数2-isInterrupted" class="headerlink" title="函数2 isInterrupted()"></a>函数2 isInterrupted()</h5><p>方法唯一的作用只是测试线程是否已经中断，中断标识位的状态并不受到该方法的影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tests whether this thread has been interrupted.  </span></span><br><span class="line"><span class="comment">* The &lt;i&gt;interrupted status&lt;/i&gt; of the thread is unaffected by this method.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment">*          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">* is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">* passed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>最终调用的是下面的<code>isInterrupted(boolean ClearInterrupted)</code>，这个方法是一个native的，也是Java虚拟机实现的。方法的参数<code>ClearInterrupted</code>，即清除中断标识位，这里传递false，即不清除</p><h5 id="函数3-interrupted"><a href="#函数3-interrupted" class="headerlink" title="函数3 interrupted()"></a>函数3 interrupted()</h5><p>方法的作用是测试当前线程是否已经中断，线程的中断标识位由该方法清除。换句话说，连续两次调用该方法的返回值必定是false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Tests whether the current thread has been interrupted.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">*          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>interrupted()方法调用的是一个native方法，无非这个方法传入的是true，表示清除中断标识位</p><h5 id="线程在不同状态下对于中断所产生的反应"><a href="#线程在不同状态下对于中断所产生的反应" class="headerlink" title="线程在不同状态下对于中断所产生的反应"></a>线程在不同状态下对于中断所产生的反应</h5><p>NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED（Thread类中有一个State枚举类型列举了线程的所有状态）。</p><h6 id="1、NEW和TERMINATED"><a href="#1、NEW和TERMINATED" class="headerlink" title="1、NEW和TERMINATED"></a>1、NEW和TERMINATED</h6><p>线程的new状态表示还未调用start方法，还未真正启动。线程的terminated状态表示线程已经运行终止。这两个状态下调用中断方法来中断线程的时候，Java认为毫无意义，所以并不会设置线程的中断标识位，什么事也不会发生。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NEW</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(mt.getState());</span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line"></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br><span class="line"><span class="comment">// TERMINATED</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>中断操作对这两种状态下的线程是无效的。</p><h6 id="2、RUNNABLE"><a href="#2、RUNNABLE" class="headerlink" title="2、RUNNABLE"></a>2、RUNNABLE</h6><p>如果线程处于运行状态，那么该线程的状态就是RUNNABLE，但是不一定所有处于RUNNABLE状态的线程都能获得CPU运行，在某个时间段，只能由一个线程占用CPU，那么其余的线程虽然状态是RUNNABLE，但是都没有处于运行状态。测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*先定义一个线程类，让其一直占用CPU运行*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*main函数启动线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    </span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">//等到thread线程被中断之后</span></span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br></pre></td></tr></table></figure><p>我们定义的线程始终循环做一些事情，主线程启动该线程并输出该线程的状态，然后调用中断方法中断该线程并再次输出该线程的状态。</p><p>可以看到在我们启动线程之后，线程状态变为RUNNABLE，中断操作后标记中断标志，但是再次输出线程状态的时候，线程仍然处于RUNNABLE状态。</p><ul><li>解释：</li><li>处于RUNNBALE状态下的线程即便遇到中断操作，也只会设置中断标志位并不会实际中断线程运行。</li><li>为什么？</li><li>这里其实Java将这种权力交给了我们的程序，Java给我们提供了一个中断标志位，我们的程序可以通过if判断中断标志位是否被设置来中断我们的程序而不是系统强制的中断。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*修改MyThread类的run方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">"exit MyThread"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程一旦发现自己的中断标志为被设置了，立马跳出死循环。这样的设计好处就在于给了我们程序更大的灵活性。</p><h6 id="3、BLOCKED"><a href="#3、BLOCKED" class="headerlink" title="3、BLOCKED"></a>3、BLOCKED</h6><p>当线程处于BLOCKED状态说明该线程由于竞争某个对象的锁失败而被挂在了该对象的阻塞队列上了。那么此时发起中断操作不会对该线程产生任何影响，依然只是设置中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*自定义线程类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们自定义了一个线程类，run方法中主要就做一件事情，调用一个有锁的静态方法，该方法内部是一个死循环（占用该锁让其他线程阻塞）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(thread1.getState());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line"></span><br><span class="line">    thread2.interrupt();</span><br><span class="line">    System.out.println(thread2.isInterrupted());</span><br><span class="line">    System.out.println(thread2.getState());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br><span class="line"><span class="comment">// BLOCKED</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// BLOCKED</span></span><br></pre></td></tr></table></figure><p>在我们的主线程中，我们定义了两个线程并按照定义顺序启动他们，显然thread1启动后便占用MyThread类锁，此后thread2在获取锁的时候一定失败，自然被阻塞在阻塞队列上。</p><p>从输出结果看来，thread2处于BLOCKED状态，执行中断操作之后，该线程仍然处于BLOCKED状态，但是中断标志位却已被修改。这种状态下的线程和处于RUNNABLE状态下的线程是类似的，给了我们程序更大的灵活性去判断和处理中断。</p><h6 id="4、WAITING-TIMED-WAITING"><a href="#4、WAITING-TIMED-WAITING" class="headerlink" title="4、WAITING/TIMED_WAITING"></a>4、WAITING/TIMED_WAITING</h6><p>这两种状态本质上是同一种状态，只不过TIMED_WAITING在等待一段时间后会自动释放自己，而WAITING则是无限期等待，需要其他线程调用notify方法释放自己。但是他们都是线程在运行的过程中由于缺少某些条件而被挂起在某个对象的等待队列上。当这些线程遇到中断操作的时候，会抛出一个InterruptedException异常，并清空中断标志位。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义一个线程类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"i am waiting but facing interruptexception now"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了一个线程类，其中run方法让当前线程阻塞到条件队列上，并且针对InterruptedException 进行捕获，如果遇到InterruptedException 异常则输出一行信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*main函数启动该线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(thread.getState());</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(thread.isInterrupted());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// WAITING</span></span><br><span class="line"><span class="comment">// i am waiting but facing interruptexception now</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在main线程中我们启动一个MyThread线程，然后对其进行中断操作。</p><p>从运行结果看，当前程thread启动之后就被挂起到该线程对象的条件队列上，然后我们调用interrupt方法对该线程进行中断，输出了我们在catch中的输出语句，显然是捕获了InterruptedException异常，接着就看到该线程的中断标志位被清空。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>当线程调用中断函数<code>interrupt()</code>后，只是设置中断标志位并没有强制终止线程，对于线程的终止权利依然在程序手中。</p><p>对于sleep、wait、notify、join，这些会抛出InterruptedException的方法在遇到<code>interrupt()</code>函数执行时，会执行捕获InterruptedException异常的处理方式，完成后及那个中断标识位清除。</p><p>这些方法之所以会抛出InterruptedException就是由于Java虚拟机在实现这些方法的时候，本身就有某种机制在判断中断标识位，如果中断了，就抛出一个InterruptedException。所以，可以认为：</p><p><strong>interrupt一个其他线程thread时</strong></p><ol><li>如果线程thread中调用了可以抛出InterruptedException的方法，那么会在thread中抛出InterruptedException并清除中断标志位。</li><li>如果thread没有调用此类方法，那么会正常地将设置中断标志位。</li></ol><p><strong>具体来看：</strong></p><ul><li><p>如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会清除线程的中断状态，并抛出InterruptedException;</p></li><li><p>如果线程堵塞在java.nio.channels.InterruptibleChannel的IO上，Channel将会被关闭，线程被置为中断状态，并抛出java.nio.channels.ClosedByInterruptException；</p></li><li><p>如果线程堵塞在java.nio.channels.Selector上，线程被置为中断状态，select方法会马上返回，类似调用wakeup的效果；</p></li><li><p>如果不是以上三种情况，thread.interrupt()方法仅仅是设置线程的中断状态为true。</p></li></ul><p><strong>如何停止线程？</strong></p><ul><li>使用标志位终止线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//volatile修饰符用来保证其它线程读取的总是该变量的最新的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(!exit)&#123;</span><br><span class="line">            serverSocket.accept(); <span class="comment">//阻塞等待客户端消息</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread t = <span class="keyword">new</span> TestThread();</span><br><span class="line">        t.start();</span><br><span class="line">        ...</span><br><span class="line">        t.exit = <span class="keyword">true</span>; <span class="comment">//修改标志位，退出线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 interrupt() 中断线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InterruptThread t = <span class="keyword">new</span> InterruptThread();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是否被中断</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="comment">//处理中断逻辑</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果线程中有阻塞操作，在阻塞时是无法去检测中断标志位或自定义标志位的，只能使用<code>interrupt()</code>方法才能中断线程，并且在线程停止前关闭引起阻塞的资源（比如Socket）。</p><h3 id="objects线程方法"><a href="#objects线程方法" class="headerlink" title="objects线程方法"></a>objects线程方法</h3><h4 id="wait（对象-wait）"><a href="#wait（对象-wait）" class="headerlink" title="wait（对象.wait）"></a>wait（对象.wait）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><ul><li>调用obj的<code>wait()</code>， <code>notify()</code>方法前，必须获得obj锁，也就是必须写在<code>synchronized(obj)</code>代码段内。</li><li><code>obj.wait()</code>，当前线程调用对象的<code>wait()</code>方法，<strong>当前线程释放对象锁</strong>，进入等待队列。依靠<code>notify()</code>/<code>notifyAll()</code>唤醒或者<code>wait(long timeout)</code>，timeout时间到自动唤醒。</li></ul><h4 id="notify（对象-notify）"><a href="#notify（对象-notify）" class="headerlink" title="notify（对象.notify）"></a>notify（对象.notify）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>obj.notify()</code>唤醒在此对象监视器上等待的单个线程，选择是任意性的。<code>notifyAll()</code>唤醒在此对象监视器上等待的所有线程。</p><h4 id="wait-amp-notify-最佳实践"><a href="#wait-amp-notify-最佳实践" class="headerlink" title="wait&amp;notify 最佳实践"></a>wait&amp;notify 最佳实践</h4><p>等待方（消费者）和通知方（生产者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">等待方：</span><br><span class="line">    <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    消费;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通知方：</span><br><span class="line">    synchonized(obj)&#123;</span><br><span class="line">    改变条件;</span><br><span class="line">    obj.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>notify</code>与<code>notifyAll</code>： 由于多个线程可以基于不同的条件在同一个条件队列上等待，因此如果使用<code>notify</code>而不是<code>notifyAll</code>，那么将是一种危险的操作，因为单一的通知很容易导致类似于信号地址（线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词）的问题。</li></ul><p>只有同时满足以下两个条件时，才能用单一的notify而不是notifyAll：</p><ul><li>所有等待线程的类型都相同，且每个线程在从wait返回后将执行相同的操作。</li><li>单进单出：在对象状态上的每次改变，最多只能唤醒一个线程来执行。</li></ul><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在<strong>同步方法</strong>或者<strong>同步控制块</strong>中使用！否则会在运行时抛出 IllegalMonitorStateExeception。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// after</span></span><br></pre></td></tr></table></figure><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><ul><li><p>synchronized是一种<strong>互斥锁</strong></p><ul><li><strong>一次只能允许一个线程进入被锁住的代码块</strong></li></ul></li><li><p>synchronized是一种<strong>内置锁/监视器锁</strong></p><ul><li>Java中<strong>每个对象</strong>都有一个<strong>内置锁(监视器,也可以理解成锁标记)</strong>，而synchronized就是使用<strong>对象的内置锁(监视器)</strong>来将代码块(方法)锁定的！</li></ul></li><li><p>synchronized保证了线程的<strong>原子性</strong>。(被保护的代码块是一次被执行的，没有任何线程会同时访问)</p></li><li><p>synchronized还保证了<strong>可见性</strong>。(当执行完synchronized之后，修改后的变量对其他的线程是可见的)</p></li></ul><p>总的来说，Java中的synchronized，通过使用内置锁，来实现对变量的同步操作，进而实现了<strong>对变量操作的原子性和其他线程对变量的可见性</strong>，从而确保了并发情况下的线程安全。</p><h5 id="1-同步一个代码块"><a href="#1-同步一个代码块" class="headerlink" title="1. 同步一个代码块"></a>1. 同步一个代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2. 同步一个方法"></a>2. 同步一个方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它和同步代码块一样，作用于同一个对象。</p><h5 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3. 同步一个类"></a>3. 同步一个类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h5 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4. 同步一个静态方法"></a>4. 同步一个静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于整个类。</p><h5 id="synchronized锁的释放"><a href="#synchronized锁的释放" class="headerlink" title="synchronized锁的释放"></a>synchronized锁的释放</h5><ol><li>当方法(代码块)执行完毕后会<strong>自动释放锁</strong>，不需要做任何的操作。</li><li><strong>当一个线程执行的代码出现异常时，其所持有的锁会自动释放</strong>。<ul><li>不会由于异常导致出现死锁现象~</li></ul></li></ol><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>相比于 synchronized，它多了以下高级功能：</p><ol><li>等待可中断</li></ol><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><ol start="2"><li>可实现公平锁</li></ol><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p><ol start="3"><li>锁绑定多个条件</li></ol><p>一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><h5 id="1-锁的实现"><a href="#1-锁的实现" class="headerlink" title="1. 锁的实现"></a>1. 锁的实现</h5><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><h5 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h5><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><h5 id="3-等待可中断"><a href="#3-等待可中断" class="headerlink" title="3. 等待可中断"></a>3. 等待可中断</h5><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><h5 id="4-公平锁"><a href="#4-公平锁" class="headerlink" title="4. 公平锁"></a>4. 公平锁</h5><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><h5 id="5-锁绑定多个条件"><a href="#5-锁绑定多个条件" class="headerlink" title="5. 锁绑定多个条件"></a>5. 锁绑定多个条件</h5><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h5 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h5><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>这里称为乐观锁：</p><h4 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h4><blockquote><p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p></blockquote><h5 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h5><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子：</strong> 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h5 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h5><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><p>关于自旋锁，大家可以看一下这篇文章，非常不错：<a href="https://blog.csdn.net/qq_34337272/article/details/81252853" target="_blank" rel="noopener">《 面试必备之深入理解自旋锁》</a></p><h4 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h4><blockquote><p>ABA 问题是乐观锁一个常见的问题</p></blockquote><h5 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h5><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p><p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h5 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h5><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h5 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h5><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p><p>参考链接：<a href="https://snailclimb.top/JavaGuide/#/./essential-content-for-interview/面试必备之乐观锁与悲观锁?id=何谓悲观锁与乐观锁" target="_blank" rel="noopener">悲观锁乐观锁</a></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>非阻塞队列：当队列中满了时候，放入数据，数据丢失</p><p>阻塞队列：当队列满了的时候，进行等待，什么时候队列中有出队的数据，那么第11个再放进去</p><p><strong>出队</strong></p><p>非阻塞队列：如果现在队列中没有元素，取元素，得到的是null</p><p>阻塞队列：等待，什么时候放进去，再取出来</p><p>线程池使用的是阻塞队列</p><h3 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h3><p>线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，合理的使用线程池对线程进行统一分配、调优和监控，有以下好处：</p><ol><li>降低资源消耗；</li><li>提高响应速度；</li><li>提高线程的可管理性。</li></ol><p>Java1.5 中引入的 Executor 框架把任务的提交和执行进行解耦，只需要定义好任务，然后提交给线程池，而不用关心该任务是如何执行、被哪个线程执行，以及什么时候执行。</p><h3 id="Executor类图"><a href="#Executor类图" class="headerlink" title="Executor类图"></a>Executor类图</h3><p><img src="/2020/04/20/JAVA-Concurrency/820628cf179f4952812da4e8ca5de672.png" alt="img"></p><h3 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h3><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；直到线程池中的线程数达到 maxPoolSize，这时再有任务来，只能执行 reject() 处理该任务。</p><h3 id="初始化线程池"><a href="#初始化线程池" class="headerlink" title="初始化线程池"></a>初始化线程池</h3><ul><li><strong>newFixedThreadPool()</strong> 说明：<strong>初始化一个指定线程数的线程池</strong>，其中 corePoolSize == maxiPoolSize，使用 LinkedBlockingQuene 作为阻塞队列 特点：即使当线程池没有可执行任务时，也不会释放线程。</li><li><strong>newCachedThreadPool()</strong> 说明：<strong>初始化一个可以缓存线程的线程池</strong>，默认缓存60s，线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列； 特点：在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源；当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 因此，使用时要注意控制并发的任务数，防止因创建大量的线程导致而降低性能。</li><li><strong>newSingleThreadExecutor()</strong> 说明：<strong>初始化只有一个线程的线程池</strong>，内部使用 LinkedBlockingQueue 作为阻塞队列。 特点：如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行</li><li><strong>newScheduledThreadPool()</strong> 特点：初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据。</li></ul><h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Executors静态方法进行初始化</span></span><br><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">service.execute(<span class="keyword">new</span> Thread());</span><br><span class="line">service.submit(<span class="keyword">new</span> Thread());</span><br><span class="line">service.shutDown();</span><br><span class="line">service.shutDownNow();</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="execute与submit"><a href="#execute与submit" class="headerlink" title="execute与submit"></a>execute与submit</h4><ol><li><p>接收的参数不一样</p></li><li><p>submit有返回值，而execute没有</p><p>用到返回值的例子，比如说我有很多个做 validation 的 task，我希望所有的 task 执行完，然后每个 task 告诉我它的执行结果，是成功还是失败，如果是失败，原因是什么。然后我就可以把所有失败的原因综合起来发给调用者。</p></li><li><p>submit方便Exception处理</p><p>如果你在你的 task 里会抛出 checked 或者 unchecked exception，而你又希望外面的调用者能够感知这些 exception 并做出及时的处理，那么就需要用到 submit，通过捕获 Future.get 抛出的异常。</p></li></ol><h4 id="shutDown与shutDownNow"><a href="#shutDown与shutDownNow" class="headerlink" title="shutDown与shutDownNow"></a>shutDown与shutDownNow</h4><p>当线程池调用该方法时，线程池的状态则立刻变成 SHUTDOWN 状态。此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><h4 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h4><ul><li>入队<ul><li>非阻塞队列：当队列中满了时候，放入数据，数据丢失</li><li>阻塞队列：当队列满了的时候，进行等待，什么时候队列中有出队的数据，那么第11个再放进去</li></ul></li><li>出队<ul><li>非阻塞队列：如果现在队列中没有元素，取元素，得到的是null</li><li>阻塞队列：等待，什么时候放进去，再取出来</li></ul></li></ul><p><strong>线程池使用的是阻塞队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,     // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,  // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,   // 线程存活时间（在 corePore&lt;*&lt;maxPoolSize 情况下有用）</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,        // 存活时间的时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue    // 阻塞队列（用来保存等待被执行的任务）</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,    // 线程工厂，主要用来创建线程；</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler // 当拒绝处理任务时的策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 workQueue 参数，有四种队列可供选择：</p><ul><li>ArrayBlockingQueue：基于数组结构的有界阻塞队列，按 FIFO 排序任务；</li><li>LinkedBlockingQuene：基于链表结构的阻塞队列，按 FIFO 排序任务；</li><li>SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 ArrayBlockingQuene；</li><li>PriorityBlockingQuene：具有优先级的无界阻塞队列；</li></ul><p>关于 handler 参数，线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：</p><ul><li>ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><p>当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));Click to copy</span><br></pre></td></tr></table></figure><p>其中 AtomicInteger 变量 ctl 的功能非常强大：利用低 29 位表示线程池中线程数，通过高 3 位表示线程池的运行状态：</p><ul><li><strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高 3 位为 111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</li><li><strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高 3 位为 000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li><strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高 3 位为 001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li><strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高 3 位为 010，该状态表示线程池对线程进行整理优化；</li><li><strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高 3 位为 011，该状态表示线程池停止工作；</li></ul><h3 id="为什么引入Executor线程池"><a href="#为什么引入Executor线程池" class="headerlink" title="为什么引入Executor线程池"></a>为什么引入Executor线程池</h3><p>new Thread() 的缺点</p><ul><li>每次 new Thread() 耗费性能</li><li>调用 new Thread() 创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。</li><li>不利于扩展，比如如定时执行、定期执行、线程中断</li></ul><p>采用线程池的优点</p><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li><li>提供定时执行、定期执行、单线程、并发数控制等功能</li></ul><h3 id="Executor-中断"><a href="#Executor-中断" class="headerlink" title="Executor  中断"></a>Executor  中断</h3><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="number">0</span>(ExecutorInterruptExample.java:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ul><li>synchronized 同步</li><li>while 轮询的方式</li><li>join()：是当前线程进入WAIT状态，但不释放对象锁，直到执行该方法线程执行完毕或者millis时间到，原先线程再进入可运行状态。</li><li>wait()：使一个线程处于等待状态，并且释放所持有的对象的 lock。 </li><li>sleep()：使一个 正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException 异常。 </li><li>notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。 </li><li>notityAll()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</li><li>CountdownLatch 类：用来控制一个或者多个线程等待多个线程。</li><li>CyclicBarrier 类：用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</li><li>Semaphore 类：似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</li><li>Callable 接口：有返回值</li></ul><h3 id="如何让两个线程依次执行"><a href="#如何让两个线程依次执行" class="headerlink" title="如何让两个线程依次执行"></a>如何让两个线程依次执行</h3><p>假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            printNumber(<span class="string">"A"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);    </span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">            printNumber(<span class="string">"B"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);    </span><br><span class="line">    A.start();    </span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">乱序同时打印</span><br></pre></td></tr></table></figure><p>其中的 <code>printNumber(String)</code> 实现如下，用来依次打印 <code>1</code>, <code>2</code>, <code>3</code> 三个数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(String threadName)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">3</span>) &#123; </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        try &#123;            </span></span><br><span class="line"><span class="comment">            Thread.sleep(100);        </span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;            </span></span><br><span class="line"><span class="comment">            e.printStackTrace();        </span></span><br><span class="line"><span class="comment">        &#125;*/</span>        </span><br><span class="line">        System.out.println(threadName + <span class="string">" print: "</span> + i);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果两者是同时打印的，目标：让A打印完后B再打印，方法：是使用 join 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printNumber(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 开始等待 A"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                A.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            printNumber(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    B.start();</span><br><span class="line">    A.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">B 开始等待 A</span><br><span class="line">A print: <span class="number">1</span></span><br><span class="line">A print: <span class="number">2</span></span><br><span class="line">A print: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">B print: <span class="number">1</span></span><br><span class="line">B print: <span class="number">2</span></span><br><span class="line">B print: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>A.join</code> 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的 join() 方法，直到线程A执行完毕后，才会继续执行线程B。</p><ul><li>t.join(); 调用 join 方法，等待线程 t 执行完毕</li><li>t.join(1000); 等待 t 线程，等待时间是1000毫秒。</li></ul><p>所以能看到 <code>A.join()</code> 方法会让 B 一直等待直到 A 运行完毕。</p><h3 id="如何让两个线程有序交叉运行"><a href="#如何让两个线程有序交叉运行" class="headerlink" title="如何让两个线程有序交叉运行"></a>如何让两个线程有序交叉运行</h3><p>还是上面那个例子，我现在希望 A 在打印完 <code>1</code> 后，再让 B 打印 <code>1</code>, <code>2</code>, <code>3</code>，最后再回到 A 继续打印 <code>2</code>, <code>3</code>。这种需求下，显然 <code>Thread.join()</code> 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。</p><p>这里，我们可以利用 <code>object.wait()</code> 和 <code>object.notify()</code> 两个方法来实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 1, B 1, B 2, B 3, A 2, A 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A 1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"A 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"B 1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 3"</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先创建一个 A 和 B 共享的对象锁 lock = new Object();</span><br><span class="line">当 A 得到锁后，先打印 1，然后调用 lock.wait() 方法，交出锁的控制权，进入 wait 状态；</span><br><span class="line">对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 lock.wait() 释放控制权后， B 才得到了锁；</span><br><span class="line">B 在得到锁后打印 1， 2， 3；然后调用 lock.notify() 方法，唤醒正在 wait 的 A;</span><br><span class="line">A 被唤醒后，继续打印剩下的 2，3。</span><br></pre></td></tr></table></figure><h3 id="计数器（run-D-After-A-B-C）"><a href="#计数器（run-D-After-A-B-C）" class="headerlink" title="计数器（run D After A B C）"></a>计数器（run D After A B C）</h3><blockquote><p> A B C D四个线程，D 等其他全执行完毕再执行，且 A B C 同步运行</p></blockquote><p>目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要 A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 <code>CountdownLatch</code> 来实现这类通信方式。它的基本用法是：</p><ol><li>创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);</li><li>在 <code>等待线程</code>里调用 <code>countDownLatch.await()</code> 方法，进入等待状态，直到计数值变成 0；</li><li>在 <code>其他线程</code>里，调用 <code>countDownLatch.countDown()</code> 方法，该方法会将计数值减小 1；</li><li>当 <code>其他线程</code>的 <code>countDown()</code> 方法把计数值变成 0 时，<code>等待线程</code> 里的 <code>countDownLatch.await()</code> 立即退出，继续执行后面的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runDAfterABC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> worker = <span class="number">3</span>;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(worker);</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"D is waiting for other three threads"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"All done, D starts working"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> threadName=<span class="string">'A'</span>; threadName &lt;= <span class="string">'C'</span>; threadName++) &#123;</span><br><span class="line">        <span class="keyword">final</span> String tN = String.valueOf(threadName);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(tN + <span class="string">" is working"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(tN + <span class="string">" finished"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">D is waiting <span class="keyword">for</span> other three threads</span><br><span class="line">A is working</span><br><span class="line">B is working</span><br><span class="line">C is working</span><br><span class="line">B finished</span><br><span class="line">A finished</span><br><span class="line">C finished</span><br><span class="line">All done, D starts working</span><br></pre></td></tr></table></figure><p>其实简单点来说，<code>CountDownLatch</code> 就是一个倒计数器，我们把初始计数值设置为<code>3</code>，当 <code>D</code> 运行时，先调用 <code>countDownLatch.await()</code> 检查计数器值是否为 <code>0</code>，若不为 <code>0</code> 则保持等待状态；当<code>A</code> <code>B</code> <code>C</code> 各自运行完后都会利用<code>countDownLatch.countDown()</code>，将倒计数器减 <code>1</code>，当三个都运行完后，计数器被减至 <code>0</code>；此时立即触发 <code>D</code> 的 <code>await()</code> 运行结束，继续向下执行。</p><p>因此，<code>CountDownLatch</code> 适用于一个线程去等待多个线程的情况。</p><h3 id="栅栏（run-ABC-When-All-Ready）"><a href="#栅栏（run-ABC-When-All-Ready）" class="headerlink" title="栅栏（run ABC When All Ready）"></a>栅栏（run ABC When All Ready）</h3><p>上面的 <code>CountDownLatch</code> 可以用来倒计数，但当计数完毕，只有一个线程的 <code>await()</code> 会得到响应，无法让多个线程同时触发。</p><p>为了实现线程间互相等待这种需求，我们可以利用 <code>CyclicBarrier</code> 数据结构，它的基本用法是：</p><ol><li>先创建一个公共 <code>CyclicBarrier</code> 对象，设置 <code>同时等待</code>的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</li><li>这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 <code>cyclicBarrier.await();</code> 即可开始等待别人；</li><li>当指定的 <code>同时等待</code>的线程数都调用了 <code>cyclicBarrier.await();</code>时，意味着这些线程都准备完毕好，然后这些线程才 <code>同时继续执行</code>。</li></ol><p>实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runABCWhenAllReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runner = <span class="number">3</span>;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(runner);</span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> runnerName=<span class="string">'A'</span>; runnerName &lt;= <span class="string">'C'</span>; runnerName++) &#123;</span><br><span class="line">        <span class="keyword">final</span> String rN = String.valueOf(runnerName);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> prepareTime = random.nextInt(<span class="number">10000</span>) + <span class="number">100</span>;</span><br><span class="line">                System.out.println(rN + <span class="string">" is preparing for time: "</span> + prepareTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(prepareTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(rN + <span class="string">" is prepared, waiting for others"</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 当前运动员准备完毕，等待别人准备好</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(rN + <span class="string">" starts running"</span>); <span class="comment">// 所有运动员都准备好了，一起开始跑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">A is preparing <span class="keyword">for</span> time: <span class="number">1177</span></span><br><span class="line">C is preparing <span class="keyword">for</span> time: <span class="number">5944</span></span><br><span class="line">B is preparing <span class="keyword">for</span> time: <span class="number">1196</span></span><br><span class="line">A is prepared, waiting <span class="keyword">for</span> others</span><br><span class="line">B is prepared, waiting <span class="keyword">for</span> others</span><br><span class="line">C is prepared, waiting <span class="keyword">for</span> others</span><br><span class="line">C starts running</span><br><span class="line">A starts running</span><br><span class="line">B starts running</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>Semaphore 就是操作系统中的信号量，可以控制对互斥资源的访问线程数。Semaphore 可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>假若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">8</span>;            <span class="comment">//工人数        </span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目       </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) <span class="keyword">new</span> Worker(i, semaphore).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"工人"</span> + <span class="keyword">this</span>.num + <span class="string">"释放出机器"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">工人<span class="number">0</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">1</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">2</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">5</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">0</span>释放出机器</span><br><span class="line">工人<span class="number">2</span>释放出机器</span><br><span class="line">工人<span class="number">3</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">7</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">4</span>释放出机器</span><br><span class="line">工人<span class="number">5</span>释放出机器</span><br><span class="line">工人<span class="number">1</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>占用一个机器在生产...</span><br><span class="line">工人<span class="number">3</span>释放出机器</span><br><span class="line">工人<span class="number">7</span>释放出机器</span><br><span class="line">工人<span class="number">6</span>释放出机器</span><br></pre></td></tr></table></figure><h3 id="返回值通知（do-Task-With-Result-In-Worker）"><a href="#返回值通知（do-Task-With-Result-In-Worker）" class="headerlink" title="返回值通知（do Task With Result In Worker）"></a>返回值通知（do Task With Result In Worker）</h3><p>子线程完成某件任务后，把结果回传给主线程。回顾线程的创建，我们一般会把 <code>Runnable</code> 对象传给 Thread 去执行。<code>Runnable</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>run()</code> 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 <code>Callable</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>Callable</code> 最大区别就是返回范型 <code>V</code> 结果。</p><p>那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：<code>FutureTask</code>，不过注意，它获取结果的 <code>get</code> 方法会阻塞主线程。</p><p>举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTaskWithResultInWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Task starts"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Task finished and return result"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Before futureTask.get()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Result: "</span> + futureTask.get());</span><br><span class="line">        System.out.println(<span class="string">"After futureTask.get()"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Before futureTask.get()</span><br><span class="line"></span><br><span class="line">Task starts</span><br><span class="line">Task finished and <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">Result: <span class="number">5050</span></span><br><span class="line">After futureTask.get()</span><br></pre></td></tr></table></figure><p>可以看到，主线程调用 <code>futureTask.get()</code> 方法时阻塞主线程；然后 <code>Callable</code> 内部开始执行，并返回运算结果；此时 <code>futureTask.get()</code> 得到结果，主线程恢复运行。</p><p>这里我们可以学到，通过 <code>FutureTask</code> 和 <code>Callable</code> 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 <code>ExecutorService</code>，把 <code>FutureTask</code> 放到线程池去管理执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTaskWithResultInWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Task starts"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Task finished and return result"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Before futureTask.get(). ThreadName: "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Result: "</span> + get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"After futureTask.get()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executor.submit(futureTask);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"End of main thread. ThreadName: "</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Task starts</span><br><span class="line">End of main thread. ThreadName: main</span><br><span class="line">Task finished and <span class="keyword">return</span> result</span><br><span class="line">Before futureTask.get(). ThreadName: pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Result: <span class="number">5050</span></span><br><span class="line">After futureTask.get()</span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="[http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/](http://wingjay.com/2017/04/09/Java里如何实现线程间通信？/)">参考链接</a></li><li><a href="https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java" target="_blank" rel="noopener">Github</a></li></ul></blockquote><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>JMM（java内存模型） 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或则规范，通过这组规范定义了程序中的访问方式。</li><li>JMM 同步规定<ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ul></li></ul><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p><img src="/2020/04/20/JAVA-Concurrency/1195582-20180508173147029-1341787720.png" alt="img"></p><p>所有的变量都存储在<strong>主内存</strong>中，每个线程还有自己的<strong>工作内存</strong>，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><blockquote><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p></blockquote><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><strong>Java内存模型抽象结构图</strong></p><p><img src="https://frank-lam.github.io/fullstack-tutorial/assets/1135283-20170403195814660-1521573510.png" alt="img"></p><h3 id="内存指令"><a href="#内存指令" class="headerlink" title="内存指令"></a>内存指令</h3><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="https://frank-lam.github.io/fullstack-tutorial/assets/536c6dfd-305a-4b95-b12c-28ca5e8aa043.png" alt="img"></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量，把一个变量标识为一条线程独占状态</li><li>unlock：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行 read 和 load 操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行 store 和 write 操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是 read 和 load 之间，store 和 write 之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。</p><h3 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h4><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h3 id="交互操作"><a href="#交互操作" class="headerlink" title="交互操作"></a>交互操作</h3><ul><li>JVM 运行程序的实体是线程，</li><li>工作内存是每个线程的私有数据区域，</li><li>主内存是所有变量的储存区域，所有的线程都可以访问，</li><li>线程对变量的操作（读取赋值等）必须都工作内存进行。</li></ul><p>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h4 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁/不可重入锁"></a>可重入锁/不可重入锁</h4><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Java多线程的 wait() 方法和 notify() 方法。<br>这两个方法是成对出现和使用的，要执行这两个方法，有一个前提就是，当前线程必须获其对象的monitor（俗称“锁”），否则会抛出 IllegalMonitorStateException 异常，所以这两个方法必须在同步块代码里面调用。</p><ul><li>wait()：阻塞当前线程</li><li>notify()：唤起被wait()阻塞的线程</li></ul><h4 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h4><p>所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。我们尝试设计一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isLocked)&#123;    </span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程执行print()方法首先获取lock，接下来执行doAdd()方法就无法执行doAdd()中的逻辑，必须先释放锁。这个例子很好的说明了不可重入锁。</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>接下来，我们设计一种可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    Thread  lockedBy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(isLocked &amp;&amp; lockedBy != thread)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockedCount++;</span><br><span class="line">        lockedBy = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread() == <span class="keyword">this</span>.lockedBy)&#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            <span class="keyword">if</span>(lockedCount == <span class="number">0</span>)&#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓可重入，意味着线程可以进入它已经拥有的锁的同步代码块儿。</p><p>我们设计两个线程调用 print() 方法，第一个线程调用 print() 方法获取锁，进入 lock() 方法，由于初始 lockedBy 是 null，所以不会进入 while 而挂起当前线程，而是是增量 lockedCount 并记录 lockBy 为第一个线程。接着第一个线程进入 doAdd() 方法，由于同一进程，所以不会进入 while 而挂起，接着增量 lockedCount，当第二个线程尝试lock，由于 isLocked=true，所以他不会获取该锁，直到第一个线程调用两次 unlock() 将 lockCount 递减为0，才将标记为 isLocked 设置为 false。</p><p>可重入锁的概念和设计思想大体如此，Java 中的可重入锁 ReentrantLock 设计思路也是这样。</p><h4 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h4><p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p><p>对于Java <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。</p><ul><li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li><li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li></ul><p>对于<code>Synchronized</code>而言，当然是独享锁。</p><h4 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h4><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><ul><li>互斥锁在Java中的具体实现就是<code>ReentrantLock</code></li><li>读写锁在Java中的具体实现就是<code>ReadWriteLock</code></li></ul><h4 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h4><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><ul><li>悲观锁在Java中的使用，就是利用各种锁。</li><li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li></ul><p><img src="/2020/04/20/JAVA-Concurrency/v2-e52179342a2735c58d2092a234bfe586_hd.jpg" alt="img"></p><h5 id="CAS的原理"><a href="#CAS的原理" class="headerlink" title="CAS的原理"></a>CAS的原理</h5><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>整个“比较+更新”操作封装在compareAndSwapInt()中。通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。</p><p>问题：</p><table><thead><tr><th>问题</th><th align="center">问题原理</th><th align="center">解决方法</th></tr></thead><tbody><tr><td>ABA</td><td align="center">内存值由A，变为B，又变成A，那么CAS检查时会发现值没有变化，但实际上是有变化的。</td><td align="center">在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</td></tr><tr><td>循环时间长开销大</td><td align="center">长时间不成功，会导致其一直自旋</td><td align="center">类似自适应自旋</td></tr><tr><td>只能保证一个共享变量的原子操作</td><td align="center">CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的</td><td align="center">AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作</td></tr></tbody></table><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p><p><img src="/2020/04/20/JAVA-Concurrency/v2-a8f348b241cff06fe76751931bd27106_hd.jpg" alt="img"></p><p>如果锁的粒度小，那么<strong>锁的持有时间比较短</strong>（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：</p><ul><li>当前线程竞争锁失败时，打算阻塞自己</li><li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li><li>在自旋的同时重新竞争锁</li><li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li></ul><p>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。</p><p>“锁的持有时间比较短“这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在<strong>锁持有时间长，但竞争不激烈</strong>的场景中。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="/2020/04/20/JAVA-Concurrency/1568776461627.png" alt="1568776461627"></p><p>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="noopener">自旋锁的实现</a></p><h4 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁/偏向锁/轻量级锁/重量级锁"></a>无锁/偏向锁/轻量级锁/重量级锁</h4><p>这四种锁是指锁的状态，专门针对synchronized的。</p><p><img src="/2020/04/20/JAVA-Concurrency/1568776678399.png" alt="1568776678399"></p><p><img src="/2020/04/20/JAVA-Concurrency/1568776727351.png" alt="1568776727351"></p><p><img src="/2020/04/20/JAVA-Concurrency/1568776780005.png" alt="1568776780005"></p><h5 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h5><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中 CAS 操作记录线程ID（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，锁状态为偏向锁，以后只检测Mark Word里是否存储着指向当前线程的偏向锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，持有偏向锁的线程就会释放锁，就破坏了偏向锁的假定。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li><li>重量级锁：有实际竞争，且锁竞争时间长。</li></ul><p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p><p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>自旋锁时属于不可重入锁；<code>ReentrantLock</code> 和<code>synchronized</code> 都是可重入锁；</li><li>synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()/notify() 都是阻塞锁；</li><li>偏向锁、轻量级锁和重量级锁都表示锁的状态。</li></ul><p>[<img src="http://blog.cuzz.site/2019/02/13/Java%20%E4%B8%AD%E7%9A%84%E9%94%81/4491294-e3bcefb2bacea224.png" alt="锁分配和膨胀过程">](<a href="http://blog.cuzz.site/2019/02/13/Java" target="_blank" rel="noopener">http://blog.cuzz.site/2019/02/13/Java</a> 中的锁/4491294-e3bcefb2bacea224.png)</p><blockquote><ul><li>[参考链接]([<a href="http://blog.cuzz.site/2019/02/13/Java%20%E4%B8%AD%E7%9A%84%E9%94%81/]" target="_blank" rel="noopener">http://blog.cuzz.site/2019/02/13/Java%20%E4%B8%AD%E7%9A%84%E9%94%81/]</a>(<a href="http://blog.cuzz.site/2019/02/13/Java" target="_blank" rel="noopener">http://blog.cuzz.site/2019/02/13/Java</a> 中的锁/))</li><li><a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">参考链接</a></li><li><a href="https://blog.csdn.net/qq_33404395/article/details/88896602" target="_blank" rel="noopener">参考链接</a></li></ul></blockquote><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>是 Java 虚拟机提供的轻量级的同步机制</p><ul><li>保证可见性</li><li>禁止指令排序</li><li>不保证原子性</li></ul><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li>可见性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data.addOne();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" updated..."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data.a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// looping</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" job is done..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新线程修改a值后，可通知main线程，即可见性</span></span><br></pre></td></tr></table></figure><p>如果不加 volatile 关键字，则主线程会进入死循环，加 volatile 则主线程能够退出，说明加了 volatile 关键字变量，当有一个线程修改了值，会马上被另一个线程感知到，当前值作废，从新从主内存中获取值。对其他线程可见，这就叫可见性。</p><ul><li>原子性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test01();</span></span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    data.addOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认有 main 线程和 gc 线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并不能输入 20000</p><ul><li>禁止指令排序</li></ul><p>volatile 实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象</p><p>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，他的作用有两个：</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0e75180bf35c40e2921493d0bf6bd684_th.png" alt="0e75180bf35c40e2921493d0bf6bd684_th"></p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21ebc7e8190c4966948c4ef4424088be_th.png" alt="21ebc7e8190c4966948c4ef4424088be_th"></p><h4 id="线程安全性保证"><a href="#线程安全性保证" class="headerlink" title="线程安全性保证"></a>线程安全性保证</h4><ul><li>工作内存与主内存同步延迟现象导致可见性问题<ul><li>可以使用 synchronzied 或 volatile 关键字解决，它们可以使用一个线程修改后的变量立即对其他线程可见</li></ul></li><li>对于指令重排导致可见性问题和有序性问题<ul><li>可以利用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排序优化</li></ul></li></ul><h4 id="volatile-使用场景"><a href="#volatile-使用场景" class="headerlink" title="volatile 使用场景"></a>volatile 使用场景</h4><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><ul><li>多线程环境下可能存在的安全问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton01.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  发现构造器里的内容会多次输出</p><ul><li>双重锁单例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton02 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton01<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton02.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有加 volatile 就不一定是线程安全的，原因是指令重排序的存在，加入 volatile 可以禁止指令重排。</p></li><li><p>原因是在于某一个线程执行到第一次检测，读取到的 instance 不为 null 时，<strong>instance 的引用对象可能还没有完成初始化。</strong></p></li><li><p><code>instance = new Singleton()</code> 可以分为以下三步完成</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null</span></span><br></pre></td></tr></table></figure><ul><li><p>步骤 2 和步骤 3 不存在依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种优化是允许的。</p></li><li><p>发生重排</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null，但对象还没有初始化完成</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br></pre></td></tr></table></figure><ul><li>所以不加 volatile 返回的实例不为空，但可能是未初始化的实例</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><ul><li><p>CAS 的全称 Compare-And-Swap，它是一条 CPU 并发。</p></li><li><p>它的功能是判断内存某一个位置的值是否为预期，如果是则更改这个值，这个过程就是原子的。</p></li><li><p>CAS 并发原体现在 JAVA 语言中就是 sun.misc.Unsafe 类中的各个方法。调用 UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于 CAS 是一种系统源语，源语属于操作系统用语范畴，是由若干条指令组成，用于完成某一个功能的过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说 CAS 是一条原子指令，不会造成所谓的数据不一致的问题。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">666</span>);</span><br><span class="line">        <span class="comment">// 获取真实值（期望值），并替换为相应的值</span></span><br><span class="line">        <span class="keyword">boolean</span> b = atomicInteger.compareAndSet(<span class="number">666</span>, <span class="number">2019</span>);</span><br><span class="line">        System.out.println(b); <span class="comment">// true</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = atomicInteger.compareAndSet(<span class="number">666</span>, <span class="number">2020</span>);</span><br><span class="line">        System.out.println(b1); <span class="comment">// false</span></span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="getAndIncrement"><a href="#getAndIncrement" class="headerlink" title="getAndIncrement();"></a>getAndIncrement();</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//this当前对象</span></span><br><span class="line">    <span class="comment">//valueOffset内存偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引出一个问题：UnSafe 类是什么？</p><h5 id="UnSafe-类"><a href="#UnSafe-类" class="headerlink" title="UnSafe 类"></a>UnSafe 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取下面 value 的地址偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，而需要通过本地（native）方法来访问， Unsafe 类相当一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 指针一样直接操作内存，因为 Java 中 CAS 操作执行依赖于 Unsafe 类。</li><li>变量 vauleOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。</li><li>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</li></ul><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>循环时间长开销很大<ul><li>如果 CAS 失败，会一直尝试，如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销（比如线程数很多，每次比较都是失败，就会一直循环），所以希望是线程数比较小的场景。</li></ul></li><li>只能保证一个共享变量的原子操作<ul><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li></ul></li><li>引出 ABA 问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 保证上面线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>);</span><br><span class="line">            System.out.println(atomicReference.get()); <span class="comment">// 2019</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有一个值从 A 改为 B 又改为 A，这就是 ABA 问题。</p><p>应对方法：时间戳原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 的版本号为："</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 的版本号为："</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> b = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(b); <span class="comment">// false</span></span><br><span class="line">            System.out.println(atomicStampedReference.getReference()); <span class="comment">// 100</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先保证两个线程的初始版本为一致，后面修改是由于版本不一样就会修改失败。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读 的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p><p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p><h3 id="概述线程状态"><a href="#概述线程状态" class="headerlink" title="概述线程状态"></a>概述线程状态</h3><ul><li><p>新建 new。 </p></li><li><p>就绪 放在可运行线程池中，等待被线程调度选中，获取 cpu。</p></li><li><p>运行 获得了 cpu。</p></li><li><p>阻塞</p><ul><li>等待阻塞 执行 wait() 。</li><li>同步阻塞 获取对象的同步琐时，同步锁被别的线程占用。</li><li>其他阻塞 执行了 sleep() 或 join() 方法)。</li></ul></li><li><p>死亡</p></li></ul><h3 id="进程同步和进程通信"><a href="#进程同步和进程通信" class="headerlink" title="进程同步和进程通信"></a>进程同步和进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h3 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait 和 sleep"></a>wait 和 sleep</h3><p>1、 sleep 来自 Thread 类，和 wait 来自 Object 类。 </p><p>2、最主要是sleep方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </p><p>3、wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在任何地方使用。</p><p>4、 sleep 必须捕获异常，而 wait ， notify 和 notifyAll 不需要捕获异常</p><ul><li>sleep 方法属于 Thread 类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了 sleep 方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在 sleep 的过程中过程中有可能被其他对象调用它的 interrupt() ，产生 InterruptedException 异常，如果你的程序不捕获这个异常，线程就会异常终止，进入 TERMINATED 状态，如果你的程序捕获了这个异常，那么程序就会继续执行catch语句块以及以后的代码。</li></ul><blockquote><p>sleep() 方法是一个静态方法，也就是说他只对当前对象有效，通过<code>t.sleep()</code>让 t 对象进入 sleep ，这样的做法是错误的，它只会是使当前线程被 sleep 而不是 t 线程</p></blockquote><ul><li>wait 属于 Object 的成员方法，一旦一个对象调用了 wait 方法，必须要采用 notify() 和 notifyAll() 方法唤醒该进程；如果线程拥有某个或某些对象的同步锁，那么在调用了 wait() 后，这个线程就会释放它持有的所有同步资源。wait() 方法也同样会在 wait 的过程中有可能被其他对象调用 interrupt() 方法而终止。</li></ul><blockquote><p>wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p><p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p><p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p><p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。  </p></blockquote><h3 id="volatile-与-synchronized-的区别"><a href="#volatile-与-synchronized-的区别" class="headerlink" title="volatile 与 synchronized 的区别"></a>volatile 与 synchronized 的区别</h3><p><strong>（1）仅靠volatile不能保证线程的安全性。（原子性）</strong></p><ul><li>volatile 轻量级，只能修饰变量。synchronized重量级，还可修饰方法</li><li>volatile 只能保证数据的可见性，不能用来同步，因为多个线程并发访问 volatile 修饰的变量不会阻塞。</li></ul><p>synchronized 不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢 synchronized 锁对象时，会出现阻塞。</p><p><strong>（2）线程安全性</strong></p><p>线程安全性包括两个方面，①可见性。②原子性。</p><p>从上面自增的例子中可以看出：仅仅使用 volatile 并不能保证线程安全性。而 synchronized 则可实现线程的安全性。</p><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><p>Java 通过 Executors 提供四种线程池，分别为：</p><ul><li>new CachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>new FixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>new ScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>new SingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。</p><p><strong>如何保证线程安全？</strong></p><ul><li>对变量使用 volitate</li><li>对程序段进行加锁 (synchronized , lock)</li></ul><h4 id="阻塞同步（互斥同步）"><a href="#阻塞同步（互斥同步）" class="headerlink" title="阻塞同步（互斥同步）"></a>阻塞同步（互斥同步）</h4><p>synchronized 和 ReentrantLock。</p><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h4 id="非阻塞同步-1"><a href="#非阻塞同步-1" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>随着硬件指令集的发展，我们可以使用基于冲突检测的<strong>乐观并发策略</strong>：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。</p><p>硬件支持的原子性操作最典型的是：<strong>比较并交换</strong>（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是<strong>内存地址 V、旧的预期值 A 和新值 B</strong>。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><p>J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p><h3 id="同步和异步，阻塞和非阻塞"><a href="#同步和异步，阻塞和非阻塞" class="headerlink" title="同步和异步，阻塞和非阻塞"></a>同步和异步，阻塞和非阻塞</h3><blockquote><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p></blockquote><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul><li>在发出一个同步调用时，在没有得到结果之前，该调用就不返回。</li><li>例如：按下电饭锅的煮饭按钮，然后等待饭煮好，把饭盛出来，然后再去炒菜。</li></ul><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。</li><li>例如：按下电钮锅的煮饭按钮，直接去炒菜或者做别的事情，当电饭锅“滴滴滴”响的时候，再回去把饭盛出来。显然，异步式编程要比同步式编程高效得多。</li></ul><blockquote><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p></blockquote><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li><li>例子：你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果</li></ul><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul><li>在不能立刻得到结果之前，该调用不会阻塞当前线程。</li><li>例子：你打电话问书店老板有没有《分布式系统》这本书，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</li></ul><h3 id="start-方法调用时会执行-run-方法，为什么不直接调用-run-方法？"><a href="#start-方法调用时会执行-run-方法，为什么不直接调用-run-方法？" class="headerlink" title="start() 方法调用时会执行 run() 方法，为什么不直接调用 run() 方法？"></a>start() 方法调用时会执行 run() 方法，为什么不直接调用 run() 方法？</h3><p>new 一个 Thread，线程进入了新建状态；直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，这并不是多线程工作。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 </p><p><strong>run()和start()方法区别：</strong></p><ul><li><code>run()</code>:仅仅是<strong>封装被线程执行的代码</strong>，直接调用是普通方法</li><li><code>start()</code>:首先<strong>启动了线程</strong>，然后再<strong>由jvm去调用该线程的run()方法。</strong></li></ul><p>总结： <strong>调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-Container</title>
      <link href="/2020/04/09/JAVA-Container/"/>
      <url>/2020/04/09/JAVA-Container/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java集合框架笔记</p></blockquote><a id="more"></a><p>Java集合框架（Java Collections Framework（JCF））提供了数据持有对象的方式，提供了对数据集合的操作。Java 集合框架位于 <code>java.util</code> 包下，主要有三个大类：<strong>Collection(接口)</strong>、<strong>Map(接口)</strong>、<strong>集合工具类</strong>。</p><p><img src="/2020/04/09/JAVA-Container/1535785576589.png" alt="img"></p><p><img src="/2020/04/09/JAVA-Container/image-20200418224842484.png" alt="image-20200418224842484"></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li><code>ArrayList</code>：<strong>线程不同步</strong>。默认初始容量为 10，当数组大小不足时容量扩大为 1.5 倍。为追求效率，ArrayList 没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用 Vector 替代。</li><li><code>LinkedList</code>：<strong>线程不同步</strong>。<strong>双向链接实现</strong>。LinkedList 同时实现了 List 接口和 Deque 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 LinkedList，一方面是因为 Java 官方已经声明不建议使用 Stack 类，更遗憾的是，Java 里根本没有一个叫做 Queue 的类（它是个接口名字）。关于栈或队列，现在的首选是 ArrayDeque，它有着比 LinkedList（当作栈或队列使用时）有着更好的性能。</li><li><code>Stack and Queue</code>：Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList ）。</li><li><code>Vector</code>：<strong>线程同步</strong>。默认初始容量为 10，当数组大小不足时容量扩大为 2 倍。它的同步是通过 <code>Iterator</code> 方法加 <code>synchronized</code> 实现的。</li><li><code>Stack</code>：<strong>线程同步</strong>。继承自 Vector，添加了几个方法来完成栈的功能。现在已经不推荐使用 Stack，在栈和队列中有限使用 ArrayDeque，其次是 LinkedList。</li><li><code>TreeSet</code>：<strong>线程不同步</strong>，内部使用 <code>NavigableMap</code> 操作。默认元素 “自然顺序” 排列，可以通过 <code>Comparator</code> 改变排序。TreeSet 里面有一个 TreeMap（适配器模式）</li><li><code>HashSet</code>：<strong>线程不同步</strong>，内部使用 HashMap 进行数据存储，提供的方法基本都是调用 HashMap 的方法，所以两者本质是一样的。集合元素可以为 NULL。</li><li><code>Set</code>：Set 是一种不包含重复元素的 Collection，Set 最多只有一个 null 元素。Set 集合通常可以通过 Map 集合通过适配器模式得到。</li><li><code>PriorityQueue</code>：Java 中 PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现。<ul><li><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java 的优先队列每次取最小元素，C++ 的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器</strong>（Comparator）。</li></ul></li><li><code>NavigableSet</code>：添加了搜索功能，可以对给定元素进行搜索：小于、小于等于、大于、大于等于，放回一个符合条件的最接近给定元素的 key。</li><li><code>EnumSet</code>：线程不同步。内部使用 Enum 数组实现，速度比 <code>HashSet</code> 快。<strong>只能存储在构造函数传入的枚举类的枚举值</strong>。</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><code>TreeMap</code>：线程不同步，基于红黑树（Red-Black tree）的 NavigableMap 实现，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</li><li><code>Hashtable</code>：<strong>线程安全</strong>，HashMap 的迭代器 (Iterator) 是 <code>fail-fast</code> 迭代器。<strong>Hashtable 不能存储 NULL 的 key 和 value。</strong></li><li><code>HashMap</code>：线程不同步。根据<code>key</code>的<code>hashcode</code>进行存储，内部使用静态内部类<code>Node</code>的数组进行存储，默认初始大小为 16，每次扩大一倍。当发生 Hash 冲突时，采用拉链法（链表）。JDK 1.8中：当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。<ul><li>Java HashMap 采用的是冲突链表方式。</li><li>HashMap 是 Hashtable 的轻量级实现，可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 不允许。</li></ul></li><li><code>LinkedHashMap</code>：<strong>保存了记录的插入顺序</strong>，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。</li><li><code>WeakHashMap</code>：从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的 entry 可能会被 GC 自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。 WeakHashMap 的存储结构类似于HashMap<ul><li>既然有 WeekHashMap，是否有 WeekHashSet 呢？答案是没有！不过 Java Collections 工具类给出了解决方案，<code>Collections.newSetFromMap(Map map)</code> 方法可以将任何 Map包装成一个Set。</li></ul></li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ul><li><code>Collections</code>、<code>Arrays</code>：集合类的一个工具类帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li><li><code>Comparable</code>、<code>Comparator</code>：一般是用于对象的比较来实现排序，两者略有区别。</li></ul><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>Collections 工具类常用方法:</p><p>排序<br>查找,替换操作<br>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</p><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> arrayList.add(-<span class="number">1</span>);</span><br><span class="line"> arrayList.add(<span class="number">3</span>);</span><br><span class="line"> arrayList.add(<span class="number">3</span>);</span><br><span class="line"> arrayList.add(-<span class="number">5</span>);</span><br><span class="line"> arrayList.add(<span class="number">7</span>);</span><br><span class="line"> arrayList.add(<span class="number">4</span>);</span><br><span class="line"> arrayList.add(-<span class="number">9</span>);</span><br><span class="line"> arrayList.add(-<span class="number">7</span>);</span><br><span class="line"> System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line"> System.out.println(arrayList);</span><br><span class="line"> <span class="comment">// void reverse(List list)：反转</span></span><br><span class="line"> Collections.reverse(arrayList);</span><br><span class="line"> System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line"> System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Collections.rotate(arrayList, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.rotate(arrayList, 4):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void shuffle(List list),随机排序</span></span><br><span class="line">Collections.shuffle(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.shuffle(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void swap(List list, int i , int j),交换两个索引位置的元素</span></span><br><span class="line">Collections.swap(arrayList, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.swap(arrayList, 2, 5):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><h4 id="查找-替换"><a href="#查找-替换" class="headerlink" title="查找,替换"></a>查找,替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList2.add(-<span class="number">3</span>);</span><br><span class="line">arrayList2.add(-<span class="number">5</span>);</span><br><span class="line">arrayList2.add(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.max(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.max(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.min(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.min(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.replaceAll(arrayList, 3, -3):"</span>);</span><br><span class="line">Collections.replaceAll(arrayList, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.frequency(arrayList, -3):"</span>);</span><br><span class="line">System.out.println(Collections.frequency(arrayList, -<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.indexOfSubList(arrayList, arrayList2):"</span>);</span><br><span class="line">System.out.println(Collections.indexOfSubList(arrayList, arrayList2));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.binarySearch(arrayList, 7):"</span>);</span><br><span class="line"><span class="comment">// 对List进行二分查找，返回索引，List必须是有序的</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(Collections.binarySearch(arrayList, <span class="number">7</span>));</span><br></pre></td></tr></table></figure><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4><p>Collections提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><ol><li>排序 : <code>sort()</code></li><li>查找 : <code>binarySearch()</code></li><li>比较: <code>equals()</code></li><li>填充 : <code>fill()</code></li><li>转列表: <code>asList()</code></li><li>转字符串 : <code>toString()</code></li><li>复制: <code>copyOf()</code></li></ol><h4 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************排序 sort****************</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">    System.out.print(d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p>在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,<code>Arrays.sort()</code> 对每个字符串的特定位置进行比较，然后按照升序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123; <span class="string">"abcdehg"</span>, <span class="string">"abcdefg"</span>, <span class="string">"abcdeag"</span> &#125;;</span><br><span class="line">Arrays.sort(strs);</span><br><span class="line">System.out.println(Arrays.toString(strs));<span class="comment">//[abcdeag, abcdefg, abcdehg]</span></span><br></pre></td></tr></table></figure><h4 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************查找 binarySearch()****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h4 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************比较 equals****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h4 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************填充fill(批量初始化)****************</span></span><br><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************转列表 asList()****************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment">*（将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment">* 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment">* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h4 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************转字符串 toString()****************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回指定数组的内容的字符串表示形式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] k = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));<span class="comment">// [a, f, b, c, e, A, C, B]</span></span><br></pre></td></tr></table></figure><h4 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************复制 copy****************</span></span><br><span class="line"><span class="comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> i[] = Arrays.copyOf(h, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOf(h, 6);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：123333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">    System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// copyOfRange将指定数组的指定范围复制到新数组中</span></span><br><span class="line"><span class="keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOfRange(h, 6, 11)："</span>);</span><br><span class="line"><span class="comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 : j) &#123;</span><br><span class="line">    System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><p>JCF的迭代器（Iterator）为我们提供了遍历容器中元素的方法。只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式实现自己的迭代器。相比STL的迭代器，JCF的迭代器更容易使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//visit a list with iterator</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();<span class="comment">//得到迭代器</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String weekday = it.next();<span class="comment">//访问元素</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.5 引入了增强的for循环，简化了迭代容器时的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用增强for迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(String weekday : list)&#123;<span class="comment">//enhanced for statement</span></span><br><span class="line">System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List介绍"><a href="#List介绍" class="headerlink" title="List介绍"></a>List介绍</h2><ul><li>List集合的<strong>特点</strong>就是：<strong>有序(存储顺序和取出顺序一致),可重复</strong></li></ul><p>List集合常用的子类有三个：</p><ul><li>ArrayList<ul><li>底层数据结构是数组。线程不安全</li></ul></li><li>LinkedList<ul><li>底层数据结构是链表。线程不安全</li></ul></li><li>Vector<ul><li>底层数据结构是数组。线程安全</li></ul></li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><img src="/2020/04/09/JAVA-Container/psb.png" alt="img"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>先来看看ArrayList的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>从中我们可以了解到：</p><ul><li>ArrayList<E>：说明ArrayList支持泛型。</E></li><li>extends AbstractList<E> ：继承了AbstractList。AbstractList提供List接口的骨干实现，以最大限度地减少“随机访问”数据存储（如ArrayList）实现Llist所需的工作。</E></li><li>implements List<E>：实现了List。实现了所有可选列表操作。</E></li><li>implements RandomAccess：表明ArrayList支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</li><li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li><li>implements java.io.Serializable：表明该类具有序列化功能。</li></ul><p>ArrayList源码属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化默认容量为10。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定该ArrayList容量为0时，返回该空数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当调用无参构造方法，返回的是该数组。刚创建一个ArrayList 时，其内数据量为0。</span></span><br><span class="line"><span class="comment"> * 它与EMPTY_ELEMENTDATA的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存添加到ArrayList中的元素。</span></span><br><span class="line"><span class="comment"> * ArrayList的容量就是该数组的长度。</span></span><br><span class="line"><span class="comment"> * 该值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，当第一次添加元素进入ArrayList中时，数组将扩容值DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> * 被标记为transient，在对象被序列化的时候不会被序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的实际大小（数组包含的元素个数）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><ul><li>底层：ArrayList是List接口的大小可变数组的实现。</li><li>是否允许null：ArrayList允许null元素。</li><li>时间复杂度：size、isEmpty、get、set、iterator和listIterator方法都以固定时间运行，时间复杂度为O(1)。add和remove方法需要O(n)时间。与用于LinkedList实现的常数因子相比，此实现的常数因子较低。</li><li>容量：ArrayList的容量可以自动增长。</li><li>是否同步：ArrayList不是同步的。</li><li>迭代器：ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。</li></ul><p><strong>ArrayList底层其实就是一个数组</strong>，ArrayList中有<strong>扩容</strong>这么一个概念，正因为它扩容，所以它能够<strong>实现“动态”增长</strong></p><p>ArrayList提供了三种构造方法。</p><ul><li>ArrayList(int initialCapacity)：构造一个指定容量为capacity的空ArrayList。</li><li>ArrayList()：构造一个初始容量为 10 的空列表。</li><li>ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</li></ul><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><table><thead><tr><th>方法名</th><th>时间复杂度</th></tr></thead><tbody><tr><td>add(E e)</td><td>O(1)</td></tr><tr><td>add(int index,E element)</td><td>O(n)</td></tr><tr><td>get(int index)</td><td>O(1)</td></tr><tr><td>set(int index,E element)</td><td>O(1)</td></tr><tr><td>remove(int index)</td><td>O(n)</td></tr></tbody></table><h4 id="Add方法"><a href="#Add方法" class="headerlink" title="Add方法"></a>Add方法</h4><p>add方法可以说是ArrayList比较重要的方法了，我们来总览一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到特定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h5><p>步骤：</p><ul><li><strong>ensureCapacityInternal() 检查是否需要扩容</strong></li><li><strong>插入元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组容量检查，不够时则进行扩容，只供类内部使用。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity    想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则取minCapacity为DEFAULT_CAPACITY(10)和参数minCapacity之间的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组容量检查，不够时则进行扩容，只供类内部使用</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity 想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当指定的最小容量 &gt; 数组当前的长度 </span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grow()</code>是怎么实现的~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容。新的容量=当前容量+当前容量/2.即将当前容量增加一半。</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果扩容后的容量还是小于想要的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将扩容后的容量再次扩容为想要的最小容量</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果扩容后的容量大于临界值，则进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法总结如下：</p><ol><li>进行空间检查<code>ensureCapacityInternal(int minCapacity)</code>，决定是否进行扩容，以及确定最少需要的容量</li><li>如果确定扩容，就执行<code>grow(int minCapacity)</code>，<code>minCapacity</code>为最少需要的容量</li><li>第一次扩容，逻辑为<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>即在原有的容量基础上增加一半。</li><li>第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。</li><li>对扩容后的容量进行判断，如果大于允许的最大容量MAX_ARRAY_SIZE，则将容量再次调整为MAX_ARRAY_SIZE。至此扩容操作结束。</li></ol><p><code>copyOf()</code>函数~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">===========================================================================</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arraycopy()</code>函数~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">===========================================================================</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><p>步骤：</p><ul><li><strong>检查角标</strong></li><li><strong>空间检查，如果有需要进行扩容</strong></li><li><strong>插入元素</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>步骤：</p><ul><li><strong>检查角标</strong></li><li><strong>返回索引值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><p>步骤：</p><ul><li><strong>检查角标</strong></li><li><strong>替代元素</strong></li><li><strong>返回旧值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>步骤：</p><ul><li><strong>检查角标</strong></li><li><strong>删除元素</strong></li><li><strong>计算出需要移动的个数，并移动</strong></li><li>设置为null，让Gc回收</li></ul><h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据对象删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的删除方法，根据索引来，省略了角标检查和旧值返回</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="细节再说明"><a href="#细节再说明" class="headerlink" title="细节再说明"></a>细节再说明</h5><ul><li>ArrayList是<strong>基于动态数组实现的</strong>，在<strong>增删时候，需要数组的拷贝复制</strong>。</li><li><strong>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍</strong></li><li>删除元素时不会减少容量，<strong>若希望减少容量则调用trimToSize()</strong></li><li>它不是线程安全的。它能存放null值。</li></ul><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><h5 id="ensureCapacity-int-minCapacity"><a href="#ensureCapacity-int-minCapacity" class="headerlink" title="ensureCapacity(int minCapacity)"></a>ensureCapacity(int minCapacity)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains(Object o)"></a>contains(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf(Object o)"></a>indexOf(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf(Object o)"></a>lastIndexOf(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>基于数组实现，无容量的限制。</li><li>在执行插入元素时可能要扩容，在删除元素时并不会减小数组的容量，在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。</li><li>是非线程安全的。</li><li>注意点：<ol><li>ArrayList随机元素时间复杂度O(1)，插入删除操作需大量移动元素，效率较低</li><li>为了节约内存，当新建容器为空时，会共享Object[] EMPTY_ELEMENTDATA = {}和 Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}空数组</li><li>容器底层采用数组存储，每次扩容为1.5倍</li><li>ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法，其实Arrays.copyof()内部也是调用System.arraycopy()。System.arraycopy()为Native方法</li><li>两个ToArray方法<ul><li>Object[] toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常</li><li>T[] toArray(T[] a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型</li></ul></li><li>ArrayList可以存储null值</li><li>ArrayList每次修改（增加、删除)容器时，都是修改自身的modCount；在生成迭代器时，迭代器会保存该modCount值，迭代器每次获取元素时，会比较自身的modCount与ArrayList的modCount是否相等，来判断容器是否已经被修改，如果被修改了则抛出异常（fast-fail机制)。</li></ol></li></ul><h4 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h4><p><strong>什么是 fail-fast 机制?</strong></p><p>fail-fast 机制在遍历一个集合时，当集合结构被修改，会抛出 Concurrent Modification Exception。</p><p>fail-fast 会在以下两种情况下抛出 Concurrent Modification Exception</p><p>（1）单线程环境</p><ul><li>集合被创建后，在遍历它的过程中修改了结构。</li><li>注意 remove() 方法会让 expectModcount 和 modcount 相等，所以是不会抛出这个异常。</li></ul><p>（2）多线程环境</p><ul><li>当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</li></ul><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指<strong>添加</strong>或者<strong>删除</strong>至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 Concurrent Modification Exception。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList-与-Vector"><a href="#ArrayList-与-Vector" class="headerlink" title="ArrayList 与 Vector"></a>ArrayList 与 Vector</h4><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul><h4 id="Vector-替代方案"><a href="#Vector-替代方案" class="headerlink" title="Vector 替代方案"></a>Vector 替代方案</h4><h5 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h5><p>为了获得线程安全的 ArrayList，可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p><img src="/2020/04/09/JAVA-Container/cow.png" alt="img"></p><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>CopyOnWrite 容器即写时复制的容器。通俗的理解是<strong>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器</strong>。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种<strong>读写分离</strong>的思想，读和写不同的容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制出新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把新元素添加到新数组里</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 把原数组引用指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读的时候不需要加锁，如果读的时候有多个线程正在向 ArrayList 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CopyOnWrite的缺点</strong></p><ul><li>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</li></ul><p><strong>内存占用问题</strong>。</p><ul><li>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意：在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。之前我们系统中使用了一个服务由于每晚使用 CopyOnWrite 机制更新大对象，造成了每晚 15 秒的 Full GC，应用响应时间也随之变长。</li><li>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是 10 进制的数字，可以考虑把它压缩成 36 进制或 64 进制。或者不使用 CopyOnWrite 容器，而使用其他的并发容器，如 ConcurrentHashMap 。</li></ul><p><strong>数据一致性问题</strong>。</p><ul><li>CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList和ArrayList与Vector同样实现了List接口，但它执行某些操作如插入和删除元素操作比ArrayList与Vector更高效，而随机访问操作效率低。</p><p><img src="/2020/04/09/JAVA-Container/psb-1587283048726.png" alt="img"></p><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><ul><li>LinkedList<E>：说明它支持泛型。</E></li><li>extends AbstractSequentialList<E><br>AbstractSequentialList 继承自AbstractList，但AbstractSequentialList 只支持按次序访问，而不像 AbstractList 那样支持随机访问。这是LinkedList随机访问效率低的原因之一。</E></li><li>implements List<E>：说明它支持集合的一般操作。</E></li><li>implements Deque<E>：Deque，Double ended queue，双端队列。LinkedList可用作队列或双端队列就是因为实现了它。</E></li><li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li><li>implements java.io.Serializable：表明该类是可以序列化的。</li></ul><p>与ArrayList对比发现，LinkedList并没有实现RandomAccess，而实现RandomAccess表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。这是LinkedList随机访问效率低的原因之一。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向头节点的指针</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向尾节点的指针</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>LinkedList的构造方法有两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>一个是 <code>add(E e)</code>，该方法在 LinkedList 的末尾插入元素，因为有 last 指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是 <code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><h5 id="add-E-e-1"><a href="#add-E-e-1" class="headerlink" title="add(E e)"></a>add(E e)</h5><ul><li>add方法实际上就是往链表最后添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Links e as last element.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add-int-index-E-element-1"><a href="#add-int-index-E-element-1" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h5><ol><li>先根据 index 找到要插入的位置；</li><li>修改引用，完成插入操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove方法-1"><a href="#remove方法-1" class="headerlink" title="remove方法"></a>remove方法</h4><p>一个是删除跟指定元素相等的第一个元素 <code>remove(Object o)</code>，另一个是删除指定下标处的元素 <code>remove(int index)</code>。</p><p>两个删除操作都要：</p><ol><li>先找到要删除元素的引用；</li><li>修改相关引用，完成删除操作。</li></ol><p>在寻找被删元素引用的时候 <code>remove(Object o)</code> 调用的是元素的 equals 方法，而 <code>remove(int index)</code> 使用的是下标计数，两种方式都是线性时间复杂度。在步骤 2 中，两个 <code>revome()</code> 方法都是通过 <code>unlink(Node x)</code> 方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p><h5 id="remove-Object-o-1"><a href="#remove-Object-o-1" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove-int-index-1"><a href="#remove-int-index-1" class="headerlink" title="remove(int index)"></a>remove(int index)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标小于长度的一半就从头遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就从尾遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h4><p>可以看到get方法实现就两段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出是使用二分查找来看 <code>index</code> 离 size 中间距离来判断是从头结点正序查还是从尾节点倒序查。node() 会以O(n/2)的性能去获取一个结点。这样的效率是非常低的，特别是当 index 越接近 size 的中间值时。</p><h4 id="set方法-1"><a href="#set方法-1" class="headerlink" title="set方法"></a>set方法</h4><p>set方法和get方法其实差不多，<strong>根据下标来判断是从头遍历还是从尾遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他函数-1"><a href="#其他函数-1" class="headerlink" title="其他函数"></a>其他函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))java</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><strong>ArrayList：</strong></p><ul><li>底层实现是数组</li><li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍</li><li>在<strong>增删时候，需要数组的拷贝复制(navite 方法由C/C++实现)</strong></li></ul><p><strong>LinkedList：</strong></p><ul><li>底层实现是<strong>双向链表</strong>[双向链表方便实现往前遍历]</li></ul><p><strong>Vector：</strong></p><ul><li>底层是数组，现在已少用，被ArrayList替代，原因有两个：<ul><li>Vector所有方法都是同步，<strong>有性能损失</strong>。</li><li>Vector初始length是10 超过length时 以100%比率增长，<strong>相比于ArrayList更多消耗内存</strong>。</li></ul></li></ul><p><strong>总的来说：查询多用ArrayList，增删多用LinkedList。</strong></p><p><strong>ArrayList增删慢不是绝对</strong>的(<strong>在数量大的情况下，已测试</strong>)：</p><ul><li>如果增加元素一直是使用<code>add()</code>(增加到末尾)的话，那是ArrayList要快</li><li>一直<strong>删除末尾的元素也是ArrayList要快</strong>【不用复制移动位置】</li><li>至于如果<strong>删除的是中间的位置的话，还是ArrayList要快</strong>！</li></ul><p>但一般来说：<strong>增删多还是用LinkedList，因为上面的情况是极端的~</strong></p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack继承了Vector，特点是先进后出(FILO, First In Last Out)。</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素的到栈顶。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   item  要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  被添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Vector#addElement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">    addElement(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回栈顶元素，并将其从栈中删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  EmptyStackException 如果栈为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E obj;</span><br><span class="line">    <span class="keyword">int</span> len = size();</span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回栈顶元素，不删除。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  栈顶元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  EmptyStackException  如果栈为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断栈是否为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  栈是否有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈底向栈顶方向遍历，查找指定对象o在栈中的位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   o   指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  o的索引，如果没找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map介绍"><a href="#Map介绍" class="headerlink" title="Map介绍"></a>Map介绍</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="/2020/04/09/JAVA-Container/psb-1587301033720.png" alt="img"></p><p>无论是Set还是Map，我们会发现都会有对应的–&gt;<strong>Hash</strong>Set，<strong>Hash</strong>Map</p><p>散列表<strong>为每个对象计算出一个整数，称为散列码</strong>。<strong>根据</strong>这些计算出来的<strong>整数（散列码）保存在对应的位置上</strong>！后面介绍的集合类都会以此为基础。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul><li>底层：HashMap是Map接口基于哈希表的实现。</li><li>是否允许null：HashMap允许key和value为null。</li><li>是否有序：HashMap不保证映射的顺序，特别是它不保证该顺序恒久不变。</li><li>HashMap有两个影响性能的重要参数：初始化容量initial capacity、加载因子load factor。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。<code>initial capacity*load factor</code>就是当前允许的最大元素数目，超过<code>initial capacity*load factor</code>之后，HashMap就会进行扩容，扩容后的的容量为之前的两倍。</li><li>是否同步：HashMap不是同步的。</li><li>迭代器：迭代器是fast-fail的。</li></ul><p><strong>定义：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以了解到：</p><ul><li>HashMap&lt;K,V&gt;：HashMap是以key-value形式存储数据的。</li><li>extends AbstractMap&lt;K,V&gt;：继承了AbstractMap，大大减少了实现Map接口时需要的工作量。</li><li>implements Map&lt;K,V&gt;：实现了Map，提供了所有可选的Map操作。</li><li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li><li>implements Serializable：表明该类是可以序列化的。</li></ul><p><strong>属性：</strong></p><p>静态全局变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量，值为16</span></span><br><span class="line"><span class="comment"> * 必须是2的n次幂.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量, 容量不能超出这个值。如果一个更大的初始化容量在构造函数中被指定，将被MAXIMUM_CAPACITY替换.</span></span><br><span class="line"><span class="comment"> * 必须是2的倍数。最大容量为1&lt;&lt;30，即2的30次方。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的加载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化为红黑树的临界值。</span></span><br><span class="line"><span class="comment"> * 当添加一个元素被添加到有至少TREEIFY_THRESHOLD个节点的桶中，桶中链表将被转化为树形结构。</span></span><br><span class="line"><span class="comment"> * 临界值最小为8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复成链式结构的桶大小临界值</span></span><br><span class="line"><span class="comment"> * 小于TREEIFY_THRESHOLD，临界值最大为6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶可能被转化为树形结构的最小容量。当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突。</span></span><br><span class="line"><span class="comment"> * 应该至少4*TREEIFY_THRESHOLD来避免扩容和树形结构化之间的冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><h5 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h5><p>底层为<strong>数组和链表</strong>结合的方式，地址冲突时通过拉链法解决。</p><p><img src="/2020/04/09/JAVA-Container/hashmap-link-1587302042766.jpg" alt="img"></p><p>「拉链法」又叫做<strong>链地址法</strong>，即在每个数组元素上存储的都是一个链表。</p><h5 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h5><p>底层为<strong>数组+链表+红黑树</strong>的方式，地址冲突时通过链表和红黑树解决。</p><ul><li>当处理如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时的时间复杂度达到 O(n)，</li><li>链表长度超过 <code>TREEIFY_THRESHOLD = 8</code> 的时候，会将单链表转化为红黑树。<ul><li>红黑树是一种易于增删改查的二叉树，对与数据的查询的时间复杂度是 <code>O(logn)</code> 级别</li></ul></li></ul><p><img src="/2020/04/09/JAVA-Container/hashmap-rb-link.jpg" alt="img"></p><p><img src="/2020/04/09/JAVA-Container/hashMap-datastruct-1587304987383.png" alt="img"></p><p><strong>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</strong></p><p>（1）从源码可知，HashMap 类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个 Node 的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的节点类型。既是HashMap底层数组的组成元素，又是每个单向链表的组成元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射（键值对）。上图中的每个黑色圆点就是一个Node对象。</p><p>（2）HashMap 就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题， Java 中 HashMap 采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p>系统将调用 “美团” 这个 key 的 hashCode() 方法得到其 hashCode 值（该方法适用于每个 Java 对象），然后再通过 Hash 算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个 key 会定位到相同的位置，表示发生了 Hash 碰撞。当然 Hash 算法计算结果越分散均匀，Hash 碰撞的概率就越小，map 的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的 Hash 算法也会比较分散，如果哈希桶数组数组很小，即使好的 Hash 算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的 hash 算法减少 Hash 碰撞。</p><p><strong>那么通过什么方式来控制 map 使得 Hash 碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？</strong></p><p>答案就是好的 Hash 算法和扩容机制。</p><p>在理解 Hash 和扩容流程之前，我们得先了解下 HashMap 的几个字段。从 HashMap 的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><ul><li><strong>Node[] table的初始化长度 length (默认值是16)</strong>，<strong>Load factor 为负载因子(默认值是0.75)</strong>，</li><li>threshold 是 HashMap 所能容纳的最大数据量的 Node (键值对)个数。<strong>threshold = length * Load factor</strong>。</li><li>size 这个字段其实很好理解，就是 HashMap 中实际存在的键值对数量。注意和 table 的长度 length、容纳最大键值对数量 threshold 的区别。而</li><li>modCount 字段主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</li></ul><h4 id="2-重要参数"><a href="#2-重要参数" class="headerlink" title="2. 重要参数"></a>2. 重要参数</h4><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">buckets</td><td align="left">在 HashMap 的注释里使用哈希桶来形象的表示数组中每个地址位置。注意这里并不是数组本身，数组是装哈希桶的，他可以被称为<strong>哈希表</strong>。</td></tr><tr><td align="left">capacity</td><td align="left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td align="left">size</td><td align="left">table 的实际使用量。</td></tr><tr><td align="left">threshold</td><td align="left">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td></tr><tr><td align="left">loadFactor</td><td align="left">装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td></tr><tr><td align="left">TREEIFY_THRESHOLD</td><td align="left">树化阀值，哈希桶中的节点个数大于该值（默认为8）的时候将会被转为红黑树行存储结构。</td></tr><tr><td align="left">UNTREEIFY_THRESHOLD</td><td align="left">非树化阀值，小于该值（默认为 6）的时候将再次改为单链表的格式存储</td></tr></tbody></table><h4 id="3-确定索引"><a href="#3-确定索引" class="headerlink" title="3. 确定索引"></a>3. 确定索引</h4><p>很多操作都需要先确定一个键值对所在的桶下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>（一）计算 hash 值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，计算hash分为三步，</p><ul><li>第一步，取key的hashCode（该方法在其静态内部类中），</li><li>第二步，key的hashCode高16位异或低16位，</li><li>第三步，将第一步和第二部得到的结果进行取模运算。</li></ul><p>（二）取模</p><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>这个性质和 y 对 x 取模效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><p>位运算的代价比求模运算小的多，因此在进行这种计算时用<strong>位运算</strong>的话能带来更高的性能。</p><p>（三）确定桶下标</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-put方法"><a href="#4-put方法" class="headerlink" title="4. put方法"></a>4. put方法</h4><p>图示：</p><p><img src="https://frank-lam.github.io/fullstack-tutorial/assets/hashmap-put.png" alt="img"></p><ol><li><p>判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p></li><li><p>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向 6，如果table[i] 不为空，转向 3；</p></li><li><p>判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 4，这里的相同指的是 hashCode 以及 equals；</p></li><li><p>判断table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 5；</p></li><li><p>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p></li><li><p>插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p></li></ol><p>JDK1.8 HashMap 的 put 方法源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-get方法"><a href="#5-get方法" class="headerlink" title="5. get方法"></a>5. get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get(Object key) 可以分为三个步骤：</p><ol><li>通过hash(Object key)方法计算key的哈希值hash。<ol><li>上文中计算方法hash(Object key)</li></ol></li><li>通过getNode( int hash, Object key)方法获取node。</li><li>如果node为null，返回null，否则返回node.value。</li></ol><h4 id="6-resize方法"><a href="#6-resize方法" class="headerlink" title="6. resize方法"></a>6. resize方法</h4><p>方法是使用一个新的数组代替已有的容量小的数组</p><p>我们分析下 resize 的源码，鉴于 JDK1.8 融入了红黑树，较复杂，为了便于理解我们仍然使用 JDK1.7 的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.7</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    Entry[] oldTable = table;    </span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;      </span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大(2^30)</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; </span><br><span class="line">        <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化一个新的Entry数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  </span><br><span class="line">    <span class="comment">// 将数据转移到新的Entry数组里</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    <span class="comment">// 将HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer() 方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// src引用了旧的Entry数组</span></span><br><span class="line">    Entry[] src = table;                   </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">// 遍历旧的Entry数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; </span><br><span class="line">        <span class="comment">// 取得旧Entry数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 保存下一次循环的 Entry&lt;K,V&gt;</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); </span><br><span class="line">                <span class="comment">// 采用链头插入法将e插入i位置，最后的链表相对于原table正好是头尾相反的</span></span><br><span class="line">                e.next = newTable[i]; </span><br><span class="line">                <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                newTable[i] = e;      </span><br><span class="line">                <span class="comment">// 访问下一个Entry链上的元素</span></span><br><span class="line">                e = next;             </span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i] 的引用赋给了 e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部，这一点和 Jdk1.8 有区别，下文详解。</p><p>例子：</p><blockquote><p>假设 <code>hash = key mod table.length</code>。哈希桶数组 table 的 size=2，元素 key = 3、7、5，put 顺序依次为 5、7、3。在 mod 2 以后都冲突在 table[1] 这里了。假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p></blockquote><p><img src="/2020/04/09/JAVA-Container/jdk1.7-resize.png" alt="img"></p><p>下面我们讲解下 JDK1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展 (指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。</p><p>看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示<strong>扩容前</strong>的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示<strong>扩容后</strong> key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="/2020/04/09/JAVA-Container/hashMap-1.8-hash1.png" alt="img"></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit (红色)，因此新的 index 会有两种情况：</p><ol><li>原位置</li><li>原位置 + 原数组长度</li></ol><p><img src="/2020/04/09/JAVA-Container/hashMap-1.8-hash2.png" alt="img"></p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p><p><img src="/2020/04/09/JAVA-Container/jdk1.8-resize.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。另外，JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8 不会倒置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对table进行初始化或者扩容。</span></span><br><span class="line"><span class="comment"> * 如果table为null，则对table进行初始化</span></span><br><span class="line"><span class="comment"> * 如果对table扩容，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//新建oldTab数组保存扩容前的数组table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//使用变量oldCap扩容前table的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//保存扩容前的临界值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果扩容前的容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量&gt;=MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//扩容临界值提高到正无穷</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//无法进行扩容，返回原来的数组</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果现在容量的两倍小于MAXIMUM_CAPACITY且现在的容量大于DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//临界值变为原来的2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="comment">//如果旧容量 &lt;= 0，而且旧临界值 &gt; 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="comment">//数组的新容量设置为老数组扩容的临界值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果旧容量 &lt;= 0，且旧临界值 &lt;= 0，新容量扩充为默认初始化容量，新临界值为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//在当上面的条件判断中，只有oldThr &gt; 0成立时，newThr == 0</span></span><br><span class="line">        <span class="comment">//ft为临时临界值，下面会确定这个临界值是否合法，如果合法，那就是真正的临界值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//当新容量&lt; MAXIMUM_CAPACITY且ft &lt; (float)MAXIMUM_CAPACITY，新的临界值为ft，否则为Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将扩容后hashMap的临界值设置为newThr</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的table，初始化容量为newCap</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//修改hashMap的table为新建的newTab</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果旧table不为空，将旧table中的元素复制到新的table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果旧桶不为null，使用e记录旧桶</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将旧桶置为null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果旧桶中只有一个node</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//将e也就是oldTab[j]放入newTab中e.hash &amp; (newCap - 1)的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果旧桶中的结构为红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//将树中的node分离</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//如果旧桶中的结构为链表。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历整个链表中的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-线程安全性"><a href="#7-线程安全性" class="headerlink" title="7. 线程安全性"></a>7. 线程安全性</h4><p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="jdk1-7HashMap线程不安全总结："><a href="#jdk1-7HashMap线程不安全总结：" class="headerlink" title="jdk1.7HashMap线程不安全总结："></a>jdk1.7HashMap线程不安全总结：</h5><p>HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p><h5 id="jdk1-8HashMap线程不安全总结："><a href="#jdk1-8HashMap线程不安全总结：" class="headerlink" title="jdk1.8HashMap线程不安全总结："></a>jdk1.8HashMap线程不安全总结：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 如果没有hash碰撞则直接插入元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第六行代码是判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><p>除此之前，还有就是代码的第38行处有个++size，假设还是线程A、B，这两个线程同时进行put操作时，且当前HashMap的zise大小为10，当线程A执行到第38行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时，线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>HashMap</code>的线程不安全主要体现在下面两个方面：<br>1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。<br>2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。</p><h4 id="8-自定义类主键"><a href="#8-自定义类主键" class="headerlink" title="8. 自定义类主键"></a>8. 自定义类主键</h4><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法</strong>。</p><ul><li>从源码可以得知，在插入元素的时候是<strong>先算出该对象的hashCode</strong>。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。</li><li>如果调用equals()方法，<strong>两个key相同</strong>，则<strong>替换元素</strong></li><li>如果调用equals()方法，<strong>两个key不相同</strong>，则说明该<strong>hashCode仅仅是碰巧相同</strong>，此时是散列冲突，将新增的元素放在桶子上</li></ul><p>一般来说，我们会认为：<strong>只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的</strong>！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写<code>equals()</code>方法</p><p>重写了equals()方法，就要重写hashCode()的方法。因为<strong>equals()认定了这两个对象相同</strong>，而<strong>同一个对象调用hashCode()方法时</strong>，是应该返回相同的值的！</p><p>自定义一个类Key，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Key(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Key key = (Key) o;</span><br><span class="line">        <span class="keyword">return</span> value == key.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类复写了equals方法，并且使用属性值value当做hashcode。</p><h4 id="9-HashMap与Hashtable"><a href="#9-HashMap与Hashtable" class="headerlink" title="9.  HashMap与Hashtable"></a>9.  HashMap与Hashtable</h4><ol><li>Hashtable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ol><h4 id="10-小结"><a href="#10-小结" class="headerlink" title="10.  小结"></a>10.  小结</h4><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。</li><li>JDK1.8 引入红黑树大程度优化了 HashMap 的性能。</li></ol><h4 id="11-知识点"><a href="#11-知识点" class="headerlink" title="11. 知识点"></a>11. 知识点</h4><h5 id="不同对象hashCode值有可能相等的问题"><a href="#不同对象hashCode值有可能相等的问题" class="headerlink" title="不同对象hashCode值有可能相等的问题"></a>不同对象hashCode值有可能相等的问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o != <span class="keyword">null</span> ? o.hashCode() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashCode是所有Java对象的固有方法，如果不重写的话，返回的实际上是该对象在jvm的堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重写了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。</p><h5 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h5><p>HashCode的范围在 ±20亿，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。</p><p>常用的取余为 <code>%</code> ，但是除数是2的幂次则等价于与其除数减一的与操作：即 <code>hash % length == hash &amp; (length-1)</code>，并且采用二进制位操作 &amp;，相对于%能够提高运算效率</p><h3 id="HashTable（了解）"><a href="#HashTable（了解）" class="headerlink" title="HashTable（了解）"></a>HashTable（了解）</h3><p>Hashtable和HashMap，从存储结构和实现来讲基本上都是相同的。它和HashMap的最大的不同是它是线程安全的，另外它不允许key和value为null。Hashtable是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><h4 id="HashMap-amp-Hashtable"><a href="#HashMap-amp-Hashtable" class="headerlink" title="HashMap&amp;Hashtable"></a>HashMap&amp;Hashtable</h4><p>共同点：</p><ul><li>从存储结构和实现来讲基本上都是相同的，都是实现Map接口~</li></ul><p><strong>区别：</strong></p><ul><li><strong>同步性：</strong><ul><li>HashMap是非同步的</li><li>Hashtable是同步的，因为对put和get都上锁</li><li>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap</li></ul></li><li><strong>是否允许为null：</strong><ul><li>HashMap允许为null</li><li>Hashtable不允许为null</li></ul></li><li><strong>contains方法</strong><ul><li>Hashtable有contains方法</li><li>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</li></ul></li><li><strong>继承不同：</strong><ul><li>HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</li><li>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</li></ul></li></ul><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th align="center">不同点</th><th align="center">HashMap</th><th align="center">Hashtable</th></tr></thead><tbody><tr><td align="center">数据结构</td><td align="center">数组+链表+红黑树</td><td align="center">数组+链表</td></tr><tr><td align="center">继承的类不同</td><td align="center">继承AbstractMap</td><td align="center">继承Dictionary</td></tr><tr><td align="center">是否线程安全</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">性能高低</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">默认初始化容量</td><td align="center">16</td><td align="center">11</td></tr><tr><td align="center">扩容方式不同</td><td align="center">原始容量x2</td><td align="center">原始容量x2 + 1</td></tr><tr><td align="center">底层数组的容量为2的整数次幂</td><td align="center">要求一定为2的整数次幂</td><td align="center">不要求</td></tr><tr><td align="center">确认key在数组中的索引的方法不同</td><td align="center">i = (n - 1) &amp; hash;</td><td align="center">index = (hash &amp; 0x7FFFFFFF) % tab.length;</td></tr><tr><td align="center">遍历方式</td><td align="center">Iterator(迭代器)</td><td align="center">Iterator(迭代器)和Enumeration(枚举器)</td></tr><tr><td align="center">Iterator遍历数组顺序</td><td align="center">索引从小到大</td><td align="center">索引从大到小</td></tr></tbody></table><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>HashMap</strong> ：先说 HashMap，HashMap 是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成），导致 get 操作时，cpu 空转，所以，在并发环境中使 用HashMap 是非常危险的。</p><p><strong>Hashtable</strong> ： Hashtable 和 HashMap的实现原理几乎一样，差别无非是：（1）Hashtable不允许key和value为null；（2）Hashtable是线程安全的。</p><p>但是 Hashtable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p><p><img src="/2020/04/09/JAVA-Container/hashtable-ds.png" alt="img"></p><p>jdk1.7 中 ConcurrentHashMap 所采用的 “<strong>分段锁</strong>“ 思想。相当于容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。</p><p><img src="/2020/04/09/JAVA-Container/hashmap-ds.png" alt="img"></p><p>jdk1.8 中 ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和synchronized 来保证并发安全。数据结构跟HashMap1.8 的结构类似，数组+链表/红黑二叉树。</p><p><img src="/2020/04/09/JAVA-Container/image-20200420161931082.png" alt="image-20200420161931082"></p><p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ul><li>CAS + Synchronized</li></ul><p>如果Key对应的数组元素为null，则通过CAS操作将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用synchronized关键字申请锁，然后进行操作。如果该put操作使得当前链表长度超过一定阈值（8），则将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))，插入操作完成之后如果所有元素的数量大于当前容量（默认16）*负载因子（默认0.75）就进行扩容。</p><p><img src="/2020/04/09/JAVA-Container/5cd1d2cfc3293.jpg" alt="img"></p><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ul><li>无锁</li></ul><p>对于读操作，由于数组被volatile关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个Node实例，它的Key值和hash值都由final修饰，不可变更，无须关心它们被修改后的可见性问题。而其Value及对下一个元素的引用由volatile修饰，可见性也有保障。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Key对应的数组元素的可见性，由Unsafe的getObjectVolatile方法保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/08/5cd1d2d22c6cb.jpg" alt="img"></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>不满足那就按照链表的方式遍历获取值。</li></ul><h4 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h4><p>put方法和remove方法都会通过addCount方法维护Map的size。size方法通过sumCount获取由addCount方法维护的Map的size。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>LinkedHashMap继承了HashMap，是Map接口的哈希表和链接列表实现。</p><p>哈希表的功能通过继承HashMap实现了。</p><p>LinkedHashMap还维护着一个双重链接链表。每次向linkedHashMap插入键值对，除了将其插入到哈希表的对应位置之外，还要将其插入到双向循环链表的尾部。</p><blockquote><p>此链表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p></blockquote><ul><li><p>基本数据结构：数组＋双向链表＋红黑树</p></li><li><p>因为继承HashMap，故常用属性和HashMap都一样。</p></li><li><p>对于几个node指针的分析： </p><ul><li>HashMap中的Map.Entry：只有next</li><li>LinkedHashMap中的Entry：before，after，next。其中next指针因为继承Map.Entry得到</li></ul></li><li><p>LHM和TreeMap都实现了entry的排序，有什么区别： </p><ul><li>TreeMap按照key排序，而LHM按照entry的插入or访问顺序排序。</li><li>因为LHM保持entry有序的方式是调整双向链表的before，after指针，而TreeMap保持entry有序的方式是对tree结构作调整，因此显然LHM的代价更小。</li></ul></li><li><p>特殊的构造函数LinkedHashMap(int,float,boolean) </p><ul><li>boolean=true时，迭代器顺序遵循LRU规则，最近最少访问的entry会被最先遍历到。这种Map非常适合构建LRU缓存。</li></ul></li><li><p>removeEldestEntry(Map.Entry) </p><ul><li>通过覆写，可以实现：当添加新的映射到map中时,强制自动移除过期的映射.</li><li>过期数据： <ul><li>双向链表按插入entry排序，则为最早插入双向链表的entry。</li><li>双向链表按访问entry排序，则为最近最少访问的entry。</li></ul></li></ul></li><li><p>和HashMap的比较 </p><ul><li><p>常规操作，如add,contains,remove等，比HashMap稍微差一些，因为需要维护双向链表。</p></li><li><p>视图迭代器执行时间长短的影响因素 </p><ul><li>LHM：和size成比例</li><li>HashMap：和capacity成比例</li><li>因此HashMap相对比较费时,因为 size&lt;=capacity。</li></ul></li><li><p>非线程安全，元素允许为null</p></li></ul></li><li><p>3个特殊回调方法 </p><ul><li>afterNodeRemoval，删除节点后，双向链表中unlink</li><li>afterNodeInsertion，插入节点后，是否删除eldest节点</li><li>afterNodeAccess，访问节点后，是否调整当前访问节点的顺序</li><li>这3个方法保证了双向链表的有序性。在HashMap中方法体为空，此处是进行了覆写。</li></ul></li></ul><p><strong>LinkedHashMap和HashMap有何不同？</strong></p><ul><li>数据结构上LinkedHashMap多了一条双向链表</li><li>迭代器的实现上不同，LinkedHashMap是从双向链表头开始遍历，HashMap是按照table[ ]的索引开始读。</li><li>性能上HashMap比LinkedHashMap要高，因为LinkedHashMap需要比HashMap多维护一条双向链表的开销</li></ul><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h4><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h4><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [3, 1, 4]</span></span><br></pre></td></tr></table></figure><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><p>下面为LinkedHashMap特有，别的属性全部继承HashMap;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header; <span class="comment">//头结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;<span class="comment">//顺序性； true(访问有序); false(插入有序)</span></span><br></pre></td></tr></table></figure><h5 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a>Entry类</h5><p>Entry继承了HashMap中的Node类，仅仅多了两个属性before和after用来维护双向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><h5 id="添加节点："><a href="#添加节点：" class="headerlink" title="添加节点："></a>添加节点：</h5><p>HashMap的put()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">                   </span><br><span class="line">    &#123;.........&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当table中索引位没有结点时创建新结点放入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当key相同时覆盖</span></span><br><span class="line">        &#123;.........&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当结点时红黑树结点时添加TreeNode，putTreeVal添加时调用了newTreeNode()</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历链表</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//链表尾部加入新节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//长度大于等于7转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//链表中发现相同的key覆盖</span></span><br><span class="line">                &#123;........&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否需要扩容，modCount++</span></span><br><span class="line">        &#123;...........&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap中重写的newNode()和newTreeNode()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建LinkedHashMap重写的Entry类</span></span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">           <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="comment">//调用维护双向链表的函数</span></span><br><span class="line">       linkNodeLast(p);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//维护双向链表的函数</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">       <span class="comment">//将尾部指针指向新添加的Entry  p</span></span><br><span class="line">       tail = p;</span><br><span class="line">       <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">           head = p;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//p的前驱指向之前的尾结点</span></span><br><span class="line">           p.before = last;</span><br><span class="line">           <span class="comment">//之前的尾节点的后继指向p</span></span><br><span class="line">           last.after = p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树结点的双向链表维护和上述的雷同，不赘述</span></span><br><span class="line">   <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">       linkNodeLast(p);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结方法过程：</p><ul><li>调用父类的put函数</li><li>put函数中创建新节点的函数newNode和newTreeNode被重写，多态的特性使得调用了LinkedHashMap重写的创建方式</li><li>在LinkedHashMap重写的函数中创建结点的同时维护了双向链表的关系</li></ul><h5 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h5><p>HashMap中的remove()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,<span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key在table中寻找对应的结点node</span></span><br><span class="line">    &#123;...........&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从链表或者红黑树中移除node，并维护链表或红黑树关系</span></span><br><span class="line">    &#123;...........&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完以上操作后调用的回调函数，在LinkedHashMap中重写</span></span><br><span class="line">    afterNodeRemoval(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap中重写的afterNodeRemoval()函数，用于维护remove后双向链表的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line"><span class="comment">//向下转型，转成LinkedHashMap重写的Entry</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="遍历分析"><a href="#遍历分析" class="headerlink" title="遍历分析"></a>遍历分析</h5><p>在概述中我们知道LinkedHashMap的遍历是有序的，而HashMap是无序的，分析一下原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;Object, Object&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        linkedHashMap.put(<span class="string">"源码"</span>,<span class="number">1</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"分析"</span>,<span class="number">2</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"博客"</span>,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Object&gt; keySet = linkedHashMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : keySet) &#123;</span><br><span class="line">            System.out.print(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">"源码"</span>, <span class="number">1</span>);</span><br><span class="line">        hashMap.put(<span class="string">"分析"</span>, <span class="number">2</span>);</span><br><span class="line">        hashMap.put(<span class="string">"博客"</span>, <span class="number">3</span>);</span><br><span class="line">        Set&lt;Object&gt; keySet2 = hashMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : keySet2) &#123;</span><br><span class="line">            System.out.print(obj);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">源码分析博客</span><br><span class="line">分析博客源码</span><br></pre></td></tr></table></figure><p>Map的遍历本质上是先遍历key再通过Key去获得value，返回的keySet的遍历方式有迭代器和for循环，增强for在编译后也是转换成迭代器实现，所以只需要分析LinkedHashMap的迭代器是如何实现的就可以知道它为何能有序输出了。（EntrySet也是同理，keySet只是在最后多调用了getKey()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回linkedHashMap中所有key的视图。</span></span><br><span class="line"><span class="comment"> * 改变linkedHashMap会影响到set，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果当迭代器迭代set时，linkedHashMap被修改(除非是迭代器自己的remove()方法)，迭代器的结果是不确定的。</span></span><br><span class="line"><span class="comment"> * set支持元素的删除，通过Iterator.remove、Set.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。不支持add和addAll方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回linkedHashMap中所有key的set视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//新建LinkedKeySet对象</span></span><br><span class="line">            ks = <span class="keyword">new</span> LinkedKeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建LinkedKeyIterator对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了LinkedHashIterator</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedKeyIterator</span> <span class="keyword">extends</span> <span class="title">LinkedHashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//调用父类的nextNode(在下面)获得node再返回Key</span></span><br><span class="line">        <span class="keyword">return</span> nextNode().getKey(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; next;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; current;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">        LinkedHashIterator() &#123;</span><br><span class="line">        <span class="comment">//初始化时从双向链表头开始读</span></span><br><span class="line">            next = head;</span><br><span class="line">            <span class="comment">//fail-fast机制</span></span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> next != <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinkedHashMap.<span class="function">Entry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            current = e;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//读取的是当前结点的后继</span></span><br><span class="line">            next = e.after;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>简单总结一下步骤，并和HashMap进行对比更加直观。</p><table><thead><tr><th align="center">步骤</th><th align="center">LinkedHashMap</th><th align="center">HashMap</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">获取keySet对象</td><td align="center">同左</td></tr><tr><td align="center">2</td><td align="center">获取keySet实现的迭代器</td><td align="center">同左</td></tr><tr><td align="center">3</td><td align="center">迭代器初始化next=双向链表头，获得next时获取的是后继</td><td align="center">迭代器初始化时获得table[ ]，next()是按照table的索引遍历</td></tr></tbody></table><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap是Map接口基于红黑树的实现，键值对是有序的。TreeMap根据键的自然顺序进行排序，或者根据创建map时提供的Comparator进行排序，使用哪种取决于使用的哪个构造方法。</p><ul><li>TreeMap继承于AbstractMap，实现了Map, Cloneable, NavigableMap, Serializable接口。</li><li>TreeMap 继承于AbstractMap，而AbstractMap实现了Map接口，并实现了Map接口中定义的方法，减少了其子类继承的复杂度；</li><li>TreeMap 实现了Map接口，成为Map框架中的一员，可以包含着key–value形式的元素；</li><li>TreeMap 实现了NavigableMap接口，意味着拥有了更强的元素搜索能力；</li><li>TreeMap 实现了Cloneable接口，实现了clone()方法，可以被克隆；</li><li>TreeMap 实现了Java.io.Serializable接口，支持序列化操作，可通过Hessian协议进行传输；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回元素比较器。如果是自然顺序，则返回null；</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; comparator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从fromKey到toKey的集合：含头不含尾</span></span><br><span class="line">    java.util.<span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从头到toKey的集合：不包含toKey</span></span><br><span class="line">    java.util.<span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回从fromKey到结尾的集合：包含fromKey</span></span><br><span class="line">    java.util.<span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中的第一个元素：</span></span><br><span class="line">    <span class="function">K <span class="title">firstKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中的最后一个元素：</span></span><br><span class="line">    <span class="function">K <span class="title">lastKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中所有key的集合：</span></span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中所有value的集合：</span></span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中的元素映射：</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回小于key的第一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lowerEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回小于key的第一个键：</span></span><br><span class="line">    <span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回小于等于key的第一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">floorEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回小于等于key的第一个键：</span></span><br><span class="line">    <span class="function">K <span class="title">floorKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回大于或者等于key的第一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">ceilingEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回大于或者等于key的第一个键：</span></span><br><span class="line">    <span class="function">K <span class="title">ceilingKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回大于key的第一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">higherEntry</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回大于key的第一个键：</span></span><br><span class="line">    <span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中第一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中最后一个元素：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">lastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中第一个元素，并从集合中删除：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollFirstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回集合中最后一个元素，并从集合中删除：</span></span><br><span class="line">    Map.<span class="function">Entry&lt;K,V&gt; <span class="title">pollLastEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回倒序的Map集合：</span></span><br><span class="line">    java.util.<span class="function">NavigableMap&lt;K,V&gt; <span class="title">descendingMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">NavigableSet&lt;K&gt; <span class="title">navigableKeySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Map集合中倒序的Key组成的Set集合：</span></span><br><span class="line">    <span class="function">NavigableSet&lt;K&gt; <span class="title">descendingKeySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    java.util.<span class="function">NavigableMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> fromInclusive,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       K toKey, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.util.<span class="function">NavigableMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line"></span><br><span class="line">    java.util.<span class="function">NavigableMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用元素自然排序"><a href="#使用元素自然排序" class="headerlink" title="使用元素自然排序"></a>使用元素自然排序</h4><p>在使用自然顺序排序时候，需要区分两种情况：一种是Jdk定义的对象，一种是我们应用自己定义的对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedTest</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">SortedTest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortedTest</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义对象，实现compareTo(T o)方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(SortedTest sortedTest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.age - sortedTest.getAge();</span><br><span class="line">        <span class="comment">//为0时候，两者相同：</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//大于0时，传入的参数小：</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//小于0时，传入的参数大：</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//自然顺序比较</span></span><br><span class="line">        naturalSort();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//自然排序顺序：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">naturalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种情况：Integer对象</span></span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMapFirst = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">        treeMapFirst.put(<span class="number">1</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapFirst.put(<span class="number">6</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapFirst.put(<span class="number">3</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapFirst.put(<span class="number">10</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapFirst.put(<span class="number">7</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapFirst.put(<span class="number">13</span>,<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(treeMapFirst.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种情况:SortedTest对象</span></span><br><span class="line">        TreeMap&lt;SortedTest,String&gt; treeMapSecond = <span class="keyword">new</span> TreeMap&lt;SortedTest, String&gt;();</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">10</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">1</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">13</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">4</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">0</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMapSecond.put(<span class="keyword">new</span> SortedTest(<span class="number">9</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(treeMapSecond.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自然顺序比较中，需要让被比较的元素实现Comparable接口，否则在向集合里添加元素时报：”java.lang.ClassCastException: com.jiaboyan.collection.map.SortedTest cannot be cast to java.lang.Comparable”异常；</p><p>这是因为在调用put()方法时，会将传入的元素转化成Comparable类型对象，所以当你传入的元素没有实现Comparable接口时，就无法转换，遍会报错；</p><h4 id="使用自定义比较器排序"><a href="#使用自定义比较器排序" class="headerlink" title="使用自定义比较器排序"></a>使用自定义比较器排序</h4><p>使用自定义比较器排序，需要在创建TreeMap对象时，将自定义比较器对象传入到TreeMap构造方法中；</p><p>自定义比较器对象，需要实现Comparator接口，并实现比较方法compare(T o1,T o2)；</p><p>值得一提的是，使用自定义比较器排序的话，被比较的对象无需再实现Comparable接口了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SortedTest</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedTestComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">SortedTest</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//自定义比较器：实现compare(T o1,T o2)方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(SortedTest sortedTest1, SortedTest sortedTest2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = sortedTest1.getAge() - sortedTest2.getAge();</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;<span class="comment">//为0时候，两者相同：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;<span class="comment">//大于0时，后面的参数小：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//小于0时，前面的参数小：</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//自定义顺序比较</span></span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义排序顺序:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeMap&lt;SortedTest,String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;SortedTest, String&gt;(<span class="keyword">new</span> SortedTestComparator());</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">10</span>),<span class="string">"hello"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">21</span>),<span class="string">"my"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">15</span>),<span class="string">"name"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">2</span>),<span class="string">"is"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">1</span>),<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> SortedTest(<span class="number">7</span>),<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>不同点</th><th>HashMap</th><th>TreeMap</th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表+红黑树</td><td>红黑树</td></tr><tr><td>是否有序</td><td>否</td><td>是</td></tr><tr><td>是否实现NavigableMap</td><td>否</td><td>是</td></tr><tr><td>增删改查操作的时间复杂度</td><td>O(1)</td><td>log(n)</td></tr></tbody></table><p><strong>相同点</strong></p><ul><li>都以键值对的形式存储数据。</li><li>都继承了AbstractMap，实现了Map、Cloneable、Serializable。</li><li>都是非同步的。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th align="center">实现类</th><th align="center">数据结构</th><th align="center">是否线程安全</th><th align="center">key是否可为null</th><th align="center">是否有序</th></tr></thead><tbody><tr><td align="center">HashMap</td><td align="center">数组+链表+红黑树（since JDK1.8）</td><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">Hashtable</td><td align="center">数组+链表</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">LinkedHashMap</td><td align="center">数组+链表+红黑树(since JDK1.8)+ 双重链接列表</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">TreeMap</td><td align="center">红黑树</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr></tbody></table><h2 id="Set介绍"><a href="#Set介绍" class="headerlink" title="Set介绍"></a>Set介绍</h2><p>Set接口继承了Collection接口。特点是不保存重复的元素。</p><h3 id="equals和hashCode方法"><a href="#equals和hashCode方法" class="headerlink" title="equals和hashCode方法"></a>equals和hashCode方法</h3><h4 id="关键结论："><a href="#关键结论：" class="headerlink" title="关键结论："></a>关键结论：</h4><ul><li>无论何时重写<code>equals()</code>方法，就必须重写<code>hashCode()</code>的方法</li><li><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符</li><li><code>hashCode()</code>方法对底层是散列表的对象有提升性能的功能</li><li>同一个对象(如果该对象没有被修改)：那么重复调用<code>hashCode()</code>那么返回的int是相同的！</li><li><code>hashCode()</code>方法默认是由对象的地址转换而来的（类似于逻辑地址）</li><li><code>equals()</code>方法还有5个默认的原则：<ul><li>自反性—&gt;只要对象的不为null，x.equals(x)应该返回的是true</li><li>一致性—&gt;只要对象没有被修改，那么多次调用还是返回对应的结果！</li><li>传递性—&gt;<code>x.equals(y)</code>和<code>y.equals(z)</code>都返回true，那么可以得出：<code>x.equals(z)</code>返回true</li><li>对称性—&gt;<code>x.equals(y)</code>和<code>y.equals(x)</code>结果应该是相等的。</li><li>传入的参数为null，返回的是false</li></ul></li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><strong>散列（哈希）函数</strong></p><ul><li>把任意长度的输入（又叫做预映射）通过散列算法变换成固定长度的输出，该输出就是散列值。</li><li>或者说一种将任意长度的消息压缩到某一固定长度消息的函数。</li></ul><p><strong>性质</strong></p><ol><li>如果散列表中存在和散列原始输入K相等的记录，那么K必定在f(K)的存储位置上</li><li>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞</li><li>如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同</li></ol><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>hashCode是Object的一个方法，hashCode方法返回一个<code>hash code</code>值。在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>且这个方法是为了更好的支持hash表，比如String，Set，HashTable、HashMap等。</p><ol><li>hashCode的存在主要是为了查找的快捷性，hashCode是用来在散列存储结构中确定对象的存储地址的</li><li>如果两个对象equals相等，那么这两个对象的HashCode一定也相同</li><li>如果对象的equals方法被重写，那么对象的HashCode方法也一定重写</li></ol><h4 id="String中使用"><a href="#String中使用" class="headerlink" title="String中使用"></a>String中使用</h4><ul><li>可以<strong>直接</strong>使用String.equals()来<strong>判断两个字符串</strong>是否相等！</li></ul><p><img src="/2020/04/09/JAVA-Container/psb-1587388603144.png" alt="img"></p><p><img src="/2020/04/09/JAVA-Container/psb-1587388621180.png" alt="img"></p><h4 id="Collection中使用"><a href="#Collection中使用" class="headerlink" title="Collection中使用"></a>Collection中使用</h4><p>Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；</p><p>后者元素无序，但元素不可重复。那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？<strong>这就是Object.equals方法了</strong>。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。这显然会大大降低效率。</p><p>于是，Java采用了哈希表的原理。hash算法也称为散列算法，是将数据依特定hash算法直接指定到一个地址上。</p><p>即调用键值（key）对象的hashCode()方法，在无重写时返回的是对象的hash code（可以理解为该对象的内部地址）</p><p>这样一来，当集合要添加新的元素时，会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，就不会让其加入操作成功。不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大低了，几乎只需要一两次。</p><h4 id="为什么重写eqauls一定要重写hashcode"><a href="#为什么重写eqauls一定要重写hashcode" class="headerlink" title="为什么重写eqauls一定要重写hashcode"></a>为什么重写eqauls一定要重写hashcode</h4><p>由于为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没就不必在进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的。</p><p>其实简单的说就是为了保证同一个对象，保证在equals相同的情况下hashcode值必定相同，如果重写了equals而未重写hashcode方法，可能就会出现两个没有关系的对象equals相同的（因为equal都是根据对象的特征进行重写的），但hashcode却不相同的。</p><blockquote><p>如果只重写equals，比如认定id相同的对象相等，在不重写hashCode时（不按照id值返回对应hash code值），存在两个相同id的对象，理论上要认定为相等，若要存储到去重的集合中时，就会将两个都保存而达不到去重目的。</p><p>不重写equals方法，比较的是对象地址，即<code>==</code>等值比较。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet是依赖于HashMap的。所以HashSet的数据结构也是哈希表+链表+红黑树。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会收到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/2020/04/09/JAVA-Container/1568615813311.png" alt="1568615813311"></p><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h4><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals()</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>基于TreeMap的NavigableSet实现。使用元素的自然顺序对元素进行排序，或者根据创建set时提供的Comparator进行排序，具体取决于使用的构造方法。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><h3 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h4><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h4><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li></ul><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="并发集合类是什么？"><a href="#并发集合类是什么？" class="headerlink" title="并发集合类是什么？"></a>并发集合类是什么？</h3><p>Java1.5并发包（java.util.concurrent）<strong>包含线程安全集合类，允许在迭代时修改集合</strong>。</p><ul><li>迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。</li><li>一部分类为：<ul><li>CopyOnWriteArrayList</li><li>ConcurrentHashMap</li><li>CopyOnWriteArraySet</li></ul></li></ul><h3 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h3><ul><li><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p><strong>共同点：</strong></p><ul><li>从存储结构和实现来讲基本上都是相同的，都是实现Map接口~</li></ul><p><strong>区别：</strong></p><ul><li><strong>同步性：</strong><ul><li>HashMap是非同步的</li><li>Hashtable是同步的</li><li>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap</li></ul></li><li><strong>是否允许为null：</strong><ul><li>HashMap允许为null</li><li>Hashtable不允许为null</li></ul></li><li><strong>contains方法</strong><ul><li>Hashtable有contains方法</li><li>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</li></ul></li><li><strong>继承不同：</strong><ul><li>HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</li><li>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</li></ul></li></ul><h3 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put（）</code>向map中添加元素</td><td>调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h3 id="HashMap中的key可以是任何对象或数据类型吗"><a href="#HashMap中的key可以是任何对象或数据类型吗" class="headerlink" title="HashMap中的key可以是任何对象或数据类型吗?"></a><strong>HashMap中的key可以是任何对象或数据类型吗</strong>?</h3><ul><li>可以为null，但不能是可变对象，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。</li><li>如果可变对象在 HashMap 中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。</li></ul><h3 id="Hash冲突的解决办法"><a href="#Hash冲突的解决办法" class="headerlink" title="Hash冲突的解决办法"></a>Hash冲突的解决办法</h3><ul><li>链地址法</li><li>开放地址法（向后一位）</li><li>再哈希法</li></ul><h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p>Java 集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如 ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，ArrayList 底层维护的是一个数组；LinkedList 是链表结构的；HashSet 依赖的是哈希表，每种容器都有自己特有的数据结构。</p><p>因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java 引入了迭代器模式！</p><p>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。</p><p><strong>迭代器模式</strong>：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历ArrayList集合</span></span><br><span class="line">    Iterator&lt;String&gt; listIt = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(listIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历Set集合</span></span><br><span class="line">    Iterator&lt;String&gt; setIt = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(setIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历LinkedList集合</span></span><br><span class="line">    Iterator&lt;String&gt; linkIt = linkList.iterator();</span><br><span class="line">    <span class="keyword">while</span>(linkIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造相同hash的字符串进行攻击该如何处理？"><a href="#构造相同hash的字符串进行攻击该如何处理？" class="headerlink" title="构造相同hash的字符串进行攻击该如何处理？"></a>构造相同hash的字符串进行攻击该如何处理？</h3><p><strong>攻击原理：</strong></p><p>当客户端发送一个请求到服务器，如果该请求中带有参数，服务器端会将 参数名-参数值 作为 key-value 保存在 HashMap 中。如果有人恶意构造请求，在请求中加入大量相同 hash 值的 String 参数名（key），那么在服务器端用于存储这些 key-value 对的 HashMap 会被强行退化成链表，如图：</p><p><img src="https://frank-lam.github.io/fullstack-tutorial/assets/hash-to-badlink.png" alt="img"></p><p><strong>怎么处理</strong></p><ol><li>限制 POST 和 GET 请求的参数个数</li><li>限制 POST 请求的请求体大小</li><li>Web Application FireWall（WAF）</li></ol><p><strong>JDK7如何处理</strong></p><p>HashMap 会动态的使用一个专门 TreeMap 实现来替换掉它。</p><h3 id="Set如何保证元素不重复"><a href="#Set如何保证元素不重复" class="headerlink" title="Set如何保证元素不重复?"></a>Set如何保证元素不重复?</h3><p>在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。</p><ul><li>TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值 </li><li>HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束</li></ul><p>在HashSet中，基本的操作都是有HashMap底层实现的，因为HashSet底层是用HashMap存储数据的。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p><p>TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p><p>TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。TreeSet是用compareTo()来判断重复元素的。</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java container </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-JVM</title>
      <link href="/2020/04/08/JAVA-JVM/"/>
      <url>/2020/04/08/JAVA-JVM/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java虚拟机学习</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Java文件运行图示："><a href="#Java文件运行图示：" class="headerlink" title="Java文件运行图示："></a>Java文件运行图示：</h3><p><img src="/2020/04/08/JAVA-JVM/image-20200408221009731.png" alt="image-20200408221009731"></p><p>整个过程可以归结为三个步骤：</p><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><p><strong>Java1.8 图示</strong></p><blockquote><p><strong>方法区</strong>更改为<strong>元空间</strong></p></blockquote><p><img src="/2020/04/08/JAVA-JVM/image-20200408221348129.png" alt="image-20200408221348129"></p><p><strong>另一种图示</strong>（差别不大）</p><p><img src="/2020/04/08/JAVA-JVM/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVmJpYmFz.jpg" alt></p><p>下文介绍的点包括：类加载机制；JVM各区（5块）；垃圾回收机制</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p> 对于程序员编写的<code>HelloWorld.java</code> 文件，<strong>JVM</strong> 是不认识的，它需要一个 <strong>编译</strong> ，让其成为一个JVM可读的二进制文件 <strong>HelloWorld.class</strong>。当 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM中。</p><p><img src="/2020/04/08/JAVA-JVM/image-20200409095917129.png" alt="image-20200409095917129"></p><h3 id="JVM各区"><a href="#JVM各区" class="headerlink" title="JVM各区"></a>JVM各区</h3><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等。<strong>类加载器将 .class 文件搬过来就是先丢到这一块上</strong></p><p>方法区（也称为永久代）是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。<strong>元空间存储类的元信息，静态变量和常量池等放入堆中。</strong>元空间位于本地内存中，而不是虚拟机内存中。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>对于 本地方法栈 或者 本地方法接口 这两个名词，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p><h2 id="类加载机制详解"><a href="#类加载机制详解" class="headerlink" title="类加载机制详解"></a>类加载机制详解</h2><h3 id="类加载机制概念"><a href="#类加载机制概念" class="headerlink" title="类加载机制概念"></a>类加载机制概念</h3><p><strong>JVM将Class文件中描述类的数据加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制</strong>。</p><p>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的<strong>元信息对象</strong>，通过该元信息对象可以获知<strong>Class的结构信息：如构造函数，属性和方法</strong>等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这里就是我们经常能见到的Class类。</p><h3 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h3><ul><li>类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识（0xCAFEBABE）</li><li>ClassLoader只负责class文件的加载。至于它是否可以运行，则由Execution Engine决定</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</li><li>Class对象是存放在堆区的</li></ul><h3 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h3><ol><li>class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li><li>class file加载到JVM中，被称为DNA元数据模板，放在方法区</li><li>在.calss文件 -&gt; JVM -&gt; 最终成为元数据模板，此过程就要一个运输工具（类装载器），扮演一个快递员的角色</li></ol><hr><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类从被加载到虚拟机内存主要包括：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。（使用和卸载表示类卸载出内存为止，以上顺序都只是说开始的顺序，实际过程中是交叉的混合式进行的，加载过程中可能就已经开始验证了）</p><p><img src="/2020/04/08/JAVA-JVM/640-1586397093651.webp" alt="img"></p><h4 id="1-加载（Loading）："><a href="#1-加载（Loading）：" class="headerlink" title="1. 加载（Loading）："></a>1. 加载（Loading）：</h4><ol><li>通过一个类的全限定名获取定义此类的二进制字节流（加载到内存）</li><li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><p>加载 <code>.calss</code> 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩文件中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，比如 JSP 应用</li><li>从专有数据库提取.class 文件，比较少见</li><li>从加密文件中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h4 id="2-连接（Linking）"><a href="#2-连接（Linking）" class="headerlink" title="2. 连接（Linking）"></a>2. 连接（Linking）</h4><h5 id="验证（Verify）"><a href="#验证（Verify）" class="headerlink" title="验证（Verify）"></a>验证（Verify）</h5><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong></li></ul><h5 id="准备（Prepare）"><a href="#准备（Prepare）" class="headerlink" title="准备（Prepare）"></a>准备（Prepare）</h5><ul><li>为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 。</li><li>无初始值时，设置该类变量的默认初始值，即<strong>零值</strong></li></ul><table><thead><tr><th align="left">数据类型</th><th align="left">零值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">0L</td></tr><tr><td align="left">short</td><td align="left">(short)0</td></tr><tr><td align="left">char</td><td align="left">‘\u0000’</td></tr><tr><td align="left">byte</td><td align="left">(byte)0</td></tr><tr><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">float</td><td align="left">0.0f</td></tr><tr><td align="left">double</td><td align="left">0.0d</td></tr><tr><td align="left">reference</td><td align="left">null</td></tr></tbody></table><ul><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</li><li>注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量i在准备阶只会被赋值为0，初始化时才会被赋值为1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 这里被final修饰的变量j，直接成为常量，编译时就会被分配为2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h5 id="解析（Resolve）"><a href="#解析（Resolve）" class="headerlink" title="解析（Resolve）"></a>解析（Resolve）</h5><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等</li></ul><h4 id="3-初始化（Initialization）"><a href="#3-初始化（Initialization）" class="headerlink" title="3. 初始化（Initialization）"></a>3. 初始化（Initialization）</h4><ul><li>初始化阶段就是执行<strong>类构造器方法</strong><clinit>()的过程</clinit></li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><clinit>()不同于类的构造器（构造器是虚拟机视角下的<init>()）</init></clinit></li><li>若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕</clinit></clinit></li><li>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁</clinit></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num1 = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// num2写在定义变量之前，为什么不会报错呢？？</span></span><br><span class="line">        num2 = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 這裡直接打印可以吗？报错，非法的前向引用，可以赋值，但不可调用</span></span><br><span class="line">        System.out.println(num2);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num2在准备阶段就被设置了默认初始值0，初始化阶段又将10改为20</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num2 = <span class="number">20</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(num1);   <span class="comment">//10</span></span><br><span class="line">        System.out.println(num2);   <span class="comment">//20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p>Java程序对类的使用方式分为：主动使用和被动使用。虚拟机规范规定<strong>有且只有5种情况必须立即对类进行“初始化”</strong>，即类的主动使用。</p><ul><li>创建类的实例、访问某个类或接口的静态变量，或者对该静态变量赋值、调用类的静态方法（即遇到new、getstatic、putstatic、invokestatic这四条字节码指令时）</li><li>反射</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7 开始提供的动态语言支持：<code>java.lang.invoke.MethodHandle</code>实例的解析结果，<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</li></ul><p>除以上五种情况，其他使用Java类的方式被看作是对<strong>类的被动使用</strong>，都不<strong>会导致类的初始化</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只输出SupperClass int 123,不会输出SubClass init</span></span><br><span class="line">        <span class="comment">// 对于静态字段，只有直接定义这个字段的类才会被初始化</span></span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SupperClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    publicstaticint value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</li></ul><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++ 语言实现，嵌套在JVM 内部</li><li>它用来加载Java的核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resource.jar</code>或<code>sun.boot.class.path</code>路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自 <code>java.lang.ClassLoader</code>，没有父加载器</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Boostrap 启动类加载器只加载名为java、Javax、sun等开头的类</li></ul><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li><li>派生于 ClassLoader</li><li>父类加载器为启动类加载器</li><li>从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext</code> 子目录（扩展目录）下加载类库。如果用户创建的JAR 放在此目录下，也会自动由扩展类加载器加载</li></ul><h4 id="应用程序类加载器（也叫系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（也叫系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（也叫系统类加载器，AppClassLoader）"></a>应用程序类加载器（也叫系统类加载器，AppClassLoader）</h4><ul><li>java语言编写，由 <code>sun.misc.Lanucher$AppClassLoader</code> 实现</li><li>派生于 ClassLoader</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量<code>classpath</code>或系统属性<code>java.class.path</code> 指定路径下的类库</li><li>该类加载是<strong>程序中默认的类加载器</strong>，一般来说，Java应用的类都是由它来完成加载的</li><li>通过 <code>ClassLoader#getSystemClassLoader()</code> 方法可以获取到该类加载器</li></ul><h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>在Java的日常应用程序开发中，类的加载几乎是由3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p><h5 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h5><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源（可以从数据库、云端等指定来源加载类）</li><li>防止源码泄露（Java代码容易被反编译，如果加密后，自定义加载器加载类的时候就可以先解密，再加载）</li></ul><h5 id="用户自定义加载器实现步骤"><a href="#用户自定义加载器实现步骤" class="headerlink" title="用户自定义加载器实现步骤"></a>用户自定义加载器实现步骤</h5><ol><li>开发人员可以通过继承抽象类 <code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是JDK1.2之后已经不建议用户去覆盖loadClass()方式，而是建议把自定义的类加载逻辑写在findClass()方法中</li><li>编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ol><h4 id="ClassLoader常用方法"><a href="#ClassLoader常用方法" class="headerlink" title="ClassLoader常用方法"></a>ClassLoader常用方法</h4><p>ClassLoader类，是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getParent()</td><td align="left">返回该类加载器的超类加载器</td></tr><tr><td align="left">loadClass(String name)</td><td align="left">加载名称为name的类，返回java.lang.Class类的实例</td></tr><tr><td align="left">findClass(String name)</td><td align="left">查找名称为name的类，返回java.lang.Class类的实例</td></tr><tr><td align="left">findLoadedClass(String name)</td><td align="left">查找名称为name的已经被加载过的类，返回java.lang.Class类的实例</td></tr><tr><td align="left">defineClass(String name, byte[] b, int off, int len)</td><td align="left">把字节数组b中内容转换为一个Java类，返回java.lang.Class类的实例</td></tr><tr><td align="left">resolveClass(Class&lt;?&gt; c)</td><td align="left">连接指定的一个Java类</td></tr></tbody></table><h4 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h4><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类的时候才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交给父类处理，它是一种任务委派模式。</p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li></ul><p><img src="/2020/04/08/JAVA-JVM/image-20200409144840425.png" alt="image-20200409144840425"></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>避免类的重复加载，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</li><li>保护程序安全，防止核心API被随意篡改，避免用户自己编写的类动态替换 Java的一些核心类，比如我们自定义类：java.lang.String</li></ul><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完成类名必须一致，包括包名</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</li></ul><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>如果我们自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法就是因为加载的是<code>rt.jar</code>包中的String类。这样就可以保证对java核心源代码的保护，这就是简单的沙箱安全机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如自定义的String类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">String</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//报错说没有main方法就是因为加载的是`rt.jar`包中的String类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;sout;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><ul><li>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式，可以“被破坏”，只要我们自定义类加载器，<strong>重写loadClass()方法</strong>，指定新的加载逻辑就破坏了，重写findClass()方法不会破坏双亲委派。</li><li>双亲委派模型有一个问题：顶层ClassLoader，无法加载底层ClassLoader的类。典型例子JNDI、JDBC，所以加入了线程上下文类加载器（Thread Context ClassLoader）,可以通过<code>Thread.setContextClassLoaser()</code>设置该类加载器，然后顶层ClassLoader再使用<code>Thread.getContextClassLoader()</code>获得底层的ClassLoader进行加载。</li><li>Tomcat中使用了自定ClassLoader，并且也破坏了双亲委托机制。每个应用使用WebAppClassloader进行单独加载，他首先使用WebAppClassloader进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个tomcat中可以部署多个项目，每个项目中存在很多相同的class文件（很多相同的jar包），他们加载到jvm中可以做到互不干扰。</li><li>利用破坏双亲委派来实现<strong>代码热替换</strong>（每次修改类文件，不需要重启服务）。因为一个Class只能被一个ClassLoader加载一次，否则会报<code>java.lang.LinkageError</code>。当我们想要实现代码热部署时，可以每次都new一个自定义的ClassLoader来加载新的Class文件。JSP的实现动态修改就是使用此特性实现。</li></ul><h2 id="运行时数据区详解"><a href="#运行时数据区详解" class="headerlink" title="运行时数据区详解"></a>运行时数据区详解</h2><p><img src="/2020/04/08/JAVA-JVM/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9iVmJpYmFz.jpg" alt></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h3 id="程序计数器-1"><a href="#程序计数器-1" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p><strong>Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p>实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。<strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> </p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</li></ul><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： </p><ol><li><strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，</strong></li><li><strong>而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> </li></ol><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="img"></p><p>上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1（Eden 区-&gt;Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="方法区-1"><a href="#方法区-1" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>方法区也被称为永久代。</p><p><strong>在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</strong></p><h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。</p><ul><li>HotSpot 是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。</li></ul></blockquote><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>JDK 1.8 之后的元空间参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><p>整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。</p><blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p></blockquote><p>对这块区域进行垃圾回收的主要目标是对<strong>常量池的回收和对类的卸载</strong>，当使用永久代来进行垃圾回收，很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放）。</p><p><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><p><img src="/2020/04/08/JAVA-JVM/26038433.jpg" alt="img">——图片来源：<a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"abc"</span>;</span><br><span class="line">    String s2 = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    System.out.println(s1 == s3); <span class="comment">//false</span></span><br><span class="line">  System.out.println(s1 == s3.intern()); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，<code>s1</code>和<code>s2</code>由于是直接初始化的相同的String类型变量，这些变量储存在常量池中（类似HashSet无序唯一），因此她们的内存地址是相同的。而<code>s3</code>是显示的通过<code>new</code>关键字初始化，那么<code>s3</code>所代表的对象就直接在堆内存中存放，所以<code>s3</code>和另外两个的内存地址都不同。</p><p>运行时常量池不要求一定只有在编译器产生的才能进入，运行期间也可以将新的常量放入池中，这种特性被开发人员利用比较多的就是String.intern()方法，这个方法可以将储存在堆内存中的对象放入到常量池中，所以此时的s3和s1内存地址相同。</p><p>而String类有一个<code>intern()</code>方法，这个方法可以将储存在堆内存中的对象放入到常量池中，所以此时的<code>s3</code>和<code>s1</code>内存地址相同。</p><h4 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h4><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，它也实现了对象的共享。</p><p>字符串常量池：在编译阶段就把所有字符串文字放到一个常量池中。</p><ul><li>节省内存空间：常量池中如果有对应的字符串，那么则返回该对象的引用，从而不必再次创建一个新对象。</li><li>节省运行时间：比较字符串时，== 比equals()快。对于两个引用变量，== 判断引用是否相等，也就可以判断实际值是否相等。</li></ul><p><em>双等号（==）的含义</em><br><em>- 基本数据类型之间使用双等号，比较的是数值。</em><br><em>- 复合数据类型（类）之间使用双等号，比较的是对象的引用地址是否相等。</em></p><h4 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h4><p>Byte、Short、Integer、Long、Character、Boolean、String这7种包装类都各自实现了自己的常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：</span></span><br><span class="line">Integer i1 = <span class="number">20</span>;</span><br><span class="line">Integer i2 = <span class="number">20</span>;</span><br><span class="line">System.out.println(i1=i2);<span class="comment">//输出TRUE</span></span><br></pre></td></tr></table></figure><p>Byte、Short、Integer、Long、Character这5种包装类都默认创建了数值[-128 , 127]的缓存数据。<strong>当对这5个类型的数据不在这个区间内的时候，将会去创建新的对象，并且不会将这些新的对象放入常量池中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntegerCache.low = -128</span></span><br><span class="line"><span class="comment">//IntegerCache.high = 127</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line">Integer i1 = <span class="number">200</span>;</span><br><span class="line">Integer i2 = <span class="number">200</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//返回FALSE</span></span><br></pre></td></tr></table></figure><p>Float 和Double 没有实现常量池。</p><h4 id="String包装类与常量池"><a href="#String包装类与常量池" class="headerlink" title="String包装类与常量池"></a>String包装类与常量池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先检查字符串常量池中有没有"aaa"，如果字符串常量池中没有，则创建一个，</span></span><br><span class="line"><span class="comment">// 然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"aaa"</span></span><br><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br></pre></td></tr></table></figure><p>当以上代码运行时，JVM会到字符串常量池查找 “aaa” 这个字面量对象是否存在？</p><ul><li><strong>存在</strong>：则返回该对象的引用给变量 <strong>str1</strong> 。</li><li><strong>不存在</strong>：则在堆中创建一个相应的对象，将创建的对象的引用存放到常量池中，同时将引用返回给变量 <strong>str1</strong> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"aaa"</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">// 返回TRUE</span></span><br></pre></td></tr></table></figure><p>因为变量<strong>str1</strong> 和<strong>str2</strong> 都指向同一个对象，所以返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);<span class="comment">// 堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">// 返回FALSE</span></span><br></pre></td></tr></table></figure><p>当我们使用了<strong>new</strong>来构造字符串对象的时候，不管字符串常量池中是否有相同内容的对象的引用，新的字符串对象都会创建。因为两个指向的是不同的对象，所以返回FALSE 。</p><p><img src="/2020/04/08/JAVA-JVM/2019-3String-Pool-Java1-450x249.png" alt="String-Pool-Java"></p><h5 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h5><p>String 类型的常量池比较特殊。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure><p>对于使用了new 创建的字符串对象，如果想要将这个对象引用到字符串常量池，可以使用intern() 方法。调用intern() 方法后，检查字符串常量池中是否有这个对象的引用，并做如下操作：</p><ul><li>存在：直接返回对象引用给变量。</li><li>不存在：将这个对象引用加入到常量池，再返回对象引用给变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String interns = str3.intern();</span><br><span class="line">System.out.println(interns == str1);<span class="comment">// 返回TRUE</span></span><br></pre></td></tr></table></figure><p><strong>假定常量池中都没有以下字面量的对象，以下创建了多少个对象呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"efg"</span>;</span><br><span class="line">String str3 = <span class="string">"abc"</span> + <span class="string">"efg"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象      </span></span><br><span class="line">String str5 = <span class="string">"abcefg"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>答案是三个。第一个：”abc” ，第二个：”efg”，第三个：”abc”+”efg”（”abcefg”）</p><p><strong>String str5 = “abcefg”; 这句代码并没有创建对象</strong>，它从常量池中找到了”abcefg” 的引用，所有str3 == str5 返回TRUE，因为它们都指向一个相同的对象。</p><p><strong>什么情况下会将字符串对象引用自动加入字符串常量池？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在这两种情况下会将对象引用自动加入到常量池</span></span><br><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"aa"</span>+<span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他方式下都不会将对象引用自动加入到常量池，如下：</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String str4 = <span class="function">New <span class="title">StringBuilder</span><span class="params">(<span class="string">"aa"</span>)</span>.<span class="title">append</span><span class="params">(<span class="string">"a"</span>)</span>.<span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">StringBuilder sb = <span class="function">New <span class="title">StringBuilder</span><span class="params">()</span></span>;</span><br><span class="line">sb.append(<span class="string">"aa"</span>);</span><br><span class="line">sb.append(<span class="string">"a"</span>);</span><br><span class="line">String str5 = sb.toString();</span><br></pre></td></tr></table></figure><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="/2020/04/08/JAVA-JVM/image-20200409200827633.png" alt="image-20200409200827633"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式"></p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><p><img src="/2020/04/08/JAVA-JVM/image-20200409201317229.png" alt="image-20200409201317229"></p><ul><li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li></ul><p><img src="/2020/04/08/JAVA-JVM/image-20200409201401441.png" alt="image-20200409201401441"></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"User"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程图示"><a href="#流程图示" class="headerlink" title="流程图示"></a>流程图示</h3><p><img src="/2020/04/08/JAVA-JVM/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTYwNTM0Nw.jpg" alt></p><p>我来<strong>宏观简述</strong>一下我们的例子中的工作流程：</p><ul><li>1、通过<code>java.exe</code>运行<code>UserTest.class</code>，随后被加载到JVM中，<strong>元空间存储着类的信息</strong>(包括类的名称、方法信息、字段信息..)。</li><li>2、然后JVM找到UserTest的主函数入口(main)，为main函数创建栈帧，开始执行main函数</li><li>3、main函数的第一条命令是<code>User user = new User();</code>就是让JVM创建一个User对象，但是这时候方法区中没有User类的信息，所以JVM马上加载User类，把USer类的类型信息放到方法区中(元空间)</li><li>4、加载完User类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的User实例分配内存, 然后调用构造函数初始化User实例，这个<strong>User实例持有着指向方法区的User类的类型信息</strong>（其中包含有方法表，java动态绑定的底层实现）的引用</li><li>5、当使用<code>user.setName(&quot;User&quot;);</code>的时候，JVM<strong>根据user引用找到User对象</strong>，然后根据User对象持有的引用定位到方法区中User类的类型信息的<strong>方法表</strong>，获得<code>setName()</code>函数的字节码的地址</li><li>6、为<code>setName()</code>函数创建栈帧，开始运行<code>setName()</code>函数</li></ul><h2 id="GC机制"><a href="#GC机制" class="headerlink" title="GC机制"></a>GC机制</h2><h3 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h3><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB。</p><p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:TargetSurvivorRatio 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xms来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src="/2020/04/08/JAVA-JVM/640.png" alt="img"></p><h3 id="判断对象是否要被清除"><a href="#判断对象是否要被清除" class="headerlink" title="判断对象是否要被清除"></a>判断对象是否要被清除</h3><p><img src="/2020/04/08/JAVA-JVM/640.jpg" alt="img"></p><p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>两个基础的计算方法：</p><ol><li><strong>引用计数法</strong>：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</li><li><strong>可达性分析法</strong>：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。</li></ol><p>在Java语言汇总能作为GC Roots的对象分为以下几种：（了解）</p><ol><li>虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li>方法区中静态变量所引用的对象（静态变量）</li><li>方法区中常量引用的对象</li><li>本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li>已启动的且未终止的Java线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h3 id="堆空间对象分配"><a href="#堆空间对象分配" class="headerlink" title="堆空间对象分配"></a>堆空间对象分配</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h3><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src="/2020/04/08/JAVA-JVM/640-1586441892259.webp" alt="img"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src="/2020/04/08/JAVA-JVM/640-1586441903245.webp" alt="img"></p><p>不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src="/2020/04/08/JAVA-JVM/640-1586441909525.png" alt="img"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><h3 id="各种各样的垃圾回收器（了解）"><a href="#各种各样的垃圾回收器（了解）" class="headerlink" title="各种各样的垃圾回收器（了解）"></a>各种各样的垃圾回收器（了解）</h3><p><img src="/2020/04/08/JAVA-JVM/640-1586441941062.jpg" alt="img"></p><p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p><p>从jdk9开始，G1收集器成为默认的垃圾收集器<br>目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p><h3 id="JVM的常用参数（了解）"><a href="#JVM的常用参数（了解）" class="headerlink" title="JVM的常用参数（了解）"></a>JVM的常用参数（了解）</h3><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><p>JVM参数的含义</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td><td></td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。</p><h3 id="1-调整最大堆内存和最小堆内存"><a href="#1-调整最大堆内存和最小堆内存" class="headerlink" title="1 调整最大堆内存和最小堆内存"></a>1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></table></figure><h3 id="2-调整新生代和老年代的比值"><a href="#2-调整新生代和老年代的比值" class="headerlink" title="2 调整新生代和老年代的比值"></a>2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="3-调整Survivor区和Eden区的比值"><a href="#3-调整Survivor区和Eden区的比值" class="headerlink" title="3 调整Survivor区和Eden区的比值"></a>3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-设置年轻代和老年代的大小"><a href="#4-设置年轻代和老年代的大小" class="headerlink" title="4 设置年轻代和老年代的大小"></a>4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p><h3 id="5-小总结"><a href="#5-小总结" class="headerlink" title="5 小总结"></a>5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p><p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br></pre></td></tr></table></figure><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="6-永久区的设置"><a href="#6-永久区的设置" class="headerlink" title="6 永久区的设置"></a>6 永久区的设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize -XX:MaxPermSize</span><br></pre></td></tr></table></figure><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p><p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p><h3 id="7-JVM的栈参数调优"><a href="#7-JVM的栈参数调优" class="headerlink" title="7 JVM的栈参数调优"></a>7 JVM的栈参数调优</h3><h4 id="7-1-调整每个线程栈空间的大小"><a href="#7-1-调整每个线程栈空间的大小" class="headerlink" title="7.1 调整每个线程栈空间的大小"></a>7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p><h4 id="7-2-设置线程栈的大小"><a href="#7-2-设置线程栈的大小" class="headerlink" title="7.2 设置线程栈的大小"></a>7.2 设置线程栈的大小</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XXThreadStackSize：</span><br><span class="line">    设置线程栈的大小(0 means use default stack size)</span><br></pre></td></tr></table></figure><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p><h2 id="QA部分"><a href="#QA部分" class="headerlink" title="QA部分"></a>QA部分</h2><ul><li>讲讲什么情况下回出现内存溢出，内存泄漏？</li><li>说说Java线程栈</li><li>JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</li><li>JVM 出现 fullGC 很频繁，怎么去线上排查问题？</li><li>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</li><li>类的实例化顺序</li><li>JVM垃圾回收机制，何时触发MinorGC等操作</li><li>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</li><li>各种回收算法</li><li><code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</li></ul><h3 id="讲讲什么情况下回出现内存溢出，内存泄漏？"><a href="#讲讲什么情况下回出现内存溢出，内存泄漏？" class="headerlink" title="讲讲什么情况下回出现内存溢出，内存泄漏？"></a>讲讲什么情况下回出现内存溢出，内存泄漏？</h3><p>内存泄漏的原因很简单：</p><ul><li><strong>对象是可达的</strong>(一直被引用)</li><li>但是对象<strong>不会被使用</strong></li></ul><p>常见的内存泄漏例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        set.add(object);</span><br><span class="line">        <span class="comment">// 设置为空，这对象我不再用了</span></span><br><span class="line">        object = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 但是set集合中还维护这obj的引用，gc不会回收object对象</span></span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免<strong>上诉</strong>内存泄漏问题了。其他内存泄漏得一步一步分析了。</p><p>内存泄漏参考资料：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-JavaMemoryLeak/</a></li></ul><p>内存溢出的原因：</p><ul><li>内存泄露导致堆栈内存不断增大，从而引发内存溢出。</li><li>大量的jar，class文件加载，装载类的空间不够，溢出</li><li>操作大量的对象导致堆内存空间已经用满了，溢出</li><li>nio直接操作内存，内存过大导致溢出</li></ul><p>解决：</p><ul><li>查看程序是否存在内存泄漏的问题</li><li>设置参数加大空间</li><li>代码中是否存在死循环或循环产生过多重复的对象实体、</li><li>查看是否使用了nio直接操作内存。</li></ul><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/bingosblog/p/6661527.html" target="_blank" rel="noopener">https://www.cnblogs.com/bingosblog/p/6661527.html</a></li><li><a href="http://www.importnew.com/14604.html" target="_blank" rel="noopener">http://www.importnew.com/14604.html</a></li></ul><h3 id="说说线程栈"><a href="#说说线程栈" class="headerlink" title="说说线程栈"></a>说说线程栈</h3><blockquote><p>这里的线程栈应该指的是虚拟机栈</p></blockquote><p>JVM规范让<strong>每个Java线程</strong>拥有自己的<strong>独立的JVM栈</strong>，也就是Java方法的调用栈。</p><p>当方法调用的时候，会生成一个<strong>栈帧</strong>。栈帧是保存在虚拟机栈中的，栈帧存储了方法的<strong>局部变量表、操作数栈</strong>、动态连接和方法返回地址等信息</p><p>线程运行过程中，<strong>只有一个栈帧是处于活跃状态</strong>，称为“当前活跃栈帧”，当前活动栈帧始终是虚拟机栈的<strong>栈顶元素</strong>。</p><p>通过<strong>jstack</strong>工具查看线程状态</p><p>参考资料：</p><ul><li><a href="http://wangwengcn.iteye.com/blog/1622195" target="_blank" rel="noopener">http://wangwengcn.iteye.com/blog/1622195</a></li><li><a href="https://www.cnblogs.com/Codenewbie/p/6184898.html" target="_blank" rel="noopener">https://www.cnblogs.com/Codenewbie/p/6184898.html</a></li><li><a href="https://blog.csdn.net/u011734144/article/details/60965155" target="_blank" rel="noopener">https://blog.csdn.net/u011734144/article/details/60965155</a></li></ul><h3 id="JVM-年轻代到年老代的晋升过程的判断条件是什么呢？"><a href="#JVM-年轻代到年老代的晋升过程的判断条件是什么呢？" class="headerlink" title="JVM 年轻代到年老代的晋升过程的判断条件是什么呢？"></a>JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</h3><ol><li>部分对象会在From和To区域中复制来复制去,<strong>如此交换15次</strong>(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</li><li>如果<strong>对象的大小大于Eden的二分之一会直接分配在old</strong>，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。</li><li>minor gc后，survivor仍然放不下，则放到老年代</li><li>动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代</li></ol><h3 id="JVM-出现-fullGC-很频繁，怎么去线上排查问题"><a href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题" class="headerlink" title="JVM 出现 fullGC 很频繁，怎么去线上排查问题"></a>JVM 出现 fullGC 很频繁，怎么去线上排查问题</h3><p>这题就依据full GC的触发条件来做：</p><ul><li>如果有perm gen的话(jdk1.8就没了)，<strong>要给perm gen分配空间，但没有足够的空间时</strong>，会触发full gc。</li></ul><p>​    - 所以看看是不是perm gen区的值设置得太小了。</p><ul><li><code>System.gc()</code>方法的调用</li></ul><p>​    - 这个一般没人去调用吧<del>~</del></p><ul><li>当<strong>统计</strong>得到的Minor GC晋升到旧生代的平均大小<strong>大于老年代的剩余空间</strong>，则会触发full gc(这就可以从多个角度上看了)</li></ul><p>​    - 是不是<strong>频繁创建了大对象(也有可能eden区设置过小)</strong>(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁gc)<br>​    - 是不是<strong>老年代的空间设置过小了</strong>(Minor GC几个对象就大于老年代的剩余空间了)</p><p><img src="/2020/04/08/JAVA-JVM/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2ltZy9yZW1vdGUvMTQ2MDAwMDAxNTYwNTM1OA.jpg" alt="img"></p><h3 id="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"><a href="#类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？" class="headerlink" title="类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？"></a>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</h3><p>双亲委托模型的重要用途是为了解决类载入过程中的<strong>安全性问题</strong>。</p><ul><li>假设有一个开发者自己编写了一个名为<code>java.lang.Object</code>的类，想借此欺骗JVM。现在他要使用自定义<code>ClassLoader</code>来加载自己编写的<code>java.lang.Object</code>类。</li><li>然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在<code>Bootstrap ClassLoader</code>的路径下找到<code>java.lang.Object</code>类，并载入它</li></ul><p>Java的类加载是否一定遵循双亲委托模型？</p><ul><li>在实际开发中，我们可以<strong>通过自定义ClassLoader，并重写父类的loadClass方法</strong>，来打破这一机制。</li><li>SPI就是打破了双亲委托机制的(SPI：服务提供发现)。SPI资料：</li></ul><p>​    - <a href="https://zhuanlan.zhihu.com/p/28909673" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28909673</a><br>​    - <a href="https://www.cnblogs.com/huzi007/p/6679215.html" target="_blank" rel="noopener">https://www.cnblogs.com/huzi007/p/6679215.html</a><br>​    - <a href="https://blog.csdn.net/sigangjun/article/details/79071850" target="_blank" rel="noopener">https://blog.csdn.net/sigangjun/article/details/79071850</a></p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/markzy/article/details/53192993" target="_blank" rel="noopener">https://blog.csdn.net/markzy/article/details/53192993</a></li></ul><h3 id="类的实例化顺序"><a href="#类的实例化顺序" class="headerlink" title="类的实例化顺序"></a>类的实例化顺序</h3><ul><li>父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</li><li>父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>父类构造方法</li><li>子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</li><li>子类构造方法</li></ul><p>检验一下是不是真懂了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dervied</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Java3y"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dervied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tellName();</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dervied tell name: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dervied print name: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Dervied();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"公众号"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tellName();</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base tell name: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base print name: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dervied tell name: <span class="keyword">null</span></span><br><span class="line">Dervied print name: <span class="keyword">null</span></span><br><span class="line">Dervied tell name: Java3y</span><br><span class="line">Dervied print name: Java3y</span><br></pre></td></tr></table></figure><h3 id="JVM垃圾回收机制，何时触发MinorGC等操作"><a href="#JVM垃圾回收机制，何时触发MinorGC等操作" class="headerlink" title="JVM垃圾回收机制，何时触发MinorGC等操作"></a>JVM垃圾回收机制，何时触发MinorGC等操作</h3><p>当young gen中的eden区分配满的时候触发MinorGC(新生代的空间不够放的时候).</p><h3 id="JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的"><a href="#JVM-中一次完整的-GC-流程（从-ygc-到-fgc）是怎样的" class="headerlink" title="JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的"></a>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的</h3><ul><li>YGC ：<strong>对新生代堆进行gc</strong>。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。</li><li>FGC ：<strong>全堆范围的gc</strong>。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。</li></ul><blockquote><p>什么时候执行YGC和FGC</p></blockquote><ul><li>a.eden空间不足,执行 young gc</li><li>b.old空间不足，perm空间不足，调用方法<code>System.gc()</code> ，ygc时的悲观策略, dump live的内存信息时(jmap –dump:live)，都会执行full gc</li></ul><h3 id="各种回收算法"><a href="#各种回收算法" class="headerlink" title="各种回收算法"></a>各种回收算法</h3><p>GC最基础的算法有三种：</p><ul><li>标记 - 清除算法</li><li>复制算法</li><li>标记 - 整理算法</li><li>我们常用的垃圾回收器一般都采用<strong>分代收集算法</strong>(其实就是组合上面的算法，不同的区域使用不同的算法)。</li></ul><p>具体：</p><ul><li>标记-清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li><li>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li><li>标记-整理算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li><li>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li></ul><h3 id="String-s1-new-String-quot-abc-quot-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-quot-abc-quot-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？"></a><code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串文字<code>abc</code>，则池中只会创建一个字符串对象引用<code>s1</code>指向了字符串常量中的<code>abc</code>。如果池中没有字符串文字<code>abc</code>，那么它将首先在池中创建<code>abc</code>，然后在堆空间中创建String对象（每次new都会在堆内存开辟空间），因此将创建总共 2 个字符串对象。</strong></p><p><strong>验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>补充：</p><p><code>String s = &quot;a&quot;; s += &quot;b&quot;;</code>，这段代码执行前后，字符串常量池中将出现<code>a</code>和<code>ab</code>两个字符串常量，而原本<code>s</code>变量的引用指向了常量池中<code>ab</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-Recursive</title>
      <link href="/2020/03/20/Algorithm-Recursive/"/>
      <url>/2020/03/20/Algorithm-Recursive/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>递归解释</p></blockquote><a id="more"></a><h2 id="引例——数组求和问题"><a href="#引例——数组求和问题" class="headerlink" title="引例——数组求和问题"></a>引例——数组求和问题</h2><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211102706151.png" alt="image-20191211102706151"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRecusion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露给用户调用的和函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正调用的递归求和的和函数</span></span><br><span class="line">    <span class="comment">// 功能为计算arr[l ... n)范围内的数字和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求解最基本的问题</span></span><br><span class="line">        <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (l == arr.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把原问题转化为更小的问题（将从l开始计算的问题变成从l+1开始计算的问题）</span></span><br><span class="line">        <span class="comment">// 调用sum函数理解为一个和完成指定功能的子函数的调用</span></span><br><span class="line">        <span class="keyword">return</span> arr[l] + sum(arr, l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结（两步）：</p><ul><li><p>递归结束条件</p></li><li><p>把原问题转换为更小的问题</p></li></ul><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211103958276.png" alt="image-20191211103958276"></p><h2 id="链表与递归"><a href="#链表与递归" class="headerlink" title="链表与递归"></a>链表与递归</h2><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211104530011.png" alt="image-20191211104530011"></p><p>问题示例：递归删除链表中某个元素值</p><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211104813317.png" alt="image-20191211104813317"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionRemoveElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定链表头节点head，递归删除其中的节点val，返回新的链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 基本版</span></span><br><span class="line"><span class="comment">        ListNode res = removeElements(head.next, val);</span></span><br><span class="line"><span class="comment">        if(head.val == val)</span></span><br><span class="line"><span class="comment">            return res;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            head.next = res;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精简版</span></span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="微观分析"><a href="#微观分析" class="headerlink" title="微观分析"></a>微观分析</h3><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211133351190.png" alt="image-20191211133351190"></p><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211133940119.png" alt="image-20191211133940119"></p><p><img src="/2020/03/20/Algorithm-Recursive/image-20191211134230823.png" alt="image-20191211134230823"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(传入数值)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (终止条件) </span><br><span class="line">      <span class="keyword">return</span> 最小子问题解;</span><br><span class="line">  <span class="keyword">return</span> func(缩小规模);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树与递归"><a href="#二叉树与递归" class="headerlink" title="二叉树与递归"></a>二叉树与递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(TreeNode child : root.children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    traverse(root.leftNode);</span><br><span class="line">    traverse(root.rightNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Leetcode437-PathSum-III"><a href="#Leetcode437-PathSum-III" class="headerlink" title="Leetcode437 PathSum III"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">Leetcode437 PathSum III</a></h3><p>给一棵二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="keyword">null</span>,<span class="number">1</span>], sum = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">      <span class="number">10</span></span><br><span class="line">     /  \</span><br><span class="line">    <span class="number">5</span>   -<span class="number">3</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">3</span>   <span class="number">2</span>   <span class="number">11</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>  -<span class="number">2</span>   <span class="number">1</span></span><br><span class="line">Return <span class="number">3</span>. The paths that sum to <span class="number">8</span> are:</span><br><span class="line"><span class="number">1</span>.  <span class="number">5</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">2</span>.  <span class="number">5</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">3</span>. -<span class="number">3</span> -&gt; <span class="number">11</span></span><br></pre></td></tr></table></figure><p>这里涉及两层递归函数，一个是count函数，作用是该节点下有多少条路线，本质是二叉树遍历，递归该节点下存在的路径，pathSum函数也是二叉树遍历，是在遍历那个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode437</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rootPathSum = count(root,sum);</span><br><span class="line">        <span class="keyword">int</span> leftPathSum = pathSum(root.left,sum);</span><br><span class="line">        <span class="keyword">int</span> rightPathSum = pathSum(root.right,sum-root.val);</span><br><span class="line">        <span class="keyword">return</span> rootPathSum + leftPathSum + rightPathSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == sum)</span><br><span class="line">            target = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftPath = count(root.left,sum-root.val);</span><br><span class="line">        <span class="keyword">int</span> rightPath = count(root.right,sum-root.val);</span><br><span class="line">        <span class="keyword">return</span> target + leftPath + rightPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leetcode226</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reading Notes</title>
      <link href="/2020/02/09/Reading-Notes/"/>
      <url>/2020/02/09/Reading-Notes/</url>
      
        <content type="html"><![CDATA[<p>装一装吧</p><blockquote><p>读书笔记</p></blockquote><a id="more"></a><h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sword-For-Offer</title>
      <link href="/2020/01/28/Sword-For-Offer/"/>
      <url>/2020/01/28/Sword-For-Offer/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>LeetCode Top100 tags题解</p></blockquote><a id="more"></a><h2 id="P39数组中重复数字"><a href="#P39数组中重复数字" class="headerlink" title="P39数组中重复数字"></a>P39数组中重复数字</h2><p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　从哈希表的思路拓展，重排数组：把扫描的每个数字（如数字m）放到其对应下标（m下标）的位置上，若同一位置有重复，则说明该数字重复。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190616/124213_1560686196023_49d2adc1-b28a-44bf-babb-d44993f4a2e3.gif" alt="img"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 数组中重复数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/2/11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 输入判断</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"数组输入无效！"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数字大小超出范围！"</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[arr[i]] == arr[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * int temp = arr[i];</span></span><br><span class="line"><span class="comment">                 * arr[i] = arr[arri]];</span></span><br><span class="line"><span class="comment">                 * arr[arr[i]] = temp;</span></span><br><span class="line"><span class="comment">                 * 这种写法会造成死循环</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[temp];</span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数组中无重复数字！"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *数组为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test1："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> dup = findDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *数组无重复数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test2："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dup = findDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *数组数字越界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test3："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dup = findDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *数组带重复数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"test4："</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dup = findDuplicate(a);</span><br><span class="line">        <span class="keyword">if</span> (dup &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"重复数字为："</span> + dup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution03 f = <span class="keyword">new</span> Solution03();</span><br><span class="line">        f.test1();</span><br><span class="line">        f.test2();</span><br><span class="line">        f.test3();</span><br><span class="line">        f.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P44二维数组查找"><a href="#P44二维数组查找" class="headerlink" title="P44二维数组查找"></a>P44二维数组查找</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><p><img src="https://uploadfiles.nowcoder.com/files/20190616/124213_1560686367049_0ad9f7ba-f408-4999-a77a-9b73562c9088.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二维数组中查找数据</span></span><br><span class="line"><span class="comment"> * 基本思想是沿对角线横切或者竖切判断。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = array.length;         <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> column = array[<span class="number">0</span>].length;   <span class="comment">// 列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右上角开始定义索引</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = column - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// "while(true)&#123;...&#125;"记住条件是true的</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[r][c] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[r][c] &gt; target)</span><br><span class="line">                c--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P51替换空格"><a href="#P51替换空格" class="headerlink" title="P51替换空格"></a>P51替换空格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>　　请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>　　首先要询问面试官是新建一个字符串还是在原有的字符串上修改，本题要求在原有字符串上进行修改。</p><p>　　若从前往后依次替换，在每次遇到空格字符时，都需要移动后面O(n)个字符，对于含有O(n)个空格字符的字符串而言，总的时间效率为O(n2)。</p><p>　　转变思路：先计算出需要的总长度，然后从后往前进行复制和替换，则每个字符只需要复制一次即可。时间效率为O(n)。</p><p><strong>测试用例</strong></p><ol><li>字符串中无空格</li><li>字符串中含有空格（连续空格，空格在首尾等）</li><li>字符串为空字符串或者为null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 替换空格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Java内置函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace1</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString().replace(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>)</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 补充：StringBuilder/StringBuffer是可变的，其中StringBuffer是线程安全的，</span></span><br><span class="line">    <span class="comment">// StringBuilder是线程不安全的，所以效率更高。其中字符串的拼接操作的原理是生</span></span><br><span class="line">    <span class="comment">// 成一个新的StringBuffer来append的。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在原字符串上修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace3</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> len1 = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="comment">//len += 2;</span></span><br><span class="line">                str.append(<span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更改后字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> len2 = str.length();</span><br><span class="line">        <span class="comment">// 从后向前填入</span></span><br><span class="line">        <span class="keyword">int</span> indexOld = len1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexNew = len2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (indexNew &gt; indexOld) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(indexOld);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(indexNew--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(indexNew--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(indexNew--, <span class="string">'%'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                str.setCharAt(indexNew--, c);</span><br><span class="line">            indexOld--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test1："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">null</span>;</span><br><span class="line">        String s = replaceSpace3(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入为空字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test2："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        String s = replaceSpace3(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入字符串无空格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test3："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">        String s = replaceSpace3(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 输入字符串为首尾空格，中间连续空格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Test4："</span>);</span><br><span class="line">        StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">" a b  c  "</span>);</span><br><span class="line">        String s = replaceSpace3(sBuffer);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution05 rs = <span class="keyword">new</span> Solution05();</span><br><span class="line">        rs.test1();</span><br><span class="line">        rs.test2();</span><br><span class="line">        rs.test3();</span><br><span class="line">        rs.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P59从尾到头输出链表"><a href="#P59从尾到头输出链表" class="headerlink" title="P59从尾到头输出链表"></a>P59从尾到头输出链表</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>　　结点遍历顺序只能从头到尾，但是输出的顺序却为从尾到头，是典型的“后进先出”问题，这就要联想到使用栈，从而也可以联想到使用递归。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>　　1.功能测试（单个结点链表，多个结点链表）</p><p>　　2.特殊输入测试（链表为空）</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 反转打印链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Java内置函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseList1</span><span class="params">(ArrayList arrayList)</span> </span>&#123;</span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己写的函数，非递归方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">reverseList2</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode temp = listNode;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>, temp.val);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方式</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">reverseList3</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reverseList3(listNode.next);</span><br><span class="line">            list3.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用栈方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">reverseList4</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(listNode);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            list.add(stack.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 链表为空时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode listNode = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"采用非递归方式(list头插入)："</span>);</span><br><span class="line">        System.out.println(reverseList2(listNode));</span><br><span class="line">        System.out.println(<span class="string">"采用递归方式："</span>);</span><br><span class="line">        System.out.println(reverseList3(listNode));</span><br><span class="line">        System.out.println(<span class="string">"采用栈方式："</span>);</span><br><span class="line">        System.out.println(reverseList4(listNode));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 多节点链表测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode ListNode1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode ListNode2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode ListNode3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode ListNode4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode ListNode5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        ListNode1.next=ListNode2;</span><br><span class="line">        ListNode2.next=ListNode3;</span><br><span class="line">        ListNode3.next=ListNode4;</span><br><span class="line">        ListNode4.next=ListNode5;</span><br><span class="line">        System.out.println(<span class="string">"采用非递归方式(list头插入)："</span>);</span><br><span class="line">        System.out.println(reverseList2(ListNode1));</span><br><span class="line">        System.out.println(<span class="string">"采用递归方式："</span>);</span><br><span class="line">        System.out.println(reverseList3(ListNode1));</span><br><span class="line">        System.out.println(<span class="string">"采用栈方式："</span>);</span><br><span class="line">        System.out.println(reverseList4(ListNode1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单个结点链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode ListNode1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"采用非递归方式(list头插入)："</span>);</span><br><span class="line">        System.out.println(reverseList2(ListNode1));</span><br><span class="line">        System.out.println(<span class="string">"采用递归方式："</span>);</span><br><span class="line">        System.out.println(reverseList3(ListNode1));</span><br><span class="line">        System.out.println(<span class="string">"采用栈方式："</span>);</span><br><span class="line">        System.out.println(reverseList4(ListNode1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution06 demo = <span class="keyword">new</span> Solution06();</span><br><span class="line">        System.out.println(<span class="string">"test1:"</span>);</span><br><span class="line">        demo.test1();</span><br><span class="line">        System.out.println(<span class="string">"test2:"</span>);</span><br><span class="line">        demo.test2();</span><br><span class="line">        System.out.println(<span class="string">"test3:"</span>);</span><br><span class="line">        demo.test3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>对于“后进先出”问题，要快速想到”栈“，也同时想到递归。</li><li>递归代码的写法，错了好几次。</li></ol><h2 id="P62重建二叉树"><a href="#P62重建二叉树" class="headerlink" title="P62重建二叉树"></a>P62重建二叉树</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>　　输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建出其二叉树并输出它的头结点。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>　　前序遍历第一个值就是根结点的值，根据该值在中序遍历的位置，可以轻松找出该根结点左右子树的前序遍历和中序遍历，之后又可以用同样方法构建左右子树，所以该题可以采用递归的方法完成。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 重建二叉树，已知前序和中序的情况下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution07</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归思想：返回值——树头结点，参数——前序中序数组，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBT</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] front)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || front == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre.length == <span class="number">0</span> || front.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre.length != front.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历中序数组，从中寻找前序数组的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; front.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (front[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 递归传给根节点左右子节点</span></span><br><span class="line">                <span class="comment">// 递归左子树参数1：前序数组开始截止到查询到前序数组索引0值，2：中序数组中前序数组第一个值左边</span></span><br><span class="line">                root.left = reConstructBT(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>),</span><br><span class="line">                        Arrays.copyOfRange(front, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 递归右子树参数：前序中序剩余元素</span></span><br><span class="line">                root.right = reConstructBT(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length),</span><br><span class="line">                        Arrays.copyOfRange(front, i + <span class="number">1</span>, front.length));</span><br><span class="line">                <span class="comment">// 查询到根节点递归后就直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我写的前序</span></span><br><span class="line">        <span class="comment">//while (node!= null)&#123;</span></span><br><span class="line">        <span class="comment">//    System.out.println(node.val);</span></span><br><span class="line">        <span class="comment">//    preOrderTraverse(node.left);</span></span><br><span class="line">        <span class="comment">//    preOrderTraverse(node.right);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 改的前序</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(node.val + <span class="string">", "</span>);</span><br><span class="line">        preOrderTraverse(node.left);</span><br><span class="line">        preOrderTraverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrderTraverse(node.left);</span><br><span class="line">        System.out.print(node.val + <span class="string">", "</span>);</span><br><span class="line">        inOrderTraverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 正常二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        TreeNode root = reConstructBT(pre, in);</span><br><span class="line">        System.out.println(<span class="string">"test1:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"前序："</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"中序:"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 左斜树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        TreeNode root = reConstructBT(pre, in);</span><br><span class="line">        System.out.println(<span class="string">"test2:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"前序："</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"中序:"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 右斜树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        TreeNode root = reConstructBT(pre, in);</span><br><span class="line">        System.out.println(<span class="string">"test3:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"前序："</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"中序:"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 单个结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        TreeNode root = reConstructBT(pre, in);</span><br><span class="line">        System.out.println(<span class="string">"test4:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"前序："</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"中序:"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 数组为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pre = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] in = &#123;&#125;;</span><br><span class="line">        TreeNode root = reConstructBT(pre, in);</span><br><span class="line">        System.out.println(<span class="string">"test5:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"前序："</span>);</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"中序:"</span>);</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution07 demo = <span class="keyword">new</span> Solution07();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P65二叉树的下一个节点"><a href="#P65二叉树的下一个节点" class="headerlink" title="P65二叉树的下一个节点"></a>P65二叉树的下一个节点</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>　　给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？ 树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p><p><img src="https://uploadfiles.nowcoder.com/files/20190616/124213_1560686577082_b0611f89-1e5f-4494-a795-3544bf65042a.gif" alt="img"></p><p>② 若当前结点无右子树时，</p><ul><li>若当前结点为其父结点的左子结点时，其下一个结点为其父结点；</li><li>若当前结点为其父结点的右子结点时，继续向上遍历父结点的父结点，直到找到一个结点是其父结点的左子结点（与① 中判断相同），该结点即为下一结点。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20190616/124213_1560686577139_95080fae-de40-463d-a76e-783a0c677fec.gif" alt="img"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 二叉树下一节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">getNext</span><span class="params">(TreeLinkNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"结点为null "</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点有右子树时，下一个节点是向下找</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点无右子树时，向上找</span></span><br><span class="line">        <span class="keyword">while</span> (node.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点无右子树，且是父节点的左子树时，返回其父节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.parent.left == node) &#123;</span><br><span class="line">                <span class="keyword">return</span> node.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上寻找一个节点，这个节点满足上面的if</span></span><br><span class="line">            node = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==================================测试代码==================================</span></span><br><span class="line">    <span class="comment">//创建树较为繁琐，未包括所有测试代码。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeLinkNode node = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode nextNode = getNext(node);</span><br><span class="line">        <span class="keyword">if</span> (nextNode != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(nextNode.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"无下一结点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeLinkNode node1 = <span class="keyword">new</span> TreeLinkNode(<span class="number">1</span>);</span><br><span class="line">        TreeLinkNode node2 = <span class="keyword">new</span> TreeLinkNode(<span class="number">2</span>);</span><br><span class="line">        TreeLinkNode node3 = <span class="keyword">new</span> TreeLinkNode(<span class="number">3</span>);</span><br><span class="line">        TreeLinkNode node4 = <span class="keyword">new</span> TreeLinkNode(<span class="number">4</span>);</span><br><span class="line">        node1.left = node2;</span><br><span class="line">        node1.right = node3;</span><br><span class="line">        node2.parent = node1;</span><br><span class="line">        node3.parent = node1;</span><br><span class="line">        node4.left = node1;</span><br><span class="line">        node1.parent = node4;</span><br><span class="line">        TreeLinkNode nextNodeOf1 = getNext(node1);</span><br><span class="line">        TreeLinkNode nextNodeOf2 = getNext(node2);</span><br><span class="line">        TreeLinkNode nextNodeOf3 = getNext(node3);</span><br><span class="line">        TreeLinkNode nextNodeOf4 = getNext(node4);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf1 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"1结点的下一个结点值为："</span> + nextNodeOf1.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"1结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf2 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"2结点的下一个结点值为："</span> + nextNodeOf2.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"2结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf3 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"3结点的下一个结点值为："</span> + nextNodeOf3.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"3结点无下一结点"</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextNodeOf4 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"4结点的下一个结点值为："</span> + nextNodeOf4.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"4结点无下一结点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution08 demo = <span class="keyword">new</span> Solution08();</span><br><span class="line">        System.out.print(<span class="string">"test1:"</span>);</span><br><span class="line">        demo.test1();</span><br><span class="line">        System.out.print(<span class="string">"test2:"</span>);</span><br><span class="line">        demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P68使用两个栈实现队列"><a href="#P68使用两个栈实现队列" class="headerlink" title="P68使用两个栈实现队列"></a>P68使用两个栈实现队列</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p><p><img src="/2020/01/28/Sword-For-Offer/124213_1560686577119_3ea280b5-be7d-471b-ac76-ff020384357c.gif" alt="img"></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 两个栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution09</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先定义两个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现pop和push的功能</span></span><br><span class="line">        <span class="comment">// 入队使用stack1</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            stack1.push(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队使用stack2</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 出队是stack2，先查看是否为空</span></span><br><span class="line">                <span class="comment">// 为空情况下再从stack1中调出存入</span></span><br><span class="line">                <span class="comment">// 从stack1中调值时一次性取完</span></span><br><span class="line">                <span class="keyword">if</span> (stack1.isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空！"</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                        stack2.push(stack1.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=======测试代码==========</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.push(<span class="number">1</span>);</span><br><span class="line">        queue.push(<span class="number">2</span>);</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">        queue.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 往空队列删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        System.out.println(queue.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution09 demo = <span class="keyword">new</span> Solution09();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P74斐波那契数列"><a href="#P74斐波那契数列" class="headerlink" title="P74斐波那契数列"></a>P74斐波那契数列</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="/2020/01/28/Sword-For-Offer/image-20200212142801214.png" alt="image-20200212142801214"></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。</p><p><img src="/2020/01/28/Sword-For-Offer/124213_1560686577136_c13e2a3d-b01c-4a08-a69b-db2c4e821e09.png" alt="img"></p><p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/2/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fibonacci1</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fibonacci1(n - <span class="number">1</span>) + fibonacci1(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fibonacci2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> preOne = <span class="number">0</span>, preTwo = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意起始下标位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preOne = preTwo;</span><br><span class="line">            preTwo = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution10 demo = <span class="keyword">new</span> Solution10();</span><br><span class="line">        System.out.println(demo.fibonacci1(<span class="number">0</span>));</span><br><span class="line">        System.out.println(demo.fibonacci2(<span class="number">0</span>));</span><br><span class="line">        System.out.println(demo.fibonacci1(<span class="number">2</span>));</span><br><span class="line">        System.out.println(demo.fibonacci2(<span class="number">2</span>));</span><br><span class="line">        System.out.println(demo.fibonacci1(<span class="number">8</span>));</span><br><span class="line">        System.out.println(demo.fibonacci2(<span class="number">8</span>));</span><br><span class="line">        <span class="comment">// 递归真的超级慢</span></span><br><span class="line">        System.out.println(demo.fibonacci1(<span class="number">50</span>));</span><br><span class="line">        System.out.println(demo.fibonacci2(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p><strong>题目1：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>　　将跳法总数记为f(n)，可以知道f(1)=1，f(2)=2。当n&gt;2时，第一次跳1级的话，还有f(n-1)种跳法；第一次跳2级的话，还有f(n-2)种跳法，所以可以推得<strong>f(n)=f(n-1)+f(n-2)</strong>，即为<strong>斐波那契数列</strong>。</p><p><strong>题目2：</strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>　　<strong>解法1：</strong></p><p>　　当n=1时，f(1)=1。</p><p>　　当n大于1时，归纳总结可知：跳上n级台阶，第一次跳1级的话，有f(n-1)种方法；第一次跳2级的话，有f(n-2)种方法……第一次跳n-1级的话，有f(1)种方法；直接跳n级的话，有1种方法，所以可以得到如下公式：</p><p>　　f(n) = f(n-1)+f(n-2)+……f(1)+1　　（n≥2）</p><p>　　f(n-1) = f(n-2)+f(n-3)+…..f(1)+1　　（n&gt;2）</p><p>　　由上面两式相减可得，f(n)-f(n-1)=f(n-1)，即f(n) = 2*f(n-1) (n&gt;2)</p><p>　　最终结合f(1)和f(2)，可以推得：<strong>f(n)=2^(n-1)</strong></p><p>　　<strong>解法2：</strong></p><p>　　假设跳到第n级总共需要k次，说明要在中间n-1级台阶中选出任意k-1个台阶，即C(n-1,k-1)种方法。</p><p>　　所以：跳1次就跳上n级台阶，需要C(n-1,0)种方法；跳2次需要C(n-1,1)种方法……跳n次需要C(n-1,n-1)种方法</p><p>　　总共需要跳C(n-1,0)+C(n-1,1)+C(n-1,2)+……C(n-1,n-1)=<strong>2^(n-1)</strong>种方法。</p><p>　　<strong>解法3：</strong></p><p>　　除了必须到达最后一级台阶，第1级到第n-1级台阶都可以有选择的跳，也就是说对于这n-1个台阶来说，每个台阶都有跳上和不跳上2种情况，所以一共有<strong>2^(n-1)</strong>种方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩形覆盖问题"><a href="#矩形覆盖问题" class="headerlink" title="矩形覆盖问题"></a><strong>矩形覆盖问题</strong></h3><p><strong><em>\</em>题目：**</strong>用n个2<em>1的小矩形无重叠地覆盖一个2</em>n的大矩形，总共有多少种方法？</p><p>　　当n = 1时，有一种方法。</p><p>　　当n = 2时，有两种方法。</p><p>　　当n &gt;= 3时，和斐波那契数列类似。第一步竖着放，有f(n-1)种方法；第一步横着放，有f(n-2)种方法。所以<strong>f(n)=f(n-1)+f(n-2)。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　1.求n次方时，可以利用递归来降低时间复杂度</p><p>　　2.当遇到涉及n的问题时（类似青蛙跳台阶问题），注意f(n)与f(n-1)、f(n-2)等的关联，从而找出规律，进行合理建模。</p><p>　　3.return (int)Math.pow(2,target-1);</p><p>　　　　1) 转int类型</p><p>　　　　2）pow不是power</p><h2 id="P82旋转数组查找最小值"><a href="#P82旋转数组查找最小值" class="headerlink" title="P82旋转数组查找最小值"></a>P82旋转数组查找最小值</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>数组在一定程度上是排序的，很容易分析出：可以采用二分法来寻找最小数字。但是这里面有一些陷阱：</p><ol><li>递增排序数组的本身是自己的旋转，则最小数字是第一个数字</li><li>中间数字与首尾数字大小相等，如{1,0,1,1,1,1}和{1,1,1,1,0,1}，无法采用二分法，只能顺序查找。</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swordforoffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.Element;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 旋转数组寻找元素</span></span><br><span class="line"><span class="comment"> * 例[4,5,6,7,1,2,3]中查找6</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/1/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用二分法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[low] == nums[mid] &amp;&amp; nums[mid] == nums[high])</span><br><span class="line">                <span class="keyword">return</span> minNumber(nums, low, high);</span><br><span class="line">                <span class="comment">// 这里的两个和high/low的判断条件只用其中一个即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写一遍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinInRotateArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里直接比较数值，可直接剔除递增数组现象</span></span><br><span class="line">        <span class="keyword">while</span> (nums[low] &gt;= nums[high]) &#123;</span><br><span class="line">            <span class="comment">// 在low值和high值处满足"nums[low] &gt;= nums[high] &amp;&amp; high - low == 1"</span></span><br><span class="line">            <span class="comment">// 即两者相邻时，达到循环终止条件，返回第二个索引值即为最小值。</span></span><br><span class="line">            <span class="keyword">if</span> (high - low == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[high];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 特殊值处理，有相等值存在情况</span></span><br><span class="line">            <span class="keyword">if</span> (nums[high] == nums[mid] &amp;&amp; nums[mid] == nums[low])</span><br><span class="line">                <span class="keyword">return</span> minNumber(nums, low, high);</span><br><span class="line">                <span class="comment">// 这两个判断条件是最初的特性判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= nums[low])</span><br><span class="line">                low = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; h; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =======================测试代码===========================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"test1:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test2:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test3:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test4:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test5:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test6:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"test7:"</span> + findMinInRotateArray(array) + findMinInRotateArray2(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution11 demo = <span class="keyword">new</span> Solution11();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        demo.test5();</span><br><span class="line">        demo.test6();</span><br><span class="line">        demo.test7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P89矩阵中的路径"><a href="#P89矩阵中的路径" class="headerlink" title="P89矩阵中的路径"></a>P89矩阵中的路径</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。<br> A B T G<br> C F C S<br> J D E H</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。</p><p><img src="/2020/01/28/Sword-For-Offer/124213_1560686577116_dc964b86-7a08-4bde-a3d9-e6ddceb29f98.png" alt="img"></p><p>首先对所整个矩阵遍历，找到第一个字符，然后向上下左右查找下一个字符，由于每个字符都是相同的判断方法（先判断当前字符是否相等，再向四周查找），因此采用<strong>递归函数</strong>。由于字符查找过后不能重复进入，所以还要定义一个与字符矩阵大小相同的<strong>布尔值矩阵</strong>，进入过的格子标记为true。如果不满足的情况下，需要进行<strong>回溯</strong>，此时，要将当前位置的布尔值标记回false。（所谓的回溯无非就是对使用过的字符进行标记和处理后的去标记）</p><p>刷题类别：</p><p>二叉树</p><p><img src="/2020/01/28/Sword-For-Offer/image-20200408151847430.png" alt="image-20200408151847430"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swordforoffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sell Project</title>
      <link href="/2019/12/26/Sell-Project/"/>
      <url>/2019/12/26/Sell-Project/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><blockquote><p>微信点餐项目实践——慕课网</p></blockquote><a id="more"></a><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>前端是由Vue.js构建的WebApp，后端由Spring Boot打造，后端的前台页面使用Bootstrap+Freemarker+JQuery构建,后端和前端通过RESTful风格的接口相连。</p><p><img src="/2019/12/26/Sell-Project/image-20200123151733508.png" alt="image-20200123151733508"></p><p>数据库方面使用Spring Boot+JPA，兼顾Spring Boot+Mybatis；缓存方面，使用Spring Boot+Redis；基于Redis，应对分布式Session和锁；消息推送方面，使用WebSocket。</p><p><img src="/2019/12/26/Sell-Project/image-20200123151751523.png" alt="image-20200123151751523"></p><h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><h3 id="角色划分"><a href="#角色划分" class="headerlink" title="角色划分"></a>角色划分</h3><ul><li>买家（手机端）：由微信公众号提供的一个服务。</li><li>卖家（PC端）：一个简单的商家管理系统</li></ul><h3 id="功能模块划分"><a href="#功能模块划分" class="headerlink" title="功能模块划分"></a>功能模块划分</h3><ul><li>功能分析</li></ul><p><img src="/2019/12/26/Sell-Project/image-20191226132632562.png" alt="image-20191226132632562"></p><ul><li>关系图</li></ul><p><img src="/2019/12/26/Sell-Project/image-20191226132747143.png" alt="image-20191226132747143"></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>买家端在手机端，卖家端在PC端，两端都会发出数据请求，请求首先到达nginx服务器，如果请求的是后端接口，nginx服务器会进行一个转发，转发到后面的Tomcat服务器，即我们的Java项目所在，如果这个接口作了缓存，那么就会访问redis服务器，如果没有缓存，就会访问我们的MySQL数据库。值得注意的是我们的应用是支持分布式部署的，也就是说图上的Tomcat表示的是多台服务器，多个应用。</p><p><img src="/2019/12/26/Sell-Project/image-20191226132922967.png" alt="image-20191226132922967"></p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>共5个表，表之间的关系如下，其中商品表存放的就是商品的名称、价格、库存、图片链接等信息；类目表含有类目id、类目名字等信息，一个类目下有多种商品，类目表和商品表之间是一对多的关系；订单详情表含有购买的商品名称、数量、所属订单的订单号等信息；订单主表包含包含该订单的订单号、买家的信息、订单的支付状态等信息，订单主表和订单详情表之间是一对多的关系；最后是卖家信息表，存放的卖家的账号和密码等信息，作为卖家后台管理的权限认证。</p><p><img src="/2019/12/26/Sell-Project/image-20191226134017529.png" alt="image-20191226134017529"></p><h2 id="项目使用的主要技术栈"><a href="#项目使用的主要技术栈" class="headerlink" title="项目使用的主要技术栈"></a>项目使用的主要技术栈</h2><ul><li>Spring Boot的相关特性<ul><li>Spring Boot+JPA</li><li>Spring Boot+Redis</li><li>Spring Boot+WebSocket</li></ul></li><li>微信相关特征<ul><li>微信支付、退款</li><li>微信授权登陆</li><li>微信模板消息推送</li><li>使用微信相关的开源SDK</li></ul></li><li>利用Redis应用分布式Session和锁<ul><li>对用户的登陆信息使用分布式Session存储</li><li>利用一个抢购商品的例子，来对Redis分布式锁进行详细的说明</li></ul></li></ul><h2 id="开发环境及工具"><a href="#开发环境及工具" class="headerlink" title="开发环境及工具"></a>开发环境及工具</h2><ul><li>IDEA</li><li>Maven</li><li>Git</li><li>MySQL</li><li>Nginx</li><li>Redis</li><li>Postman模拟微信订单创建订单</li><li>Fiddler对手机请求抓包</li><li>Natapp内网穿透</li><li>Apache ab模拟高并发，抢购一个商品</li></ul><h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><h3 id="买家端商品类目"><a href="#买家端商品类目" class="headerlink" title="买家端商品类目"></a>买家端商品类目</h3><p>买家端类目模块的开发，按照dao-&gt;service-&gt;api的顺序开发。</p><h4 id="create类目表"><a href="#create类目表" class="headerlink" title="create类目表"></a>create类目表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类目</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`product_category`</span> (</span><br><span class="line">    <span class="string">`category_id`</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="string">`category_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'类目名字'</span>,</span><br><span class="line">    <span class="string">`category_type`</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'类目编号'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`category_id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="ProductCategory实体"><a href="#ProductCategory实体" class="headerlink" title="ProductCategory实体"></a>ProductCategory实体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span><span class="comment">// 将数据库表单映射成对象加上注解</span></span><br><span class="line"><span class="meta">@Data</span><span class="comment">// 使用插件lombok自己生成get、set、toString等方法</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span> <span class="comment">// 动态更新的意思，属性中的两个**时间字段**会随着自动更新</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 类目id. */</span></span><br><span class="line">    <span class="meta">@Id</span><span class="comment">// 类属性主键上</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryId;</span><br><span class="line">    <span class="comment">/** 类目名字. */</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="comment">/** 类目编号. */</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductCategory</span><span class="params">(String categoryName, Integer categoryType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.categoryName = categoryName;</span><br><span class="line">        <span class="keyword">this</span>.categoryType = categoryType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProductCategoryDAO"><a href="#ProductCategoryDAO" class="headerlink" title="ProductCategoryDAO"></a>ProductCategoryDAO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承SpringBootJPA，泛型为实体对象和其对应主键类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductCategoryRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">ProductCategory</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;ProductCategory&gt; <span class="title">findByCategoryTypeIn</span><span class="params">(List&lt;Integer&gt; categoryTypeList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dao单元测试"><a href="#dao单元测试" class="headerlink" title="dao单元测试"></a>dao单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ProductCategoryRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductCategoryRepository repository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = repository.findOne(<span class="number">1</span>);</span><br><span class="line">        System.out.println(productCategory.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory(<span class="string">"男生最爱"</span>, <span class="number">4</span>);</span><br><span class="line">        ProductCategory result = repository.save(productCategory);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line"><span class="comment">//        Assert.assertNotEquals(null, result);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByCategoryTypeInTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        List&lt;ProductCategory&gt; result = repository.findByCategoryTypeIn(list);</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, result.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ProductCategory productCategory = repository.findOne(4);</span></span><br><span class="line"><span class="comment">//        productCategory.setCategoryName("男生最爱1");</span></span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory(<span class="string">"男生最爱"</span>, <span class="number">4</span>);</span><br><span class="line">        ProductCategory result = repository.save(productCategory);</span><br><span class="line">        Assert.assertEquals(productCategory, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CategoryService"><a href="#CategoryService" class="headerlink" title="CategoryService"></a>CategoryService</h4><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span>  <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过类别id查询（系统方向）</span></span><br><span class="line">    <span class="function">ProductCategory <span class="title">findOne</span><span class="params">(Integer categoryId)</span></span>;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="function">List&lt;ProductCategory&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 通过类别查询（客户方向）</span></span><br><span class="line">    <span class="function">List&lt;ProductCategory&gt; <span class="title">findByCategoryTypeIn</span><span class="params">(List&lt;Integer&gt; categoryTypeList)</span></span>;</span><br><span class="line">    <span class="comment">// 新增/更新操作</span></span><br><span class="line">    <span class="function">ProductCategory <span class="title">save</span><span class="params">(ProductCategory productCategory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title">CategoryService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductCategoryDao productCategoryDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductCategory <span class="title">findOne</span><span class="params">(Integer categoryId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productCategoryDao.findOne(categoryId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProductCategory&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productCategoryDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProductCategory&gt; <span class="title">findByCategoryTypeIn</span><span class="params">(List&lt;Integer&gt; categoryTypeList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productCategoryDao.findByCategoryTypeIn(categoryTypeList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductCategory <span class="title">save</span><span class="params">(ProductCategory productCategory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productCategoryDao.save(productCategory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service单元测试"><a href="#service单元测试" class="headerlink" title="service单元测试"></a>service单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ProductCategoryRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductCategoryRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = repository.findOne(<span class="number">1</span>);</span><br><span class="line">        System.out.println(productCategory.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory(<span class="string">"男生最爱"</span>, <span class="number">4</span>);</span><br><span class="line">        ProductCategory result = repository.save(productCategory);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line"><span class="comment">//        Assert.assertNotEquals(null, result);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByCategoryTypeInTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;ProductCategory&gt; result = repository.findByCategoryTypeIn(list);</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, result.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ProductCategory productCategory = repository.findOne(4);</span></span><br><span class="line"><span class="comment">//        productCategory.setCategoryName("男生最爱1");</span></span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory(<span class="string">"男生最爱"</span>, <span class="number">4</span>);</span><br><span class="line">        ProductCategory result = repository.save(productCategory);</span><br><span class="line">        Assert.assertEquals(productCategory, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/26/Sell-Project/image-20200516223402309.png" alt="image-20200516223402309"></p><h3 id="买家端商品信息"><a href="#买家端商品信息" class="headerlink" title="买家端商品信息"></a>买家端商品信息</h3><h4 id="create商品表"><a href="#create商品表" class="headerlink" title="create商品表"></a>create商品表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 商品</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`product_info`</span> (</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`product_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'商品名称'</span>,</span><br><span class="line">    <span class="string">`product_price`</span> <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'单价'</span>,</span><br><span class="line">    <span class="string">`product_stock`</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'库存'</span>,</span><br><span class="line">    <span class="string">`product_description`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">comment</span> <span class="string">'描述'</span>,</span><br><span class="line">    <span class="string">`product_icon`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">comment</span> <span class="string">'小图'</span>,</span><br><span class="line">    <span class="string">`product_status`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'商品状态,0正常1下架'</span>,</span><br><span class="line">    <span class="string">`category_type`</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'类目编号'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`product_id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="ProductInfo实体"><a href="#ProductInfo实体" class="headerlink" title="ProductInfo实体"></a>ProductInfo实体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span><span class="comment">// 将数据库表单映射成对象加上注解</span></span><br><span class="line"><span class="meta">@Data</span><span class="comment">// 使用插件lombok自己生成get、set、toString等方法</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span> <span class="comment">// 动态更新的意思，属性中的两个**时间字段**会随着自动更新</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductInfo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span><span class="comment">// 类属性主键上</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">/** 名字. */</span></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="comment">/** 单价. */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="comment">/** 库存. */</span></span><br><span class="line">    <span class="keyword">private</span> Integer productStock;</span><br><span class="line">    <span class="comment">/** 描述. */</span></span><br><span class="line">    <span class="keyword">private</span> String productDescription;</span><br><span class="line">    <span class="comment">/** 小图. */</span></span><br><span class="line">    <span class="keyword">private</span> String productIcon;</span><br><span class="line">    <span class="comment">/** 状态, 0正常1下架. */</span></span><br><span class="line">    <span class="keyword">private</span> Integer productStatus = ProductStatusEnum.UP.getCode();</span><br><span class="line">    <span class="comment">/** 类目编号. */</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductStatusEnum <span class="title">getProductStatusEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumUtil.getByCode(productStatus, ProductStatusEnum<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProductInfoDAO"><a href="#ProductInfoDAO" class="headerlink" title="ProductInfoDAO"></a>ProductInfoDAO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductInfoDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">ProductInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 根据状态查询商品</span></span><br><span class="line">    <span class="function">List&lt;ProductInfo&gt; <span class="title">findByProductStatus</span><span class="params">(Integer productStatus)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dao单元测试-1"><a href="#dao单元测试-1" class="headerlink" title="dao单元测试"></a>dao单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ProductInfoRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductInfoRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductInfo productInfo = <span class="keyword">new</span> ProductInfo();</span><br><span class="line">        productInfo.setProductId(<span class="string">"123456"</span>);</span><br><span class="line">        productInfo.setProductName(<span class="string">"皮蛋粥"</span>);</span><br><span class="line">        productInfo.setProductPrice(<span class="keyword">new</span> BigDecimal(<span class="number">3.2</span>));</span><br><span class="line">        productInfo.setProductStock(<span class="number">100</span>);</span><br><span class="line">        productInfo.setProductDescription(<span class="string">"很好喝的粥"</span>);</span><br><span class="line">        productInfo.setProductIcon(<span class="string">"http://xxxxx.jpg"</span>);</span><br><span class="line">        productInfo.setProductStatus(<span class="number">0</span>);</span><br><span class="line">        productInfo.setCategoryType(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ProductInfo result = repository.save(productInfo);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByProductStatus</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;ProductInfo&gt; productInfoList = repository.findByProductStatus(<span class="number">0</span>);</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, productInfoList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProductService"><a href="#ProductService" class="headerlink" title="ProductService"></a>ProductService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductInfo <span class="title">findOne</span><span class="params">(String productId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询在售商品（用户端）</span></span><br><span class="line">    <span class="function">List&lt;ProductInfo&gt; <span class="title">findUpAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有商品（商家管理后台展示）</span></span><br><span class="line">    <span class="comment">// 注意这里会有分页</span></span><br><span class="line">    <span class="comment">// 使用的是pageable分页，返回的是一个page对象</span></span><br><span class="line">    <span class="function">Page&lt;ProductInfo&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ProductInfo <span class="title">save</span><span class="params">(ProductInfo productInfo)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 库存操作，参数是前端传入参数DTO</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increaseStock</span><span class="params">(List&lt;CartDTO&gt; cartDTOList)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decreaseStock</span><span class="params">(List&lt;CartDTO&gt; cartDTOList)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下架方法</span></span><br><span class="line">    <span class="function">ProductInfo <span class="title">onSale</span><span class="params">(String productId)</span></span>;</span><br><span class="line">    <span class="function">ProductInfo <span class="title">offSale</span><span class="params">(String productId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductInfoDao productInfoDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">findOne</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productInfoDao.findOne(productId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ProductInfo&gt; <span class="title">findUpAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的就是枚举类使用</span></span><br><span class="line">        <span class="keyword">return</span> productInfoDao.findByProductStatus(ProductStatusEnum.UP.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;ProductInfo&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productInfoDao.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">save</span><span class="params">(ProductInfo productInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productInfoDao.save(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseStock</span><span class="params">(List&lt;CartDTO&gt; cartDTOList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历购物车</span></span><br><span class="line">        <span class="keyword">for</span> (CartDTO cartDTO : cartDTOList) &#123;</span><br><span class="line">            <span class="comment">// 定位购物车中商品</span></span><br><span class="line">            ProductInfo productInfo = productInfoDao.findOne(cartDTO.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_NO_EXIST);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Integer result = productInfo.getProductStock() - cartDTO.getProductQuantity();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_STOCK_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            productInfo.setProductStock(result);</span><br><span class="line">            productInfoDao.save(productInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseStock</span><span class="params">(List&lt;CartDTO&gt; cartDTOList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历购物车列表</span></span><br><span class="line">        <span class="keyword">for</span> (CartDTO cartDTO : cartDTOList) &#123;</span><br><span class="line">            ProductInfo productInfo = productInfoDao.findOne(cartDTO.getProductId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_NO_EXIST);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Integer result = productInfo.getProductStock() + cartDTO.getProductQuantity();</span><br><span class="line"></span><br><span class="line">            productInfo.setProductStock(result);</span><br><span class="line">            productInfoDao.save(productInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">onSale</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        ProductInfo productInfo = productInfoDao.findOne(productId);</span><br><span class="line">        <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (productInfo.getProductStatusEnum() == ProductStatusEnum.UP) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        productInfo.setProductStatus(ProductStatusEnum.UP.getCode());</span><br><span class="line">        <span class="keyword">return</span> productInfoDao.save(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">offSale</span><span class="params">(String productId)</span> </span>&#123;</span><br><span class="line">        ProductInfo productInfo = productInfoDao.findOne(productId);</span><br><span class="line">        <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (productInfo.getProductStatusEnum() == ProductStatusEnum.DOWN) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        productInfo.setProductStatus(ProductStatusEnum.DOWN.getCode());</span><br><span class="line">        <span class="keyword">return</span> productInfoDao.save(productInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会有一些目前还未涉及到的，这里先放上。同时这里涉及到编程中的一些类的包装和优化。</p><h5 id="枚举类包装商品状态"><a href="#枚举类包装商品状态" class="headerlink" title="枚举类包装商品状态"></a>枚举类包装商品状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span><span class="comment">// 引入lombok.Getter自动生成get()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ProductStatusEnum implements CodeEnum&#123;</span><br><span class="line">    UP(<span class="number">0</span>,<span class="string">"在售"</span>),</span><br><span class="line">    DOWN(<span class="number">1</span>,<span class="string">"下架"</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    ProductStatusEnum(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service单元测试-1"><a href="#service单元测试-1" class="headerlink" title="service单元测试"></a>service单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ProductServiceImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductServiceImpl productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findOne</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ProductInfo productInfo = productService.findOne(<span class="string">"123456"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"123456"</span>, productInfo.getProductId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUpAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;ProductInfo&gt; productInfoList = productService.findUpAll();</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, productInfoList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PageRequest request = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        Page&lt;ProductInfo&gt; productInfoPage = productService.findAll(request);</span><br><span class="line"><span class="comment">//        System.out.println(productInfoPage.getTotalElements());</span></span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, productInfoPage.getTotalElements());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ProductInfo productInfo = <span class="keyword">new</span> ProductInfo();</span><br><span class="line">        productInfo.setProductId(<span class="string">"123457"</span>);</span><br><span class="line">        productInfo.setProductName(<span class="string">"皮皮虾"</span>);</span><br><span class="line">        productInfo.setProductPrice(<span class="keyword">new</span> BigDecimal(<span class="number">3.2</span>));</span><br><span class="line">        productInfo.setProductStock(<span class="number">100</span>);</span><br><span class="line">        productInfo.setProductDescription(<span class="string">"很好吃的虾"</span>);</span><br><span class="line">        productInfo.setProductIcon(<span class="string">"http://xxxxx.jpg"</span>);</span><br><span class="line">        productInfo.setProductStatus(ProductStatusEnum.DOWN.getCode());</span><br><span class="line">        productInfo.setCategoryType(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        ProductInfo result = productService.save(productInfo);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductInfo result = productService.onSale(<span class="string">"123456"</span>);</span><br><span class="line">        Assert.assertEquals(ProductStatusEnum.UP, result.getProductStatusEnum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offSale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductInfo result = productService.offSale(<span class="string">"123456"</span>);</span><br><span class="line">        Assert.assertEquals(ProductStatusEnum.DOWN, result.getProductStatusEnum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BuyerProductController"><a href="#BuyerProductController" class="headerlink" title="BuyerProductController"></a>BuyerProductController</h4><h5 id="商品列表api"><a href="#商品列表api" class="headerlink" title="商品列表api"></a>商品列表api</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /sell/buyer/product/list</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要分析文档</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在外层字段1</span></span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 在外层字段2</span></span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="comment">// 在外层字段3</span></span><br><span class="line">    <span class="attr">"data"</span>: [<span class="comment">// data字段里层是个list</span></span><br><span class="line">        <span class="comment">// list的一个元素，或者说是一个对象，但不是一个商品对象，又是一层包装类</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这是类目名称</span></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"热榜"</span>,</span><br><span class="line">            <span class="comment">// 这是类目号</span></span><br><span class="line">            <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="comment">// 这是才是真正商品信息，同样这个字段也是一个list</span></span><br><span class="line">            <span class="attr">"foods"</span>: [</span><br><span class="line">                <span class="comment">// 这是里面的一个元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下面的各个字段是商品信息字段</span></span><br><span class="line">                    <span class="attr">"id"</span>: <span class="string">"123456"</span>,</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"皮蛋粥"</span>,</span><br><span class="line">                    <span class="attr">"price"</span>: <span class="number">1.2</span>,</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"好吃的皮蛋粥"</span>,</span><br><span class="line">                    <span class="attr">"icon"</span>: <span class="string">"http://xxx.com"</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// list的第二个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"好吃的"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"foods"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"id"</span>: <span class="string">"123457"</span>,</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"慕斯蛋糕"</span>,</span><br><span class="line">                    <span class="attr">"price"</span>: <span class="number">10.9</span>,</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"美味爽口"</span>,</span><br><span class="line">                    <span class="attr">"icon"</span>: <span class="string">"http://xxx.com"</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对文档的分析，发现首先需要对数据进行封装</p><h5 id="包装返回到前端的视图对象VO"><a href="#包装返回到前端的视图对象VO" class="headerlink" title="包装返回到前端的视图对象VO"></a>包装返回到前端的视图对象VO</h5><blockquote><p>ViewObject</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最外层</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVo</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8445738735149690659L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 错误码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 错误提示</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">// 返回实体</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 次外层（商品信息包含类目）</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultDataVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8482248794818454115L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 商品类别名，为防止混淆以及和API对应，加上注解</span></span><br><span class="line">    <span class="comment">// 因为返回前端是name</span></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"food"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultDataDetailVo&gt; resultDataDetailVolist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最里层（商品的部分信息）</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultDataDetailVo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7670881173673410125L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"price"</span>)</span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"description"</span>)</span><br><span class="line">    <span class="keyword">private</span> String productDescription;</span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"icon"</span>)</span><br><span class="line">    <span class="keyword">private</span> String productIcon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">// 表示返回json格式</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buyer/product"</span>)  <span class="comment">// url设置，这里注意是由文档来的，而且可以看到和类名很相似</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVo <span class="title">getList</span><span class="params">(@RequestParam(<span class="string">"sellerId"</span>)</span> String sellerId)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.查询所有上架的商品</span></span><br><span class="line">        List&lt;ProductInfo&gt; productInfoList = productService.findUpAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.查询类目()</span></span><br><span class="line">        List&lt;Integer&gt; categoryTypeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 传统方法</span></span><br><span class="line">        <span class="keyword">for</span> (ProductInfo productInfo : productInfoList) &#123;</span><br><span class="line">            categoryTypeList.add(productInfo.getCategoryType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lambda方法</span></span><br><span class="line">        List&lt;Integer&gt; categoryTypeList = productInfoList.stream().map(e -&gt; e.getCategoryType()).collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        List&lt;ProductCategory&gt; productCategoryList = categoryService.findByCategoryTypeIn(categoryTypeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.数据拼装</span></span><br><span class="line"></span><br><span class="line">        List&lt;ResultDataVo&gt; ResultDataVoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ProductCategory productCategory: productCategoryList) &#123;</span><br><span class="line">            ResultDataVo ResultDataVo = <span class="keyword">new</span> ResultDataVo();</span><br><span class="line">            ResultDataVo.setCategoryType(productCategory.getCategoryType());</span><br><span class="line">            ResultDataVo.setCategoryName(productCategory.getCategoryName());</span><br><span class="line"></span><br><span class="line">            List&lt;ResultDataDetailVo&gt; ResultDataDetailVoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (ProductInfo productInfo: productInfoList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (productInfo.getCategoryType().equals(productCategory.getCategoryType())) &#123;</span><br><span class="line">                    ResultDataDetailVo ResultDataDetailVo = <span class="keyword">new</span> ResultDataDetailVo();</span><br><span class="line">                    <span class="comment">// 对象拷贝工具</span></span><br><span class="line">                    BeanUtils.copyProperties(productInfo, ResultDataDetailVo);</span><br><span class="line">                    ResultDataDetailVoList.add(ResultDataDetailVo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ResultDataVo.setResultDataDetailVolist(ResultDataDetailVoList);</span><br><span class="line">            ResultDataVoList.add(ResultDataVo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultVoUtil.success(ResultDataVoList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="包装返回前端提示工具"><a href="#包装返回前端提示工具" class="headerlink" title="包装返回前端提示工具"></a>包装返回前端提示工具</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVoUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成功时返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultVo <span class="title">success</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        ResultVo ResultVo = <span class="keyword">new</span> ResultVo();</span><br><span class="line">        ResultVo.setData(object);</span><br><span class="line">        ResultVo.setCode(<span class="number">0</span>);</span><br><span class="line">        ResultVo.setMsg(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> ResultVo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无数据时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultVo <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出错时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultVo <span class="title">error</span><span class="params">(Integer code, String msg)</span> </span>&#123;</span><br><span class="line">        ResultVo ResultVo = <span class="keyword">new</span> ResultVo();</span><br><span class="line">        ResultVo.setCode(code);</span><br><span class="line">        ResultVo.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> ResultVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买家端订单信息"><a href="#买家端订单信息" class="headerlink" title="买家端订单信息"></a>买家端订单信息</h3><h4 id="create订单表"><a href="#create订单表" class="headerlink" title="create订单表"></a>create订单表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单主表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`order_master`</span> (</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`buyer_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'买家名字'</span>,</span><br><span class="line">    <span class="string">`buyer_phone`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'买家电话'</span>,</span><br><span class="line">    <span class="string">`buyer_address`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'买家地址'</span>,</span><br><span class="line">    <span class="string">`buyer_openid`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'买家微信openid'</span>,</span><br><span class="line">    <span class="string">`order_amount`</span> <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'订单总金额'</span>,</span><br><span class="line">    <span class="string">`order_status`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'0'</span> <span class="keyword">comment</span> <span class="string">'订单状态, 默认为新下单'</span>,</span><br><span class="line">    <span class="string">`pay_status`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'0'</span> <span class="keyword">comment</span> <span class="string">'支付状态, 默认未支付'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`order_id`</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">`idx_buyer_openid`</span> (<span class="string">`buyer_openid`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单详情</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`order_detail`</span> (</span><br><span class="line">    <span class="string">`detail_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`order_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`product_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`product_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'商品名称'</span>,</span><br><span class="line">    <span class="string">`product_price`</span> <span class="built_in">decimal</span>(<span class="number">8</span>,<span class="number">2</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'当前价格,单位分'</span>,</span><br><span class="line">    <span class="string">`product_quantity`</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'数量'</span>,</span><br><span class="line">    <span class="string">`product_icon`</span> <span class="built_in">varchar</span>(<span class="number">512</span>) <span class="keyword">comment</span> <span class="string">'小图'</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">current_timestamp</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">current_timestamp</span> <span class="keyword">comment</span> <span class="string">'修改时间'</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`detail_id`</span>),</span><br><span class="line">    <span class="keyword">key</span> <span class="string">`idx_order_id`</span> (<span class="string">`order_id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="OrderMaster实体"><a href="#OrderMaster实体" class="headerlink" title="OrderMaster实体"></a>OrderMaster实体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMaster</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订单id</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="comment">// 买家用户名</span></span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="comment">// 买家地址</span></span><br><span class="line">    <span class="keyword">private</span> String buyerAddress;</span><br><span class="line">    <span class="comment">// 买家手机号</span></span><br><span class="line">    <span class="keyword">private</span> String buyerPhone;</span><br><span class="line">    <span class="comment">// 买家微信openid</span></span><br><span class="line">    <span class="keyword">private</span> String buyerOpenid;</span><br><span class="line">    <span class="comment">// 订单总金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderAmount;</span><br><span class="line">    <span class="comment">// 订单状态，默认为新下单，0</span></span><br><span class="line">    <span class="keyword">private</span> Integer orderStatus = OrderStatusEnum.NEW.getCode();</span><br><span class="line">    <span class="comment">// 订单支付状态，默认未支付，0</span></span><br><span class="line">    <span class="keyword">private</span> Integer payStatus = PayStatusEnum.WAIT.getCode();</span><br><span class="line">    <span class="comment">// 订单创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">// 订单更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDetail</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String detailId;</span><br><span class="line">    <span class="comment">// 订单id</span></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="comment">// 商品id</span></span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="comment">// 商品单价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal productPrice;</span><br><span class="line">    <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer productQuantity;</span><br><span class="line">    <span class="comment">// 商品小图</span></span><br><span class="line">    <span class="keyword">private</span> String productIcon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="包装订单状态"><a href="#包装订单状态" class="headerlink" title="包装订单状态"></a>包装订单状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatusEnum implements CodeEnum &#123;</span><br><span class="line">    NEW(<span class="number">0</span>,<span class="string">"新订单"</span>),</span><br><span class="line">    FINISHED(<span class="number">1</span>,<span class="string">"已完成"</span>),</span><br><span class="line">    CANCEL(<span class="number">2</span>,<span class="string">"已取消"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    OrderStatusEnum(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要一个根据传入code值返回订单状态的方法：getOrderStatusEnum()</span></span><br><span class="line">    <span class="comment">// 问题在于代码的冗余，这样写每个枚举类都要加上</span></span><br><span class="line">    <span class="comment">// 解决在于，抽象一下，让每个类实现一个接口，接口的方法为获取状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OrderMasterDAO"><a href="#OrderMasterDAO" class="headerlink" title="OrderMasterDAO"></a>OrderMasterDAO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderMasterDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">OrderMaster</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据买家微信id查询主订单，分页显示</span></span><br><span class="line">    <span class="function">Page&lt;OrderMaster&gt; <span class="title">findByBuyerOpenid</span><span class="params">(String buyerOpenid, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDetailDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">OrderDetail</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据orderId查询订单详情</span></span><br><span class="line">    <span class="function">List&lt;OrderDetail&gt; <span class="title">findByOrderId</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="dao单元测试-2"><a href="#dao单元测试-2" class="headerlink" title="dao单元测试"></a>dao单元测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderMasterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMasterRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String OPENID = <span class="string">"110110"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderMaster orderMaster = <span class="keyword">new</span> OrderMaster();</span><br><span class="line">        orderMaster.setOrderId(<span class="string">"1234567"</span>);</span><br><span class="line">        orderMaster.setBuyerName(<span class="string">"师兄"</span>);</span><br><span class="line">        orderMaster.setBuyerPhone(<span class="string">"123456789123"</span>);</span><br><span class="line">        orderMaster.setBuyerAddress(<span class="string">"幕课网"</span>);</span><br><span class="line">        orderMaster.setBuyerOpenid(OPENID);</span><br><span class="line">        orderMaster.setOrderAmount(<span class="keyword">new</span> BigDecimal(<span class="number">2.5</span>));</span><br><span class="line"></span><br><span class="line">        OrderMaster result = repository.save(orderMaster);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByBuyerOpenid</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PageRequest request = <span class="keyword">new</span> PageRequest(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        Page&lt;OrderMaster&gt; result = repository.findByBuyerOpenid(OPENID, request);</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, result.getTotalElements());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">OrderDetailRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDetailRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderDetail orderDetail = <span class="keyword">new</span> OrderDetail();</span><br><span class="line">        orderDetail.setDetailId(<span class="string">"1234567810"</span>);</span><br><span class="line">        orderDetail.setOrderId(<span class="string">"11111112"</span>);</span><br><span class="line">        orderDetail.setProductIcon(<span class="string">"http://xxxx.jpg"</span>);</span><br><span class="line">        orderDetail.setProductId(<span class="string">"11111112"</span>);</span><br><span class="line">        orderDetail.setProductName(<span class="string">"皮蛋粥"</span>);</span><br><span class="line">        orderDetail.setProductPrice(<span class="keyword">new</span> BigDecimal(<span class="number">2.2</span>));</span><br><span class="line">        orderDetail.setProductQuantity(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        OrderDetail result = repository.save(orderDetail);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByOrderId</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;OrderDetail&gt; orderDetailList = repository.findByOrderId(<span class="string">"11111111"</span>);</span><br><span class="line">        Assert.assertNotEquals(<span class="number">0</span>, orderDetailList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OrderService"><a href="#OrderService" class="headerlink" title="OrderService"></a>OrderService</h4><h5 id="包装数据传输对象（DTO）"><a href="#包装数据传输对象（DTO）" class="headerlink" title="包装数据传输对象（DTO）"></a>包装数据传输对象（DTO）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">// 下面这句注释的作用是当返回给前端的属性值为null时就不返回该属性（字段）</span></span><br><span class="line"><span class="comment">// @JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="comment">// 当有很多对象都与前端相关，需要一个一个设置时可以使用全局配置，在application.yml文件中添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDTO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订单id</span></span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="comment">// 买家用户名</span></span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="comment">// 买家地址</span></span><br><span class="line">    <span class="keyword">private</span> String buyerAddress;</span><br><span class="line">    <span class="comment">// 买家手机号</span></span><br><span class="line">    <span class="keyword">private</span> String buyerPhone;</span><br><span class="line">    <span class="comment">// 买家微信openid</span></span><br><span class="line">    <span class="keyword">private</span> String buyerOpenid;</span><br><span class="line">    <span class="comment">// 订单总金额</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal orderAmount;</span><br><span class="line">    <span class="comment">// 订单状态，默认为新下单，0</span></span><br><span class="line">    <span class="keyword">private</span> Integer orderStatus;</span><br><span class="line">    <span class="comment">// 订单支付状态，默认未支付，0</span></span><br><span class="line">    <span class="keyword">private</span> Integer payStatus;</span><br><span class="line">    <span class="comment">// 订单创建时间</span></span><br><span class="line">    <span class="comment">// 这里的注解是为了将Date时间改为Long类型，使用的是我们自己写的Date2LongSerializer中重写的方法</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = Date2LongSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Date</span> <span class="title">createTime</span></span>;</span><br><span class="line">    <span class="comment">// 订单更新时间</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = Date2LongSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Date</span> <span class="title">updateTime</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和订单详情关联</span></span><br><span class="line">    List&lt;OrderDetail&gt; orderDetailList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加通过code值获取订单状态枚举值的方法</span></span><br><span class="line">    <span class="comment">// 这个注解的作用是对象转为Json时该属性/方法忽略</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderStatusEnum <span class="title">getOrderStatusEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumUtil.getByCode(orderStatus, OrderStatusEnum<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PayStatusEnum <span class="title">getPayStatusEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumUtil.getByCode(payStatus, PayStatusEnum<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义异常"><a href="#定义异常" class="headerlink" title="定义异常"></a>定义异常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellException</span><span class="params">(ResultEnum resultEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resultEnum.getMsg());</span><br><span class="line">        <span class="keyword">this</span>.code = resultEnum.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellException</span><span class="params">(Integer code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常信息结果枚举类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ResultEnum &#123;</span><br><span class="line">    PARAM_ERROR(<span class="number">1</span>,<span class="string">"表单参数不正确"</span>),</span><br><span class="line">    PRODUCT_NO_EXIST(<span class="number">10</span>, <span class="string">"商品不存在"</span>),</span><br><span class="line">    PRODUCT_STOCK_ERROR(<span class="number">11</span>, <span class="string">"商品库存不足"</span>),</span><br><span class="line">    ORDER_NO_EXIST(<span class="number">12</span>, <span class="string">"订单不存在"</span>),</span><br><span class="line">    ORDERDETAIL_NO_EXIST(<span class="number">13</span>, <span class="string">"订单详情不存在"</span>),</span><br><span class="line">    ORDER_STATUS_ERROR(<span class="number">14</span>,<span class="string">"订单状态不正确"</span>),</span><br><span class="line">    ORDER_UPDATE_ERROR(<span class="number">15</span>,<span class="string">"订单更改失败"</span>),</span><br><span class="line">    ORDER_EMPTY_ERROR(<span class="number">16</span>,<span class="string">"订单详情为空"</span>),</span><br><span class="line">    ORDER_PAY_STATUS_ERROR(<span class="number">17</span>,<span class="string">"订单支付状态不正确"</span>),</span><br><span class="line">    CART_EMPTY(<span class="number">18</span>,<span class="string">"购物车为空"</span>),</span><br><span class="line">    ORDER_OWNER_ERROR(<span class="number">19</span>,<span class="string">"该订单不属于当前用户"</span>),</span><br><span class="line">    WECHAT_MP_ERROR(<span class="number">20</span>,<span class="string">"微信公众账号异常"</span>),</span><br><span class="line">    WXPAY_NOTIFY_MONEY_VERIFY_ERROR(<span class="number">21</span>, <span class="string">"微信支付异步通知金额校验不通过"</span>),</span><br><span class="line">    ORDER_CANCEL_SUCCESS(<span class="number">22</span>, <span class="string">"订单取消成功"</span>),</span><br><span class="line">    ORDER_FINISH_SUCCESS(<span class="number">23</span>, <span class="string">"订单完结成功"</span>),</span><br><span class="line">    PRODUCT_STATUS_ERROR(<span class="number">24</span>, <span class="string">"商品状态不正确"</span>),</span><br><span class="line">    LOGIN_FAIL(<span class="number">25</span>, <span class="string">"登录失败, 登录信息不正确"</span>),</span><br><span class="line">    LOGOUT_SUCCESS(<span class="number">26</span>, <span class="string">"登出成功"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    ResultEnum(Integer code, String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="随机数生成主键"><a href="#随机数生成主键" class="headerlink" title="随机数生成主键"></a>随机数生成主键</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenKeyUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @description 生成唯一主键方法（时间+随机数），避免多线程出现问题，加上synchronized关键字</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return java.lang.String</span></span><br><span class="line"><span class="comment">     * @info zw 2020/1/6 16:23</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title">genUniqueKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Integer number = random.nextInt(<span class="number">900000</span>) + <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() + String.valueOf(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="购物车DTO"><a href="#购物车DTO" class="headerlink" title="购物车DTO"></a>购物车DTO</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> Integer productQuantity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CartDTO</span><span class="params">(String productId, Integer productQuantity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">this</span>.productQuantity = productQuantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMaster2OrderDTOConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrderDTO <span class="title">convert</span><span class="params">(OrderMaster orderMaster)</span></span>&#123;</span><br><span class="line">        OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">        BeanUtils.copyProperties(orderMaster, orderDTO);</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderDTO&gt; <span class="title">convert</span><span class="params">(List&lt;OrderMaster&gt; orderMasterList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderMasterList.stream().map(e -&gt;</span><br><span class="line">                convert(e)</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建订单，这里返回的是数据传输对象，在各个层中传输</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">create</span><span class="params">(OrderDTO orderDTO)</span></span>;</span><br><span class="line">    <span class="comment">// 查询单个订单</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">findOne</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="comment">// 查询订单列表</span></span><br><span class="line">    <span class="comment">// 这里是查询单个卖家订单</span></span><br><span class="line">    <span class="function">Page&lt;OrderDTO&gt; <span class="title">findListByBuyerOpenid</span><span class="params">(String buyerOpenid, Pageable pageable)</span></span>;</span><br><span class="line">    <span class="comment">// 查询所有订单列表</span></span><br><span class="line">    <span class="function">Page&lt;OrderDTO&gt; <span class="title">findAllList</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">    <span class="comment">// 取消订单</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">cancel</span><span class="params">(OrderDTO orderDTO)</span></span>;</span><br><span class="line">    <span class="comment">// 完结订单</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">finish</span><span class="params">(OrderDTO orderDTO)</span></span>;</span><br><span class="line">    <span class="comment">// 支付订单</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">paid</span><span class="params">(OrderDTO orderDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDetailDao orderDetailDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMasterDao orderMasterDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> PushMsgService pushMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订单的实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span><span class="comment">// 事务注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">create</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String orderId = GenKeyUtil.genUniqueKey();</span><br><span class="line">        BigDecimal orderAmount = <span class="keyword">new</span> BigDecimal(BigInteger.ZERO);</span><br><span class="line">        <span class="comment">// 1. 查询商品（数量，单价）</span></span><br><span class="line">        <span class="keyword">for</span> (OrderDetail orderDetail : orderDTO.getOrderDetailList()) &#123;</span><br><span class="line">            <span class="comment">// 查商品信息</span></span><br><span class="line">            ProductInfo productInfo = productService.findOne(orderDetail.getProductId());</span><br><span class="line">            <span class="comment">// 判断商品是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (productInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PRODUCT_NO_EXIST);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断数量放在库存</span></span><br><span class="line">            <span class="comment">// 2. 计算订单总价</span></span><br><span class="line">            <span class="comment">// bug1：注意是orderDetail是错的，要用productInfo</span></span><br><span class="line">            <span class="comment">// orderAmount = orderAmount.add(orderDetail.getProductPrice().multiply(new BigDecimal(orderDetail.getProductQuantity())));</span></span><br><span class="line">            orderAmount = orderAmount</span><br><span class="line">                    .add(productInfo.getProductPrice()</span><br><span class="line">                            .multiply(<span class="keyword">new</span> BigDecimal(orderDetail.getProductQuantity())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 属性拷贝，补全orderDetail的属性，注意拷贝先后顺序，拷贝中productInfo的orderId/detailId的null值也会拷贝进来</span></span><br><span class="line">            <span class="comment">// bug2：先拷贝完，再对个别值赋值。</span></span><br><span class="line">            BeanUtils.copyProperties(productInfo, orderDetail);</span><br><span class="line">            <span class="comment">// 3. 订单性情入库，前端传进来的只有两个重要信息：商品Id和购买数量，所以在入库时要补全订单详情字段</span></span><br><span class="line">            orderDetail.setDetailId(GenKeyUtil.genUniqueKey());</span><br><span class="line">            orderDetail.setOrderId(orderId);</span><br><span class="line">            <span class="comment">// 3.1 订单详情入库（OrderDetail）</span></span><br><span class="line">            orderDetailDao.save(orderDetail);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 写入订单表（OrderMaster）</span></span><br><span class="line">        OrderMaster orderMaster = <span class="keyword">new</span> OrderMaster();</span><br><span class="line">        <span class="comment">// 同bug2</span></span><br><span class="line">        <span class="comment">// controller层create函数无orderId出错bug处</span></span><br><span class="line">        orderDTO.setOrderId(orderId);</span><br><span class="line">        BeanUtils.copyProperties(orderDTO, orderMaster);</span><br><span class="line">        orderMaster.setOrderAmount(orderAmount);</span><br><span class="line">        <span class="comment">// bug3：额外的属性被覆盖，重新设置</span></span><br><span class="line">        orderMaster.setOrderStatus(OrderStatusEnum.NEW.getCode());</span><br><span class="line">        orderMaster.setPayStatus(PayStatusEnum.WAIT.getCode());</span><br><span class="line">        orderMasterDao.save(orderMaster);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 扣库存</span></span><br><span class="line">        <span class="comment">// 使用Lambert表达式生成cartDTOList</span></span><br><span class="line">        List&lt;CartDTO&gt; cartDTOList = orderDTO.getOrderDetailList().stream().map(e -&gt;</span><br><span class="line">                <span class="keyword">new</span> CartDTO(e.getProductId(), e.getProductQuantity())</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line">        productService.decreaseStock(cartDTOList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找单个订单</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">findOne</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询主订单</span></span><br><span class="line">        OrderMaster orderMaster = orderMasterDao.findOne(orderId);</span><br><span class="line">        <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (orderMaster == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询订单详情</span></span><br><span class="line">        List&lt;OrderDetail&gt; orderDetailList = orderDetailDao.findByOrderId(orderId);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(orderDetailList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDERDETAIL_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询结果用OrderDTO封装</span></span><br><span class="line">        OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">        BeanUtils.copyProperties(orderMaster, orderDTO);</span><br><span class="line">        orderDTO.setOrderDetailList(orderDetailList);</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询订单列表（单个用户的订单列表）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;OrderDTO&gt; <span class="title">findListByBuyerOpenid</span><span class="params">(String buyerOpenid, Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Page类不了解，明天看一看</span></span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        Page&lt;OrderMaster&gt; orderMasterPage =</span><br><span class="line">                orderMasterDao.findByBuyerOpenid(buyerOpenid, pageable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换</span></span><br><span class="line">        List&lt;OrderDTO&gt; orderDTOList =</span><br><span class="line">                OrderMaster2OrderDTOConverter.convert(orderMasterPage.getContent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装</span></span><br><span class="line">        Page&lt;OrderDTO&gt; orderDTOPage =</span><br><span class="line">                <span class="keyword">new</span> PageImpl&lt;OrderDTO&gt;(orderDTOList, pageable, orderDTOList.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDTOPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有订单列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;OrderDTO&gt; <span class="title">findAllList</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">        Page&lt;OrderMaster&gt; orderMasterPage = orderMasterDao.findAll(pageable);</span><br><span class="line"></span><br><span class="line">        List&lt;OrderDTO&gt; orderDTOList =</span><br><span class="line">                OrderMaster2OrderDTOConverter.convert(orderMasterPage.getContent());</span><br><span class="line"></span><br><span class="line">        Page&lt;OrderDTO&gt; orderDTOPage =</span><br><span class="line">                <span class="keyword">new</span> PageImpl&lt;OrderDTO&gt;(orderDTOList, pageable, orderDTOList.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDTOPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订单</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">cancel</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.判断订单状态，这里判断只有新订单可以取消</span></span><br><span class="line">        <span class="keyword">if</span> (!orderDTO.getOrderStatus().equals(OrderStatusEnum.NEW.getCode())) &#123;</span><br><span class="line">            <span class="comment">// 使用日志，记录下订单号和订单状态，并抛出异常</span></span><br><span class="line">            log.error(<span class="string">"[取消订单] 订单状态不正确，orderId=&#123;&#125;, orderStatus=&#123;&#125;"</span>,</span><br><span class="line">                    orderDTO.getOrderId(), orderDTO.getOrderStatus());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.修改订单状态（save）</span></span><br><span class="line">        OrderMaster orderMaster = <span class="keyword">new</span> OrderMaster();</span><br><span class="line">        <span class="comment">// 2.1 改状态为"取消"</span></span><br><span class="line">        <span class="comment">// bug4 同对象拷贝前后的问题，先将DTO的状态修改完成再拷贝到Master中，</span></span><br><span class="line">        <span class="comment">// 因为后续操作都在Master上</span></span><br><span class="line">        orderDTO.setOrderStatus(OrderStatusEnum.CANCEL.getCode());</span><br><span class="line">        BeanUtils.copyProperties(orderDTO, orderMaster);</span><br><span class="line">        <span class="comment">// 2.2 save函数参数为OrderMaster，所以上面有个转型</span></span><br><span class="line">        OrderMaster updateResult = orderMasterDao.save(orderMaster);</span><br><span class="line">        <span class="keyword">if</span> (updateResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"[取消订单] 更新失败，orderMaster=&#123;&#125;"</span>, orderMaster);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_UPDATE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.返还库存</span></span><br><span class="line">        <span class="comment">// 3.1 判断订单内是否有商品</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(orderDTO.getOrderDetailList())) &#123;</span><br><span class="line">            log.error(<span class="string">"[取消订单] 订单内无商品，orderDTO=&#123;&#125;"</span>, orderDTO);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_EMPTY_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 返回（增加）库存</span></span><br><span class="line">        <span class="comment">// 将订单OrderDTO转型为CartDTO，因为其参数格式为之</span></span><br><span class="line">        List&lt;CartDTO&gt; cartDTOList = orderDTO.getOrderDetailList().stream()</span><br><span class="line">                .map(e -&gt; <span class="keyword">new</span> CartDTO(e.getProductId(), e.getProductQuantity()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        productService.increaseStock(cartDTOList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.退还已支付金额</span></span><br><span class="line">        <span class="keyword">if</span> (orderDTO.getOrderStatus().equals(PayStatusEnum.SUCCESS.getCode())) &#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完结订单</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">finish</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断订单状态（只有新下单时候可执行）</span></span><br><span class="line">        <span class="comment">// 不是新订单就报错</span></span><br><span class="line">        <span class="keyword">if</span> (!orderDTO.getOrderStatus().equals(OrderStatusEnum.NEW.getCode())) &#123;</span><br><span class="line">            log.error(<span class="string">"[完结订单] 订单状态不正确，orderId=&#123;&#125;, orderStatus=&#123;&#125;"</span>,</span><br><span class="line">                    orderDTO.getOrderId(), orderDTO.getOrderStatus());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改订单状态（修改为已完结）</span></span><br><span class="line">        orderDTO.setOrderStatus(OrderStatusEnum.FINISHED.getCode());</span><br><span class="line">        OrderMaster orderMaster = <span class="keyword">new</span> OrderMaster();</span><br><span class="line">        BeanUtils.copyProperties(orderDTO, orderMaster);</span><br><span class="line">        OrderMaster resultOrderMaster = orderMasterDao.save(orderMaster);</span><br><span class="line">        <span class="comment">// 判断是否修改成功</span></span><br><span class="line">        <span class="keyword">if</span> (resultOrderMaster == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"[完结订单] 更新失败，orderMaster=&#123;&#125;"</span>, orderMaster);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_UPDATE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 推送微信模板消息</span></span><br><span class="line">        pushMsgService.orderStatus(orderDTO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支付订单</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">paid</span><span class="params">(OrderDTO orderDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断订单状态</span></span><br><span class="line">        <span class="keyword">if</span> (!orderDTO.getOrderStatus().equals(OrderStatusEnum.NEW.getCode())) &#123;</span><br><span class="line">            log.error(<span class="string">"[支付订单完成] 订单状态不正确，orderId=&#123;&#125;, orderStatus=&#123;&#125;"</span>,</span><br><span class="line">                    orderDTO.getOrderId(), orderDTO.getOrderStatus());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断支付状态</span></span><br><span class="line">        <span class="keyword">if</span> (!orderDTO.getPayStatus().equals(PayStatusEnum.WAIT.getCode())) &#123;</span><br><span class="line">            log.error(<span class="string">"[订单支付完成] 订单支付状态不正确，orderDTO=&#123;&#125;"</span>, orderDTO);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_PAY_STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改支付状态</span></span><br><span class="line">        orderDTO.setPayStatus(PayStatusEnum.SUCCESS.getCode());</span><br><span class="line">        OrderMaster orderMaster = <span class="keyword">new</span> OrderMaster();</span><br><span class="line">        BeanUtils.copyProperties(orderDTO, orderMaster);</span><br><span class="line">        OrderMaster resultOrderMaster = orderMasterDao.save(orderMaster);</span><br><span class="line">        <span class="comment">// 判断是否修改成功</span></span><br><span class="line">        <span class="keyword">if</span> (resultOrderMaster == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"[订单支付完成] 订单支付状态不正确，orderDTO=&#123;&#125;"</span>, orderDTO);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_UPDATE_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BuyerOrderController"><a href="#BuyerOrderController" class="headerlink" title="BuyerOrderController"></a>BuyerOrderController</h4><h5 id="api"><a href="#api" class="headerlink" title="api"></a>api</h5><h6 id="创建订单"><a href="#创建订单" class="headerlink" title="创建订单"></a>创建订单</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /sell/buyer/order/create</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name: "张三"</span><br><span class="line">phone: "18868822111"</span><br><span class="line">address: "慕课网总部"</span><br><span class="line">openid: "ew3euwhd7sjw9diwkq" //用户的微信openid</span><br><span class="line">items: [&#123;</span><br><span class="line">    productId: "1423113435324",</span><br><span class="line">    productQuantity: 2 //购买数量</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">      <span class="attr">"orderId"</span>: <span class="string">"147283992738221"</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="订单列表"><a href="#订单列表" class="headerlink" title="订单列表"></a>订单列表</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /sell/buyer/order/list</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openid: 18eu2jwk2kse3r42e2e</span><br><span class="line">page: 0 //从第0页开始</span><br><span class="line">size: 10</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"orderId"</span>: <span class="string">"161873371171128075"</span>,</span><br><span class="line">      <span class="attr">"buyerName"</span>: <span class="string">"张三"</span>,</span><br><span class="line">      <span class="attr">"buyerPhone"</span>: <span class="string">"18868877111"</span>,</span><br><span class="line">      <span class="attr">"buyerAddress"</span>: <span class="string">"慕课网总部"</span>,</span><br><span class="line">      <span class="attr">"buyerOpenid"</span>: <span class="string">"18eu2jwk2kse3r42e2e"</span>,</span><br><span class="line">      <span class="attr">"orderAmount"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"orderStatus"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"payStatus"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"createTime"</span>: <span class="number">1490171219</span>,</span><br><span class="line">      <span class="attr">"updateTime"</span>: <span class="number">1490171219</span>,</span><br><span class="line">      <span class="attr">"orderDetailList"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"orderId"</span>: <span class="string">"161873371171128076"</span>,</span><br><span class="line">      <span class="attr">"buyerName"</span>: <span class="string">"张三"</span>,</span><br><span class="line">      <span class="attr">"buyerPhone"</span>: <span class="string">"18868877111"</span>,</span><br><span class="line">      <span class="attr">"buyerAddress"</span>: <span class="string">"慕课网总部"</span>,</span><br><span class="line">      <span class="attr">"buyerOpenid"</span>: <span class="string">"18eu2jwk2kse3r42e2e"</span>,</span><br><span class="line">      <span class="attr">"orderAmount"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"orderStatus"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"payStatus"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"createTime"</span>: <span class="number">1490171219</span>,</span><br><span class="line">      <span class="attr">"updateTime"</span>: <span class="number">1490171219</span>,</span><br><span class="line">      <span class="attr">"orderDetailList"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="查询订单详情"><a href="#查询订单详情" class="headerlink" title="查询订单详情"></a>查询订单详情</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /sell/buyer/order/detail</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openid: 18eu2jwk2kse3r42e2e</span><br><span class="line">orderId: 161899085773669363</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">          <span class="attr">"orderId"</span>: <span class="string">"161899085773669363"</span>,</span><br><span class="line">          <span class="attr">"buyerName"</span>: <span class="string">"李四"</span>,</span><br><span class="line">          <span class="attr">"buyerPhone"</span>: <span class="string">"18868877111"</span>,</span><br><span class="line">          <span class="attr">"buyerAddress"</span>: <span class="string">"慕课网总部"</span>,</span><br><span class="line">          <span class="attr">"buyerOpenid"</span>: <span class="string">"18eu2jwk2kse3r42e2e"</span>,</span><br><span class="line">          <span class="attr">"orderAmount"</span>: <span class="number">18</span>,</span><br><span class="line">          <span class="attr">"orderStatus"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"payStatus"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"createTime"</span>: <span class="number">1490177352</span>,</span><br><span class="line">          <span class="attr">"updateTime"</span>: <span class="number">1490177352</span>,</span><br><span class="line">          <span class="attr">"orderDetailList"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"detailId"</span>: <span class="string">"161899085974995851"</span>,</span><br><span class="line">                <span class="attr">"orderId"</span>: <span class="string">"161899085773669363"</span>,</span><br><span class="line">                <span class="attr">"productId"</span>: <span class="string">"157875196362360019"</span>,</span><br><span class="line">                <span class="attr">"productName"</span>: <span class="string">"招牌奶茶"</span>,</span><br><span class="line">                <span class="attr">"productPrice"</span>: <span class="number">9</span>,</span><br><span class="line">                <span class="attr">"productQuantity"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"productIcon"</span>: <span class="string">"http://xxx.com"</span>,</span><br><span class="line">                <span class="attr">"productImage"</span>: <span class="string">"http://xxx.com"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /sell/buyer/order/cancel</span><br></pre></td></tr></table></figure><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openid: 18eu2jwk2kse3r42e2e</span><br><span class="line">orderId: 161899085773669363</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"成功"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: jsonnull</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h5><p>包装一个订单数据表单数据类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的属性都要通过表单验证才可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 买家手机</span></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"姓名必填"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 买家手机</span></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"手机号必填"</span>)</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">// 买家地址</span></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"地址必填"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// 买家微信openid</span></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"openid必填"</span>)</span><br><span class="line">    <span class="keyword">private</span> String openid;</span><br><span class="line">    <span class="comment">// 买家购物车信息</span></span><br><span class="line">    <span class="comment">// 这里搞不懂为什么是String类型的</span></span><br><span class="line">    <span class="meta">@NotEmpty</span>(message = <span class="string">"购物车必填"</span>)</span><br><span class="line">    <span class="keyword">private</span> String items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据类型转换-1"><a href="#数据类型转换-1" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderForm2OrderDTOConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象转型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrderDTO <span class="title">convert</span><span class="params">(OrderForm orderForm)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">        orderDTO.setBuyerName(orderForm.getName());</span><br><span class="line">        orderDTO.setBuyerPhone(orderForm.getPhone());</span><br><span class="line">        orderDTO.setBuyerAddress(orderForm.getAddress());</span><br><span class="line">        orderDTO.setBuyerOpenid(orderForm.getOpenid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面四个属性很容易设置，最后一个字符串修改较为麻烦</span></span><br><span class="line">        <span class="comment">// 购物车items是个json格式，这里利用一个gson的转格式依赖加入pom文件中</span></span><br><span class="line">        <span class="comment">// 目的是将json转成List，存入orderDTO的List&lt;OrderDetail&gt;属性中</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">        List&lt;OrderDetail&gt; orderDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用gson的方法转换</span></span><br><span class="line">            <span class="comment">// try-catch一下是否有问题</span></span><br><span class="line">            orderDetailList = gson.fromJson(orderForm.getItems(),</span><br><span class="line">                    <span class="keyword">new</span> TypeToken&lt;List&lt;OrderDetail&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"[对象转换] 错误，string=&#123;&#125;"</span>, orderForm.getItems());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PARAM_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没问题时，进行set操作</span></span><br><span class="line">        orderDTO.setOrderDetailList(orderDetailList);</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buyer/order"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerOrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BuyerService buyerService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 创建订单，这里传入参数需要验证使用注解@Valid，参数验证结果返回为BindingResult接受</span></span><br><span class="line"><span class="comment">     * @param orderForm 表单验证包装类</span></span><br><span class="line"><span class="comment">     * @param bindingResult 验证结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/create"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResultVo&lt;Map&lt;String, String&gt;&gt; create(<span class="meta">@Valid</span> OrderForm orderForm,</span><br><span class="line">                                                BindingResult bindingResult)&#123;</span><br><span class="line">        <span class="comment">// 判断验证结果</span></span><br><span class="line">        <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">            log.error(<span class="string">"[创建订单] 参数不正确 orderForm=&#123;&#125;"</span>,orderForm);</span><br><span class="line">            <span class="comment">// 这里抛出异常会抛出是哪个参数不正确</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PARAM_ERROR.getCode(),</span><br><span class="line">                    bindingResult.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证通过，开始创建订单</span></span><br><span class="line">        <span class="comment">// 注意create()函数的参数是orderDTO类型，所以这里又需要对象转型</span></span><br><span class="line">        OrderDTO orderDTO = OrderForm2OrderDTOConverter.convert(orderForm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断转换后是否还有问题</span></span><br><span class="line">        <span class="comment">// 这里是判断购物车是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(orderDTO.getOrderDetailList()))&#123;</span><br><span class="line">            log.error(<span class="string">"[创建订单] 购物车不能为空"</span>);</span><br><span class="line">            <span class="comment">// 这里抛出异常会抛出是哪个参数不正确</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.CART_EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建订单</span></span><br><span class="line">        OrderDTO createOrder = orderService.create(orderDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包装结果</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"orderId"</span>,createOrder.getOrderId());</span><br><span class="line">        <span class="keyword">return</span> ResultVoUtil.success(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 根据买家微信openid查询订单列表，分页</span></span><br><span class="line"><span class="comment">     * @param openid 买家微信openid</span></span><br><span class="line"><span class="comment">     * @param page 其实页数</span></span><br><span class="line"><span class="comment">     * @param size 每页订单个数</span></span><br><span class="line"><span class="comment">     * @return com.imooc.sell.viewobject.ResultVo&lt;java.util.List&lt;com.imooc.sell.dto.OrderDTO&gt;&gt;</span></span><br><span class="line"><span class="comment">     * @info zw 2020/1/8 21:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResultVo&lt;List&lt;OrderDTO&gt;&gt; list(<span class="meta">@RequestParam</span>(<span class="string">"openid"</span>) String openid,</span><br><span class="line">                                         <span class="meta">@RequestParam</span>(value = <span class="string">"page"</span>, defaultValue = <span class="string">"0"</span>) Integer page,</span><br><span class="line">                                         <span class="meta">@RequestParam</span>(value = <span class="string">"size"</span>, defaultValue = <span class="string">"10"</span>) Integer size)&#123;</span><br><span class="line">        <span class="comment">// 判断openid是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(openid))&#123;</span><br><span class="line">            log.error(<span class="string">"[查询订单列表] openid为空"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.PARAM_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过验证，开始查询</span></span><br><span class="line">        PageRequest pageRequest = <span class="keyword">new</span> PageRequest(page,size);</span><br><span class="line">        Page&lt;OrderDTO&gt; orderDTOPage = orderService.findListByBuyerOpenid(openid,pageRequest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ResultVoUtil.success(orderDTOPage.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单详情（单个）</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/detail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVo&lt;OrderDTO&gt; <span class="title">detail</span><span class="params">(@RequestParam(<span class="string">"openid"</span>)</span> String openid,</span></span><br><span class="line"><span class="function">                                     @<span class="title">RequestParam</span><span class="params">(<span class="string">"orderId"</span>)</span> String orderId)</span>&#123;</span><br><span class="line">        <span class="comment">// 不安全做法，因为没有openid和orderId的对比验证，随便两个字符串就可以传进去</span></span><br><span class="line">        <span class="comment">// 做法是在这里加入验证逻辑，这样的话代码显得臃肿，</span></span><br><span class="line">        <span class="comment">// 正确做法是将查询单个订单和取消订单用另一个Service实现（这里是BuyerService）</span></span><br><span class="line">        <span class="comment">// OrderDTO orderDTO = orderService.findOne(orderId);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改进</span></span><br><span class="line">        OrderDTO orderDTO = buyerService.findOneBuyerSelfOrder(openid,orderId);</span><br><span class="line">        <span class="keyword">return</span> ResultVoUtil.success(orderDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消订单</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/cancel"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVo&lt;OrderDTO&gt; <span class="title">cancel</span><span class="params">(@RequestParam(<span class="string">"openid"</span>)</span> String openid,</span></span><br><span class="line"><span class="function">                                     @<span class="title">RequestParam</span><span class="params">(<span class="string">"orderId"</span>)</span> String orderId)</span>&#123;</span><br><span class="line">        <span class="comment">// 不安全做法</span></span><br><span class="line">        <span class="comment">// 先查询订单</span></span><br><span class="line">        <span class="comment">// OrderDTO orderDTO = orderService.findOne(orderId);</span></span><br><span class="line">        <span class="comment">// orderService.cancel(orderDTO);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改进</span></span><br><span class="line">        buyerService.cancelBuyerSelfOrder(openid,orderId);</span><br><span class="line">        <span class="keyword">return</span> ResultVoUtil.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询和取消订单安全做法"><a href="#查询和取消订单安全做法" class="headerlink" title="查询和取消订单安全做法"></a>查询和取消订单安全做法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询一个订单，有验证</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">findOneBuyerSelfOrder</span><span class="params">(String openid, String orderId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消一个订单，有验证</span></span><br><span class="line">    <span class="function">OrderDTO <span class="title">cancelBuyerSelfOrder</span><span class="params">(String openid, String orderId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerServiceImpl</span> <span class="keyword">implements</span> <span class="title">BuyerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">findOneBuyerSelfOrder</span><span class="params">(String openid, String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查询出orderDTO</span></span><br><span class="line">        OrderDTO orderDTO = orderService.findOne(orderId);</span><br><span class="line">        <span class="keyword">if</span> (orderDTO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断openid和orderId订单中的openid是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(!orderDTO.getBuyerOpenid().equalsIgnoreCase(openid))&#123;</span><br><span class="line">            log.error(<span class="string">"[订单查询] openid不一致，openid=&#123;&#125;,orderDTO=&#123;&#125;"</span>,openid,orderDTO);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_OWNER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderDTO <span class="title">cancelBuyerSelfOrder</span><span class="params">(String openid, String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查询出orderDTO</span></span><br><span class="line">        OrderDTO orderDTO = orderService.findOne(orderId);</span><br><span class="line">        <span class="keyword">if</span> (orderDTO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">"【取消订单】查不到修改订单, orderId=&#123;&#125;"</span>, orderId);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断openid和orderId订单中的openid是否一致</span></span><br><span class="line">        <span class="keyword">if</span>(!orderDTO.getBuyerOpenid().equalsIgnoreCase(openid))&#123;</span><br><span class="line">            log.error(<span class="string">"[订单查询] openid不一致，openid=&#123;&#125;,orderDTO=&#123;&#125;"</span>,openid,orderDTO);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException(ResultEnum.ORDER_OWNER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderService.cancel(orderDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="微信端开发"><a href="#微信端开发" class="headerlink" title="微信端开发"></a>微信端开发</h3><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><h3 id="RESTfulAPI"><a href="#RESTfulAPI" class="headerlink" title="RESTfulAPI"></a>RESTfulAPI</h3><ul><li>REST的全称是Representational State Transfer，翻译下来就是“表现层状态转移”。  </li><li>REST的名称”表现层状态转化”中，省略了主语Resource。”表现层”其实指的是”资源”（Resources）的”表现层”。“资源”是REST架构或者说整个网络处理的核心。  </li><li>Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。  </li><li>对资源的添加，修改，删除等操作，用HTTP协议里的动词来实现。如下：     </li></ul><blockquote><p>GET    用来获取资源<br>POST  用来新建资源（也可以用于更新资源）<br>PUT    用来更新资源<br>DELETE  用来删除资源  </p></blockquote><ul><li>Server和Client之间传递某资源的一个表现形式，比如用JSON，XML传输文本。</li><li>用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。 </li></ul><p>结合本项目做具体阐述：</p><p>Spring中也有Restful请求相关的注解<code>@RestController</code>，它是Spring4.0新添加的，是<code>@Controller</code>，<code>@ResponseBody</code>的组合注解。该注解用于controller上，该注解下的方法返回的对象（可序列化的）可直接响应给客户端，以json格式展示，也可用于前后端分离的项目（返回的对象模型可以填充到前端界面中）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/buyer/product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerProductController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CategoryService categoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVO <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.查询所有的上架的商品</span></span><br><span class="line">        List&lt;ProductInfo&gt; productInfoList=productService.findUpAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.查询在架商品所属类目（一次性查询）</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; categoryTypeList=new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //传统方法</span></span><br><span class="line"><span class="comment">//        for(ProductInfo productInfo: productInfoList)&#123;</span></span><br><span class="line"><span class="comment">//            categoryTypeList.add(productInfo.getCategoryType());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//精简方法lamba表达式</span></span><br><span class="line">        List&lt;Integer&gt; categoryTypeList=productInfoList.stream()</span><br><span class="line">                .map(e-&gt;e.getCategoryType()).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;ProductCategory&gt; productCategoryList=categoryService.findByCategoryTypeIn(categoryTypeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 数据拼装</span></span><br><span class="line">        List&lt;ProductVO&gt; productVOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ProductCategory productCategory: productCategoryList)&#123;</span><br><span class="line">            ProductVO productVO=<span class="keyword">new</span> ProductVO();</span><br><span class="line">            productVO.setCategoryName(productCategory.getCategoryName());</span><br><span class="line">            productVO.setCategoryType(productCategory.getCategoryType());</span><br><span class="line"></span><br><span class="line">            List&lt;ProductInfoVO&gt; productInfoVOList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(ProductInfo productInfo: productInfoList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(productInfo.getCategoryType().equals(productCategory.getCategoryType()))&#123;</span><br><span class="line">                    ProductInfoVO productInfoVO=<span class="keyword">new</span> ProductInfoVO();</span><br><span class="line">                    BeanUtils.copyProperties(productInfo,productInfoVO);</span><br><span class="line">                    productInfoVOList.add(productInfoVO);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            productVO.setProductInfoVOList(productInfoVOList);</span><br><span class="line">            productVOList.add(productVO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ResultVO resultVO=new ResultVO();</span></span><br><span class="line"><span class="comment">//        resultVO.setData(productVOList);</span></span><br><span class="line"><span class="comment">//        resultVO.setCode(0);</span></span><br><span class="line"><span class="comment">//        resultVO.setMsg("成功");</span></span><br><span class="line">        ResultVO resultVO=ResultVOUtil.success(productVOList);</span><br><span class="line">        <span class="keyword">return</span> resultVO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResultVO的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultVO</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3068837394742385883L</span>;</span><br><span class="line">    <span class="comment">/**错误码**/</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**提示信息**/</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**具体内容**/</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面商品列表的接口，<code>http://127.0.0.1:8080/sell/buyer/order/list?openid=abcabcvc</code>。</p><p>首先，我们用浏览器访问，会返回如下的json数据：</p><p><img src="/2019/12/26/Sell-Project/k0f9bQ.png" alt="rest1.PNG"></p><p>使用前端界面访问，就会得到如下画面：</p><p><img src="/2019/12/26/Sell-Project/k0fpDg.png" alt="rest2.PNG"></p><p>所以对于前后端分离的项目，前后端人员可以共同协商写一份API文档（包含访问接口，和返回数据格式），然后后端人员，就会根据根据接口进行开发，并按API文档要求返回指定格式的数据。 </p><hr><p>详情参考：   </p><ul><li>知乎热门话题：  <a href="https://www.zhihu.com/topic/19579308/top-answers" target="_blank" rel="noopener">RESTful</a>   </li><li>阮一峰的两篇文章：   <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a>   <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api" target="_blank" rel="noopener">RESTful API 设计指南</a>      </li><li>Spring构建RESTful Web Service的GETTING STARTED教程:  <a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">Building a RESTful Web Service</a></li></ul><h3 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h3><h4 id="什么是日志日志框架"><a href="#什么是日志日志框架" class="headerlink" title="什么是日志日志框架"></a>什么是日志日志框架</h4><ul><li>一套能够实现日志输出的工具包。</li><li>能够描述系统运行状态的所有时间都可以算作日志，包括用户下线，接口超时，数据库崩溃。</li></ul><h4 id="日志框架的能力"><a href="#日志框架的能力" class="headerlink" title="日志框架的能力"></a>日志框架的能力</h4><ul><li>定制输出目标。</li><li>定制输出格式。</li><li>日志携带的上下文信息，如时间戳、类路径、线程、调用对象等等。</li><li>运行时的选择性输出，比如现在的系统正常，我就只关心正常的日志，假如现在系统运行特别慢，那我可能就比较关心数据库访问层的问题，也就是DAO层的细节，这时候如果能够把这部分相关的日志打印出来，就很重要了。</li><li>灵活的配置。</li><li>优异的性能。</li></ul><h4 id="常用的日志框架"><a href="#常用的日志框架" class="headerlink" title="常用的日志框架"></a>常用的日志框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日志门面        日志实现</span><br><span class="line">JCL             Log4j</span><br><span class="line">SLF4J           Log4j2</span><br><span class="line">jboss           Logback</span><br><span class="line">                JUL</span><br></pre></td></tr></table></figure><p>进过比较，我们选用SLF4j和Logback。Spring Boot里面用的就是SLF4j和Logback，在使用Spring Boot构建web项目是，我们引入了，下面的起步依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个起步依赖已经引入了SLF4j和Logback，所以我们不必再显示引入。</p><p><img src="/2019/12/26/Sell-Project/5b193a5139484.png" alt></p><ul><li>使用方法： 如果在A类中使用日志，先以该类为参数构造一个对象，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger=LoggerFactory.getLogger(A<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">"debug......"</span>);</span><br><span class="line">log.info(<span class="string">"name: &#123;&#125; , password: &#123;&#125;"</span>,name,password);</span><br><span class="line">log.error(<span class="string">"error......"</span>);</span><br><span class="line">log.warn(<span class="string">"warning....."</span>);</span><br></pre></td></tr></table></figure><h4 id="更简洁的使用技巧"><a href="#更简洁的使用技巧" class="headerlink" title="更简洁的使用技巧"></a>更简洁的使用技巧</h4><p>上面每次使用都要构造一个Logger对象，有没有很麻烦。<br>其实在IEDA里，我们可以有一点小技巧。可以不用构造Logger对象。</p><p>首先，添加以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在IDEA中安装lombok插件，然后在需要打印日志的类上用<code>@Slf4j</code>注解。<br>这样在该类中就可以直接使用<code>log</code>对象了。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoggerTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private final Logger logger= LoggerFactory.getLogger(LoggerTest.class);</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String name=<span class="string">"imooc"</span>;</span><br><span class="line">        String password=<span class="string">"123456"</span>;</span><br><span class="line">        <span class="comment">//要安裝Lombok插件，才能直接用log</span></span><br><span class="line">        log.debug(<span class="string">"debug......"</span>);</span><br><span class="line">        log.info(<span class="string">"name: &#123;&#125; , password: &#123;&#125;"</span>,name,password);</span><br><span class="line">        log.error(<span class="string">"error......"</span>);</span><br><span class="line">        log.warn(<span class="string">"warning....."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在日志里输出变量,用占位符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="string">"Mary"</span>;</span><br><span class="line">log.info(<span class="string">"name: &#123;&#125;"</span>,name);</span><br></pre></td></tr></table></figure><h4 id="Logback的配置"><a href="#Logback的配置" class="headerlink" title="Logback的配置"></a>Logback的配置</h4><ul><li>方法一：在application.yml中配置，这里能配置的东西比较简单，只能配置日志文件的路径，日志输出格式等一些简单的配置。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">"%d - %msg%n"</span> <span class="comment">#配置日志的打印格式</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">F:/日志/sell.log</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.imooc.LoggerTest:</span> <span class="string">debug</span> <span class="comment">#将日志级别指定到一个类</span></span><br></pre></td></tr></table></figure><ul><li>方法二：在logback-spring.xml配置，可以进行一些复杂的配置。比如有下面的需求：<ul><li>区分info和error日志</li><li>每天产生一个日志文件</li></ul></li></ul><p>在<code>resource</code>目录下建立logback-spring.xml文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1. 控制台日志输出的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2. 日志输出文件，infor级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileInfoLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 滚动策略，按时间滚动，每天一个日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>F:/日志/info.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3. 日志输出文件，error级别--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 滚动策略，按时间滚动，每天一个日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>F:/日志/error.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--下面声明把以上的配置用在哪里，root即对整个项目都适用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileInfoLog"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于每个配置项的含义，已用注解作简要说明。不过我们还是有必要了解一下日志级别，在<code>package org.slf4j.event;</code>有一个Level的枚举类，它定义了日志级别，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line"></span><br><span class="line">    ERROR(ERROR_INT, <span class="string">"ERROR"</span>), </span><br><span class="line">    WARN(WARN_INT, <span class="string">"WARN"</span>), </span><br><span class="line">    INFO(INFO_INT, <span class="string">"INFO"</span>), </span><br><span class="line">    DEBUG(DEBUG_INT, <span class="string">"DEBUG"</span>), </span><br><span class="line">    TRACE(TRACE_INT, <span class="string">"TRACE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> levelInt;</span><br><span class="line">    <span class="keyword">private</span> String levelStr;</span><br><span class="line"></span><br><span class="line">    Level(<span class="keyword">int</span> i, String s) &#123;</span><br><span class="line">        levelInt = i;</span><br><span class="line">        levelStr = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> levelInt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the string representation of this Level.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> levelStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面定义的TRACE、DEBUG、INFO、WARN、ERROR，表明严重性逐渐增加。</p><h4 id="lombok其他的作用"><a href="#lombok其他的作用" class="headerlink" title="lombok其他的作用"></a>lombok其他的作用</h4><p>上面引入的lombok依赖还有其他的作用，我们在项目中与许多Entity和DTO，它们有许多字段，而且需要get、set方法。我们可以在该实体类上使用@Data注解，那么实体类就不需要显示写get、set方法了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CategoryForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer categoryId;</span><br><span class="line">    <span class="comment">/**类目名字**/</span></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="comment">/** 类目编号**/</span></span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该实体类只需get或set方法，那么就可以使用@Getter或@Setter注解。</p><h3 id="Java8特性"><a href="#Java8特性" class="headerlink" title="Java8特性"></a>Java8特性</h3><p>项目中BuyerProductController.java中有这么一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询所有的上架的商品</span></span><br><span class="line">List&lt;ProductInfo&gt; productInfoList=productService.findUpAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询在架商品所属类目（一次性查询）</span></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; categoryTypeList=new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //传统方法</span></span><br><span class="line"><span class="comment">//        for(ProductInfo productInfo: productInfoList)&#123;</span></span><br><span class="line"><span class="comment">//            categoryTypeList.add(productInfo.getCategoryType());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//精简方法lamba表达式</span></span><br><span class="line">List&lt;Integer&gt; categoryTypeList=productInfoList.stream()</span><br><span class="line">        .map(e-&gt;e.getCategoryType()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//或者像下面这样使用方法引用来简化lambda表达式</span></span><br><span class="line"><span class="comment">//  List&lt;Integer&gt; categoryTypeList=productInfoList.stream()</span></span><br><span class="line"><span class="comment">//                .map(ProductInfo::getCategoryType).collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure><p>上面代码中涉及了一些java8的知识：</p><ol><li>Stream（流）</li><li>lambda表达式</li><li>使用方法引用来简化lambda表达式</li><li>使用Stream操作集合</li></ol><p>在学习lambda表达式之前，要先了解函数式接口。</p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口是只含有一个抽象方法的接口，比如下面就是一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以使用@FunctionalInterface注解函数式接口，使用该注解后，该接口就只能定义一个抽象方法。</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>我们可以使用lambda表达式来实现一个函数式接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyFunInterface lengthCal = s -&gt; s.length();</span><br><span class="line">       <span class="keyword">int</span> len=lengthCal.test(<span class="string">"hello"</span>);</span><br><span class="line">       System.out.println(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h4><p>lambda表达式还是比较常用，很简洁。不过还有比lambda表达式更简洁的写法，那就是方法引用，先上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.上面lambda可以用：引用类方法简化</span></span><br><span class="line">MyFunInterface lengthCal1=String::length;</span><br><span class="line"><span class="keyword">int</span> len1=lengthCal.test(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>以上是使用方法引用来简化lambda表达式。如果lambda表达式的方法体只有一个方法调用，可以使用方法引用来简化lambda表达式。</p><p>下面对几种方法引用的方式总结：</p><table><thead><tr><th align="left">种类</th><th align="left">使用方式</th></tr></thead><tbody><tr><td align="left">引用类方法</td><td align="left">类名::类方法</td></tr><tr><td align="left">引用类的实例方法</td><td align="left">类名::实例方法</td></tr><tr><td align="left">引用特定对象的实例方法</td><td align="left">特定对象::实例方法</td></tr><tr><td align="left">引用构造器</td><td align="left">类名::new</td></tr></tbody></table><p>下面一段代码用例子说明了上面四种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunInterface1</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">subStr</span><span class="params">(String s,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunInterface2</span></span>&#123;</span><br><span class="line">    <span class="function">JFrame <span class="title">win</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 下面是对4种方式的举例</span></span><br><span class="line">       MyFunInterface intValConvertor = from-&gt;Integer.valueOf(from);</span><br><span class="line">       <span class="keyword">int</span> intVal = intValConvertor.test(<span class="string">"2018"</span>);</span><br><span class="line">       <span class="comment">// 1.上面个lambda可以用：引用类方法简化</span></span><br><span class="line">       MyFunInterface intValConvertor1=Integer::valueOf;</span><br><span class="line">       intVal=intValConvertor1.test(<span class="string">"2018"</span>);</span><br><span class="line">       System.out.println(intVal);</span><br><span class="line"></span><br><span class="line">       MyFunInterface1 subStrUtil=(a, b, c)-&gt;a.substring(b,c);</span><br><span class="line">       String sub=subStrUtil.subStr(<span class="string">"hello world"</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//2.上面lambda可以用：引用类的实例方法简化</span></span><br><span class="line">       MyFunInterface1 subStrUtil1=String::substring;</span><br><span class="line">       String sub1=subStrUtil1.subStr(<span class="string">"hello world"</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">       System.out.println(sub);</span><br><span class="line"></span><br><span class="line">       MyFunInterface begIdxCal= s-&gt;<span class="string">"hello world"</span>.indexOf(s);</span><br><span class="line">       <span class="keyword">int</span> begIdx=begIdxCal.test(<span class="string">"lo"</span>);</span><br><span class="line">       <span class="comment">//3.上面lambda可以用：引用特定对象的实例方法简化</span></span><br><span class="line">       MyFunInterface begIdxCal1=<span class="string">"hello world"</span>::indexOf;</span><br><span class="line">       <span class="keyword">int</span> begIdx1=begIdxCal1.test(<span class="string">"lo"</span>);</span><br><span class="line">       System.out.println(begIdx1);</span><br><span class="line"></span><br><span class="line">       MyFunInterface2 jFrame=a-&gt;<span class="keyword">new</span> JFrame(a);</span><br><span class="line">       JFrame jf=jFrame.win(<span class="string">"我的窗口"</span>);</span><br><span class="line">       <span class="comment">//4.上面的lambda可以用：引用构造器简化</span></span><br><span class="line">       MyFunInterface2 jFrame2=JFrame::<span class="keyword">new</span>;</span><br><span class="line">       JFrame jf2=jFrame2.win(<span class="string">"我的窗口"</span>);</span><br><span class="line">       System.out.println(jf2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Stream来操作集合"><a href="#使用Stream来操作集合" class="headerlink" title="使用Stream来操作集合"></a>使用Stream来操作集合</h4><p>现在主要讲解流中和集合操作相关的的知识。</p><p>本文的开头<code>productInfoList.stream()</code>返回一个Stream对象，下面挑选stream中一个典型的方法分析一下使用方式。</p><ul><li>下面是map方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a stream consisting of the results of applying the given</span></span><br><span class="line"><span class="comment">     * function to the elements of this stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate</span></span><br><span class="line"><span class="comment">     * operation&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; The element type of the new stream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment">     *               &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     *               function to apply to each element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>上面注释就是说该方法返回一个流，该流是一个中间操作，它包含通过mapper函数运算后结果。</p><p>比如<code>productInfoList.stream().map(e-&gt;e.getCategoryType())</code>就是将集合中商品的种类映射为一个Stream，它是一个中间流，再看后面一部分<code>collect(Collectors.toList())</code>，它表示把这个中间流变成一个List。<br>下面我们对Collectors这个类进行探究。</p><h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>下面是Collectors类注释的截图：</p><p><img src="/2019/12/26/Sell-Project/5b1fe2d195239.png" alt></p><p>使用方式说的很明白，详情参见：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html" target="_blank" rel="noopener">Collectors的API文档</a></p><p>下面用一个例子对上面的文档进行详细说明，建议在在IDEA里debug模式下运行，查看个变量的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;People&gt; peopleList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        peopleList.add(<span class="keyword">new</span> People(<span class="string">"sun"</span>,<span class="string">"male"</span>,<span class="number">23</span>,<span class="number">8000.0</span>));</span><br><span class="line">        peopleList.add(<span class="keyword">new</span> People(<span class="string">"li"</span>,<span class="string">"female"</span>,<span class="number">21</span>,<span class="number">7600.1</span>));</span><br><span class="line">        peopleList.add(<span class="keyword">new</span> People(<span class="string">"wang"</span>, <span class="string">"male"</span>, <span class="number">32</span>, <span class="number">9000</span>));</span><br><span class="line">        peopleList.add(<span class="keyword">new</span> People(<span class="string">"fan"</span>,<span class="string">"female"</span>,<span class="number">18</span>,<span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将姓名收集到一个list</span></span><br><span class="line">        List&lt;String&gt; nameList = peopleList.stream().map(People::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将姓名收集到一个set</span></span><br><span class="line">        Set&lt;String&gt; nameSet=peopleList.stream().map(People::getName).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将姓名以逗号为分隔符连接</span></span><br><span class="line">        String nameJoined = peopleList.stream().map(People::getName).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算总年龄</span></span><br><span class="line">        <span class="keyword">int</span> totalAge=peopleList.stream().collect(Collectors.summingInt(People::getAge));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以性别对人员分组</span></span><br><span class="line">        Map&lt;String, List&lt;People&gt;&gt; bySex = peopleList.stream().collect(Collectors.groupingBy(People::getSex));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算各性别的总薪水</span></span><br><span class="line">        Map&lt;String,Double&gt; totalBySex=peopleList.stream().collect(Collectors.groupingBy(People::getSex,</span><br><span class="line">                Collectors.summingDouble(People::getSalary)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以6000薪水分割线对人员分组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;People&gt;&gt; pass6000 = peopleList.stream().collect(Collectors.partitioningBy(people -&gt; people.getSalary() &gt; <span class="number">6000</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, String sex, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Structure</title>
      <link href="/2019/12/10/Data-Structure/"/>
      <url>/2019/12/10/Data-Structure/</url>
      
        <content type="html"><![CDATA[<p>前言</p><blockquote><p>慕课网刘宇波数据结构课程简记</p></blockquote><a id="more"></a><h2 id="课程：《玩转数据结构》"><a href="#课程：《玩转数据结构》" class="headerlink" title="课程：《玩转数据结构》"></a>课程：《玩转数据结构》</h2><h3 id="问题一：循环队列"><a href="#问题一：循环队列" class="headerlink" title="问题一：循环队列"></a>问题一：循环队列</h3><p>一般认为，从队尾添加元素，从队首取出元素（FIFO）。</p><p>如下图：</p><p><img src="/2019/12/10/Data-Structure/image-20191210213838392.png" alt="image-20191210213838392"></p><p>空队列：<code>front == tail</code></p><p><img src="/2019/12/10/Data-Structure/image-20191210214044864.png" alt="image-20191210214044864"></p><p>问题在于下面这种情况，<code>tail</code>需要处理</p><p><img src="/2019/12/10/Data-Structure/image-20191210214215317.png" alt="image-20191210214215317"></p><p>处理方式：<code>tail = (tail + 1) % capacity</code></p><p><img src="/2019/12/10/Data-Structure/image-20191210214309970.png" alt="image-20191210214309970"></p><p>达成目标，这时，注意到队列中有一个空位置，这是特意“浪费”一个位置用来标识队列满。<br>队列满条件：<code>(tail + 1) % capacity = front</code></p><p><img src="/2019/12/10/Data-Structure/image-20191210214511013.png" alt="image-20191210214511013"></p><h3 id="问题二：递归"><a href="#问题二：递归" class="headerlink" title="问题二：递归"></a>问题二：递归</h3><p><img src="/2019/12/10/Data-Structure/image-20191211102706151.png" alt="image-20191211102706151"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumRecusion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露给用户调用的和函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正调用的递归求和的和函数</span></span><br><span class="line">    <span class="comment">// 功能为计算arr[l ... n]范围内的数字和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求解最基本的问题</span></span><br><span class="line">        <span class="keyword">if</span> (l == arr.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 把原问题转化为更小的问题</span></span><br><span class="line">        <span class="comment">// 调用sum函数理解为一个和完成指定功能的子函数的调用</span></span><br><span class="line">        <span class="keyword">return</span> arr[l] + sum(arr, l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/10/Data-Structure/image-20191211103958276.png" alt="image-20191211103958276"></p><h4 id="链表和递归"><a href="#链表和递归" class="headerlink" title="链表和递归"></a>链表和递归</h4><p><img src="/2019/12/10/Data-Structure/image-20191211104530011.png" alt="image-20191211104530011"></p><p>问题示例：递归删除链表中某个元素值</p><p><img src="/2019/12/10/Data-Structure/image-20191211104813317.png" alt="image-20191211104813317"></p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionRemoveElement</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 基本版</span></span><br><span class="line"><span class="comment">        ListNode res = removeElements(head.next, val);</span></span><br><span class="line"><span class="comment">        if(head.val == val)</span></span><br><span class="line"><span class="comment">            return res;</span></span><br><span class="line"><span class="comment">        else&#123;</span></span><br><span class="line"><span class="comment">            head.next = res;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精简版</span></span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="微观分析"><a href="#微观分析" class="headerlink" title="微观分析"></a>微观分析</h4><p><img src="/2019/12/10/Data-Structure/image-20191211133351190.png" alt="image-20191211133351190"></p><p><img src="/2019/12/10/Data-Structure/image-20191211133940119.png" alt="image-20191211133940119"></p><p><img src="/2019/12/10/Data-Structure/image-20191211134230823.png" alt="image-20191211134230823"></p><h3 id="问题三：二叉树"><a href="#问题三：二叉树" class="headerlink" title="问题三：二叉树"></a>问题三：二叉树</h3><h4 id="构建一个二叉树：（4个类试验一下）"><a href="#构建一个二叉树：（4个类试验一下）" class="headerlink" title="构建一个二叉树：（4个类试验一下）"></a>构建一个二叉树：（4个类试验一下）</h4><p>TreeNode Class节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> playwithdatastructure.f_binary_search_tree.TreeDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/3/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    Integer val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(Integer val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(Integer val, TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryTree Interface 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> playwithdatastructure.f_binary_search_tree.TreeDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/3/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversalNR</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversalNR</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversalNR</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryTreeImpl 二叉树实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> playwithdatastructure.f_binary_search_tree.TreeDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/3/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeImpl</span> <span class="keyword">implements</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeImpl</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeImpl</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 暴露二叉树节点数函数</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return int</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSize(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归具体实现获取size</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSize = getSize(node.left);</span><br><span class="line">        <span class="keyword">int</span> rightSize = getSize(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftSize + rightSize + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 暴露判空函数</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return boolean</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:48</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 暴露获取二叉树高度函数</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return int</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:49</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归实现获取二叉树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = getHeight(node.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightHeight = getHeight(node.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> leftHeight &gt; rightHeight ? leftHeight : rightHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 递归获取二叉树前序遍历</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"此为空树"</span>);</span><br><span class="line">        System.out.println(<span class="string">"二叉树递归前序遍历"</span>);</span><br><span class="line">        <span class="keyword">this</span>.preOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二叉树前序遍历具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(node.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 暴露二叉树中序遍历函数</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:50</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"此为空树"</span>);</span><br><span class="line">        System.out.println(<span class="string">"二叉树递归中序遍历"</span>);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.print(node.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 暴露二叉树后序遍历</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 21:54</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"此为空树"</span>);</span><br><span class="line">        System.out.println(<span class="string">"二叉树递归后序遍历"</span>);</span><br><span class="line">        postOrder(root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.print(node.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 二叉树层次遍历（广度优先遍历）</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 22:00</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"二叉树层次遍历："</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode curNode = queue.poll();</span><br><span class="line">            System.out.print(curNode.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            <span class="keyword">if</span>(curNode.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curNode.left);</span><br><span class="line">            <span class="keyword">if</span>(curNode.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 先序遍历非递归实现，可以发现广度优先遍历和非递归前序遍历只有</span></span><br><span class="line"><span class="comment">     * 辅助工具不同，一个用队列，一个用栈</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 22:15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraversalNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"此为空树"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非递归实现前序遍历"</span>);</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode curNode = stack.pop();</span><br><span class="line">            System.out.print(curNode.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            <span class="keyword">if</span>(curNode.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(curNode.right);</span><br><span class="line">            <span class="keyword">if</span>(curNode.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(curNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 中序遍历非递归实现</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 22:27</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraversalNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"此为空树"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非递归实现中序遍历"</span>);</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode curNode = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || curNode !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(curNode);</span><br><span class="line">                curNode = curNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = stack.pop();</span><br><span class="line">            System.out.print(curNode.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            curNode = curNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* @description 后序遍历非递归实现</span></span><br><span class="line"><span class="comment">     * @param</span></span><br><span class="line"><span class="comment">     * @return void</span></span><br><span class="line"><span class="comment">     * @info zw 2020/3/21 22:34</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraversalNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 2020/3/21</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryTreeTest 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> playwithdatastructure.f_binary_search_tree.TreeDemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createDate</span>: 2020/3/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一棵基本的二叉树</span></span><br><span class="line">        TreeNode node7  = <span class="keyword">new</span> TreeNode(<span class="number">7</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node6  = <span class="keyword">new</span> TreeNode(<span class="number">6</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node3  = <span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node5  = <span class="keyword">new</span> TreeNode(<span class="number">5</span>, node6, node7);</span><br><span class="line">        TreeNode node2  = <span class="keyword">new</span> TreeNode(<span class="number">2</span>, node3, node5);</span><br><span class="line">        TreeNode node8  = <span class="keyword">new</span> TreeNode(<span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node11 = <span class="keyword">new</span> TreeNode(<span class="number">11</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node12 = <span class="keyword">new</span> TreeNode(<span class="number">12</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node10 = <span class="keyword">new</span> TreeNode(<span class="number">10</span>, node11, node12);</span><br><span class="line">        TreeNode node9  = <span class="keyword">new</span> TreeNode(<span class="number">9</span>, node10, <span class="keyword">null</span>);</span><br><span class="line">        TreeNode node4  = <span class="keyword">new</span> TreeNode(<span class="number">4</span>, node8, node9);</span><br><span class="line"></span><br><span class="line">        TreeNode root  = <span class="keyword">new</span> TreeNode(<span class="number">1</span>, node4, node2);</span><br><span class="line">        BinaryTreeImpl link = <span class="keyword">new</span> BinaryTreeImpl(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看树是否为空</span></span><br><span class="line">        System.out.println(link.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序递归遍历</span></span><br><span class="line">        link.preOrderTraversal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序递归遍历</span></span><br><span class="line">        link.inOrderTraversal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后序递归遍历</span></span><br><span class="line">        link.postOrderTraversal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> size = link.size();</span><br><span class="line">        System.out.println(<span class="string">"个数是："</span>+size);</span><br><span class="line">        <span class="comment">//得到树的高度</span></span><br><span class="line">        <span class="keyword">int</span> height = link.getHeight();</span><br><span class="line">        System.out.println(<span class="string">"树的高度是："</span>+height);</span><br><span class="line">        <span class="comment">//借助队列实现层次遍历</span></span><br><span class="line">        link.levelOrderTraversal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助栈实现先序遍历</span></span><br><span class="line">        link.preOrderTraversalNR();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借助栈实现中序遍历，不采用递归</span></span><br><span class="line">        link.inOrderTraversalNR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树中序遍历</a></p><p>给定一个二叉树，返回它的中序遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p>迭代：</p><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Online Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crash Course Computer Science</title>
      <link href="/2019/12/09/Crash-Course-Computer-Science/"/>
      <url>/2019/12/09/Crash-Course-Computer-Science/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p><a href="https://www.bilibili.com/video/av21376839" target="_blank" rel="noopener">计算机科学速成课</a></p></blockquote><a id="more"></a><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209102345330.png" alt="image-20191209102345330"></p><h2 id="第-1-集：计算机早期历史"><a href="#第-1-集：计算机早期历史" class="headerlink" title="第 1 集：计算机早期历史"></a>第 1 集：计算机早期历史</h2><p>提到的设备：算盘 → 步进计算器 → 差分机 → 分析机 → 打孔卡片制表机<br>提到的人名：Charles Babbage, Ada Lovelace</p><p>02:27 最早的计算设备是算盘，举例如何使用<br>04:31 Computer 从指代职业变成指代机器<br>04:57 机器里有名的是：步进计算器。第一个可以做加减乘除的机器<br>06:44 炮弹为了精准，要计算弹道，二战是查表来做。但每次改设计了就需要做一张新表<br>07:30 Charles Babbage 提出了 “差分机”, 在构造差分机期间，想出了分析机, 分析机是通用计算机<br>08:50 Lovelace 给分析机写了假想程序，因此成为了第一位程序员<br>09:25 人口普查 10 年一次. Herman Hollerith 的打孔卡片制表机大大提升了效率</p><h2 id="第-2-集：电子计算机"><a href="#第-2-集：电子计算机" class="headerlink" title="第 2 集：电子计算机"></a>第 2 集：电子计算机</h2><p>提到的设备：继电器 → 真空管 → 晶体管</p><p>00:17 20世纪的发展要求更强的计算能力。柜子大小的计算机发展到房间大小<br>01:06 哈佛 Mark 1 号，IBM 1944 年做的<br>02:25 继电器，继电器一秒最多 50 次开关<br>03:24 继电器出 bug<br>03:49 1904 年，热电子管出现，第一个真空管。改进后变成和继电器的功能一样<br>05:34 “巨人1号” 计算机在英国 布莱切利园 首次大规模使用真空管。但编程麻烦，还要配置<br>06:40 1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机<br>07:36 1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管<br>09:27 硅谷的典故：很多晶体管和半导体的开发都是这里做的。而生产半导体最常见的材料是硅<br>09:41 肖克利半导体 → 仙童半导体 → 英特尔</p><h2 id="第-3-集：布尔逻辑和逻辑门"><a href="#第-3-集：布尔逻辑和逻辑门" class="headerlink" title="第 3 集：布尔逻辑和逻辑门"></a>第 3 集：布尔逻辑和逻辑门</h2><p>01:00 什么是二进制, 为什么用二进制, 布尔逻辑<br>02:46 3个基本操作：NOT，AND，OR<br>02:51 解释3个基本操作<br>07:11 XOR 异或</p><h2 id="第-4-集：二进制"><a href="#第-4-集：二进制" class="headerlink" title="第 4 集：二进制"></a>第 4 集：二进制</h2><p>00:46 用十进制举例二进制的原理，演示二进制加法。存储单位 MB GB TB 等<br>05:30 正数，负数，整数，浮点数的表示<br>07:20 美国信息交换标准代码 - ASCII, 用来表示字符<br>09:00 UNICODE 1992 年诞生，是字符编码标准， 解决 ASCII 不够表达所有语言的问题</p><h2 id="第-5-集：算数逻辑单元-ALU"><a href="#第-5-集：算数逻辑单元-ALU" class="headerlink" title="第 5 集：算数逻辑单元 - ALU"></a>第 5 集：算数逻辑单元 - ALU</h2><p>00:03 简单介绍 ALU ，英特尔 74181<br>01:24 ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元</p><p>01:32 算术单元<br>半加器 (处理1个 bit，2个输入)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091108226.png" alt="image-20191209091108226"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091134336.png" alt="image-20191209091134336"></p><p>全加器 (处理1个 bit，3个输入)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091320872.png" alt="image-20191209091320872"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091401064.png" alt="image-20191209091401064"></p><p>8 bit 加法 (1个半加器，7个全加器）</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209091505711.png" alt="image-20191209091505711"></p><p>溢出的概念，吃豆人的例子<br>乘法除法</p><p>07:32 逻辑单元<br>检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）<br>ALU 抽象成一个 V 符号<br>Flag 标志（是否相等，是否小于，是否溢出等等）</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092043700.png" alt="image-20191209092043700"></p><h2 id="第-6-集：寄存器和内存"><a href="#第-6-集：寄存器和内存" class="headerlink" title="第 6 集：寄存器和内存"></a>第 6 集：寄存器和内存</h2><p>本集重点是 Memory （存储 / 内存 两种含义）</p><p>03:30 存 1 位 (Gated Latch - 锁存器）</p><p>永久存1（逻辑与输出接回输入）：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092532043.png" alt="image-20191209092532043"></p><p>永久存0（逻辑和输出接回输入）：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092711762.png" alt="image-20191209092711762"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092737143.png" alt="image-20191209092737143"></p><p>将电路连接起来：</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209092802131.png" alt="image-20191209092802131"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209094109974.png" alt="image-20191209094109974"></p><p>换个方式</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209095304803.png" alt="image-20191209095304803"></p><p>数据输入线：设为0或者1来存储值<br>启动线：允许启动或关闭存储</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100017621.png" alt="image-20191209100017621"></p><p>向上抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209095704584.png" alt="image-20191209095704584"></p><p>允许写入线的开关控制数据输入线的值能否存储入门锁中。</p><p>04:48 存 8 位 (Register - 寄存器)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100142534.png" alt="image-20191209100142534"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100219842.png" alt="image-20191209100219842"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100256357.png" alt="image-20191209100256357"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100315457.png" alt="image-20191209100315457"></p><p>05:46 16x16 的矩阵存 256 位</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100449795.png"><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100515128.png" alt></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100433081.png" alt="image-20191209100433081"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209100830634.png" alt="image-20191209100830634"></p><p>数据选择器/多路复用器 (Multiplexer) 解码 8 位地址，定位到单个锁存器</p><p>07:38 4 位代表行， 4 位代表列</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101103207.png" alt="image-20191209101103207"></p><p>08:16 组合 256 位内存 + 多路复用器<br>09:01 可寻址的 256 字节 内存</p><p>向上抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101217062.png" alt="image-20191209101217062"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101313055.png" alt="image-20191209101313055"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101340409.png" alt="image-20191209101340409"></p><p>再次抽象</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101509140.png" alt="image-20191209101509140"><br><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209101548861.png" alt="image-20191209101548861"></p><p>一条1980年代的内存，1M 大小</p><p>10:14 8个模块，每个模块有32个小方块，<br>每个小方块有 4 个小块，每个小块是 128 位 x 64 位</p><h2 id="第-7-集：中央处理器（CPU"><a href="#第-7-集：中央处理器（CPU" class="headerlink" title="第 7 集：中央处理器（CPU)"></a>第 7 集：中央处理器（CPU)</h2><p>重点</p><ol><li>拼个 CPU 出来</li><li>CPU 怎么执行命令</li></ol><p>01:00 RAM + 寄存器 + ALU 做个 CPU</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209214658376.png" alt="image-20191209214658376"></p><p>04:00 解释 “取指令→解释→执行” 这个循环</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209214742706.png" alt="image-20191209214742706"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215049890.png" alt="image-20191209215049890"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215257090.png" alt="image-20191209215257090"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215331027.png" alt="image-20191209215331027"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215530912.png" alt="image-20191209215530912"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215620939.png" alt="image-20191209215620939"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215726423.png" alt="image-20191209215726423"></p><p>上述就完成了将RAM中的值14存入寄存器A中</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209215924813.png" alt="image-20191209215924813"></p><p>开始执行下一条指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220015449.png" alt="image-20191209220015449"></p><p>向上抽象后，完成下一条指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220218556.png" alt="image-20191209220218556"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220434146.png" alt="image-20191209220434146"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220528278.png" alt="image-20191209220528278"></p><p>整个过程是从内存中加载两个数据，相加后，结果再存到内存中</p><p>08:00 时钟是什么, 时钟速度和赫兹</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220743313.png" alt="image-20191209220743313"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209220822119.png" alt="image-20191209220822119"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209221031800.png" alt="image-20191209221031800"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209221118156.png" alt="image-20191209221118156"></p><p>10:00 超频提升性能, 降频省电</p><h2 id="第-8-集：指令和程序"><a href="#第-8-集：指令和程序" class="headerlink" title="第 8 集：指令和程序"></a>第 8 集：指令和程序</h2><p>本集重点：一步步带你运行一遍程序</p><p>00:45 回顾上集的例子程序，一步步讲解。介绍”指令集”的概念<br>LOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令<br>05:16 带条件跳转，JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP<br>08:00 真正现代 CPU 用更多指令集。位数更长。<br>09:07 1971年的英特尔 4004 处理器，有 46 个指令</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191209222131963.png" alt="image-20191209222131963"></p><p>09:36 如今英特尔酷睿 i7, 有上千条指令</p><h2 id="第-9-集：高级-CPU-设计"><a href="#第-9-集：高级-CPU-设计" class="headerlink" title="第 9 集：高级 CPU 设计"></a>第 9 集：高级 CPU 设计</h2><p>00:24 早期是加快晶体管切换速度，来提升 CPU 速度<br>01:20 给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码<br>02:28 给 CPU 加缓存，提高数据存取速度，更快喂给 CPU，用计算餐馆销售额举例<br>05:13 脏位 - Dirty bit</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095155264.png" alt="image-20191210095155264"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095216725.png" alt="image-20191210095216725"></p><p>05:33 流水线设计，用 1 个洗衣机和 1 个干燥机举例</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095351622.png" alt="image-20191210095351622"></p><p>06:01 并行处理 - parallelize</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095507564.png" alt="image-20191210095507564"></p><p>07:33 乱序执行 - out-of-order execution<br>08:21 推测执行 - speculative execution<br>08:50 分支预测 - branch prediction<br>09:34 多个 ALU</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095800619.png" alt="image-20191210095800619"></p><p>09:54 多核 (Core)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095840819.png" alt="image-20191210095840819"></p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210095908362.png" alt="image-20191210095908362"></p><p>10:11 多个独立 CPU<br>10:52 超级计算机，中国的”神威 太湖之光”</p><h2 id="第-10-集：早期的编程方式"><a href="#第-10-集：早期的编程方式" class="headerlink" title="第 10 集：早期的编程方式"></a>第 10 集：早期的编程方式</h2><p>本集重点：早期计算机如何编程<br>打孔纸卡 → 插线板 → 面板拨开关</p><p>00:00 开头说本集重点：程序如何进入计算机<br>00:53 拿纺织业举例，给机器编程的需求远在计算机出现前就有了<br>01:41 打孔纸卡 - Punched card<br>02:36 插线板 - Plugboard<br>04:20 冯诺依曼架构 - Von Neumann Architecture<br>07:00 面板编程 - Panel programming<br>07:29 第一款取得商业成功的家用计算机: Altair 8800<br>08:15 编程依然很困难，人们需要更友好更简单的方式编程<br>08:44 下周主题：编程语言</p><h2 id="第-11-集：编程语言发展史"><a href="#第-11-集：编程语言发展史" class="headerlink" title="第 11 集：编程语言发展史"></a>第 11 集：编程语言发展史</h2><p>编程：二进制 → 助记符（汇编器）→ A-0（编译器）→ FORTRAIN</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210101157518.png" alt="image-20191210101157518"></p><p>01:45 二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了<br>02:28 用 “助记符” 写代码（LOAD_A 14）为了把助记符转二进制，汇编器诞生 (Assembler)</p><p><img src="/2019/12/09/Crash-Course-Computer-Science/image-20191210101410840.png" alt="image-20191210101410840"></p><p>04:32 葛丽丝·霍普 (Grace Hopper) - 哈佛1号计算机首批程序员, 海军军官<br>05:13 Grace 设计了编程语言 A-0<br>05:29 Grace 1952 年做了第一个编译器 (Compiler)，实现 A-0<br>06:29 变量 (Variables)<br>07:01 FORTRAN<br>08:18 COBOL<br>09:25 新语言<br>1960 年代：ALGOL，LISP，BASIC<br>1970 年代：Pascal，C，Smalltalk<br>1980 年代：C++，Objective-C，Perl<br>1990 年代：Python，Ruby，Java</p><h2 id="第-12-集：编程基础-语句和函数"><a href="#第-12-集：编程基础-语句和函数" class="headerlink" title="第 12 集：编程基础 - 语句和函数"></a>第 12 集：编程基础 - 语句和函数</h2><p>00:50 变量, 赋值语句<br>02:08 Grace Hopper 拍虫子游戏<br>02:52 if 判断<br>04:19 while 循环<br>05:48 for 循环<br>07:00 函数<br>11:11 下集介绍算法</p><h2 id="第-13-集：算法入门"><a href="#第-13-集：算法入门" class="headerlink" title="第 13 集：算法入门"></a>第 13 集：算法入门</h2><p>03:00 选择排序 - Selection sort<br>03:52 大 O 表示法 - Big O notation<br>04:31 归并排序 - Merge sort（N*logN）<br>08:03 Dijkstra 算法</p><ul><li><input disabled type="checkbox"> 后续课程待定，有空时候再去听吧。</li></ul><h2 id="第-14-集：数据结构"><a href="#第-14-集：数据结构" class="headerlink" title="第 14 集：数据结构"></a>第 14 集：数据结构</h2><p>00:39 数组 - Array<br>02:06 字符串 - String<br>03:12 矩阵 - Matrix<br>04:05 结构体 - Struct<br>04:46 指针 - Pointer<br>04:44 节点 - Node<br>04:53 链表 - Linked List<br>06:21 队列 - Queue<br>06:21 栈 - Stack<br>07:31 树 - Tree<br>08:01 二叉树 - Binary Tree<br>08:26 图 - Graph<br>08:50 没时间讲红黑树和堆, 不同数据结构适用不同场景</p><h2 id="第-15-集：阿兰·图灵"><a href="#第-15-集：阿兰·图灵" class="headerlink" title="第 15 集：阿兰·图灵"></a>第 15 集：阿兰·图灵</h2><p>00:33 介绍图灵<br>00:52 可判定性问题<br>01:14 阿隆佐·丘奇，Lambda 算子<br>01:38 图灵机<br>04:54 停机问题<br>08:09 破解德军英格玛加密机<br>10:40 图灵测试<br>11:18 图灵的个人生活<br>12:07 图灵奖</p><h2 id="第-16-集：软件工程"><a href="#第-16-集：软件工程" class="headerlink" title="第 16 集：软件工程"></a>第 16 集：软件工程</h2><p>01:31 对象 Object<br>02:39 面向对象编程 Object Oriented Programming.<br>03:55 API Application Programming Interface<br>04:33 public, private<br>05:36 集成开发环境, IDE - Integrated Development Environments<br>06:09 调试 debugging<br>06:31 文档和注释 - readme, comment<br>07:33 版本控制 Version control<br>08:50 质量控制 Quality Assurance testing，QA<br>09:21 Beta, Alpha</p><h2 id="第-17-集：集成电路与摩尔定律"><a href="#第-17-集：集成电路与摩尔定律" class="headerlink" title="第 17 集：集成电路与摩尔定律"></a>第 17 集：集成电路与摩尔定律</h2><p>本集重点：晶圆的制作流程：光刻 (04:21~07:42)</p><p>00:51 分立元件 Discrete components<br>01:09 数字暴政 Tyranny of Numbers - 是 1960 年代工程师碰到的问题<br>意思是如果想加强电脑性能，就要更多部件，这导致更多线路，更复杂。所以很难做<br>04:21 光刻 Photolithography<br>04:26 晶圆 Wafer<br>04:57 光刻胶 Photoresist<br>05:08 光掩膜 Photomask<br>06:00 掺杂 Doping<br>09:09 摩尔定律 Moore’s Law.<br>09:38 英特尔 Intel<br>10:20 晶体管数量大幅度增长, 1980年三万个，1990年一百万个，2000年三千万个，2010年十亿个<br>11:44 进一步小型化会碰到 2 个问题 1. 光的波长不足以制作更精细的设计 2. 量子隧穿效应</p><h2 id="第-18-集：操作系统"><a href="#第-18-集：操作系统" class="headerlink" title="第 18 集：操作系统"></a>第 18 集：操作系统</h2><p>00:48 操作系统 Operating systems<br>01:34 批处理 Batch processing<br>01:58 计算机变便宜变多，有不同配置，写程序处理不同硬件细节很痛苦，因此操作系统负责抽象硬件<br>02:12 外部设备 Peripherals<br>02:48 设备驱动程序 Device drivers<br>04:43 多任务处理 Multitasking<br>05:54 虚拟内存 Virtual Memory<br>07:09 动态内存分配 Dynamic memory allocation<br>07:31 内存保护 Memory Protection<br>07:54 1970年代，计算机足够便宜，大学买了让学生用，多个学生用多个 “终端” 连接到主机<br>08:29 多用户分时操作系统，Multics<br>09:32 Unix<br>11:02 MS-DOS<br>12:09 下集是内存&amp;存储介质</p><h2 id="第-19-集：内存-amp-储存介质"><a href="#第-19-集：内存-amp-储存介质" class="headerlink" title="第 19 集：内存&amp;储存介质"></a>第 19 集：内存&amp;储存介质</h2><p>本集重点：存储技术的发展</p><p>01:01 纸卡 Paper punch cards<br>02:01 延迟线存储器 Delay Line Memory<br>04:06 磁芯 Magnetic Core Memory<br>06:08 磁带 Magnetic Tape<br>07:08 磁鼓 Magnetic Drum Memory<br>07:43 硬盘 Hard Disk Drives<br>08:53 内存层次结构 Memory Hierarchy<br>09:36 软盘 Floppy Disk<br>10:09 光盘 Compact Disk<br>10:51 固态硬盘 Solid State Drives</p><h2 id="第-20-集：文件系统"><a href="#第-20-集：文件系统" class="headerlink" title="第 20 集：文件系统"></a>第 20 集：文件系统</h2><p>00:47 文件格式：可以随便存文件数据，但按格式存会更方便<br>01:00 TXT 文本文件：ASCII<br>01:31 WAV 音频文件：每秒上千次的音频采样数字<br>02:47 BMP 图片文件：像素的红绿蓝 RGB 值<br>04:43 文件系统：很早期时空间小，整个存储器就像一整个文件。后来随容量增长，多文件非常必要<br>05:37 目录文件：用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等</p><p>06:39 平面文件系统 - Flat File System：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用</p><p>06:57 如果文件紧密的一个个前后排序会造成问题，所以文件系统会： 1. 把空间划分成一块块 2. 文件拆分存在多个块里</p><p>08:30 文件的增删改查会不可避免的造成文件散落在各个块里，<br>如果是磁带这样的存储介质就会造成问题，所以做碎片整理</p><p>09:46 分层文件系统 - Hierarchical File System：有不同文件夹，文件夹可以层层嵌套</p><p>第21集讲压缩</p><h2 id="第-21-集：压缩"><a href="#第-21-集：压缩" class="headerlink" title="第 21 集：压缩"></a>第 21 集：压缩</h2><p>00:26 压缩的好处是能存更多文件，传输也更快<br>01:52 游程编码 Run-Length Encoding<br>02:45 无损压缩 Lossless compression<br>03:55 霍夫曼树 Huffman Tree<br>05:56 “消除冗余”和”用更紧凑的表示方法”，这两种方法通常会组合使用<br>06:07 字典编码 Dictionary coders, 游程编码 和 字典编码 都是无损压缩<br>08:03 感知编码 Perceptual coding<br>08:09 有损压缩 jpeg 格式<br>09:39 时间冗余 Temporal redundancy<br>10:30 MPEG-4 视频编码</p><h2 id="第-22-集：命令行界面"><a href="#第-22-集：命令行界面" class="headerlink" title="第 22 集：命令行界面"></a>第 22 集：命令行界面</h2><p>本集重点：计算机早期同时输入程序和数据（用纸卡/纸带）<br>运行开始直到结束，中间没有人类进行操作，<br>原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上 (02:34)</p><p>到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行<br>为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机 (02:44~05:38)</p><p>到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配 (07:24)</p><p>00:32 人机交互 Human-Computer Interaction<br>00:50 早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去<br>03:00 QWERTY 打字机的发展，克里斯托弗·莱瑟姆·肖尔斯 发明于 1868 年<br>05:38 电传打字机 Teletype machine<br>06:32 命令行界面 Command line interface<br>06:38 ls 命令<br>08:22 早期文字游戏 Zork (1977年)<br>08:47 cd 命令</p><h2 id="第-23-集：屏幕与-2D-图形显示"><a href="#第-23-集：屏幕与-2D-图形显示" class="headerlink" title="第 23 集：屏幕与 2D 图形显示"></a>第 23 集：屏幕与 2D 图形显示</h2><p>00:05 PDP-1 计算机。键盘和显示器分开，屏幕显示临时值<br>01:14 阴极射线管 Cathode Ray Tube (CRT)<br>01:38 CRT 有两种绘图方式：<br>矢量扫描 Vector Scanning<br>光栅扫描 Raster Scanning</p><p>02:14 液晶显示器 Liquid Crystal Displays (LCD)，像素 (Pixel)<br>03:32 字符生成器 Character generator<br>03:45 屏幕缓冲区 Screen buffer<br>05:09 矢量命令画图<br>06:34 Sketchpad, 光笔 (Light pen)<br>09:00 函数画线，矩形</p><h2 id="第-24-集：冷战和消费主义"><a href="#第-24-集：冷战和消费主义" class="headerlink" title="第 24 集：冷战和消费主义"></a>第 24 集：冷战和消费主义</h2><p>本集重点：冷战导致美国往计算机领域投入大量资源 (00:00~01:43)</p><p>范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex<br>帮助建立 国家科学基金会，给科学研究提供资金 (01:43~03:43)</p><p>1950 年代消费者开始买晶体管设备，收音机大卖<br>日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子 (03:43~04:29）</p><p>苏联 1961 年把宇航员加加林送上太空，导致美国提出登月<br>NASA 预算大大增加，用集成电路来制作登月计算机 (04:29~06:27)</p><p>集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次<br>美国造超级计算机进一步推进集成电路 (04:29~07:11)</p><p>美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败<br>很多公司倒闭，英特尔转型处理器 (07:11~08:23)</p><p>末尾总结：政府和消费者推动了计算机的发展<br>早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展 (08:23~10:41)</p><h2 id="第-25-集：个人计算机革命"><a href="#第-25-集：个人计算机革命" class="headerlink" title="第 25 集：个人计算机革命"></a>第 25 集：个人计算机革命</h2><p>本集：全是历史故事<br>00:18 1970年代初成本下降，个人计算机变得可行<br>01:51 Altair 8800<br>02:32 比尔·盖茨 和 保罗·艾伦写 BASIC 解释器<br>03:45 乔布斯提议卖组装好的计算机，Apple-I 诞生<br>04:40 1977年出现3款开箱即用计算机：<br>“Apple-II”，”TRS-80 Model I”，”Commodore PET 2001”</p><p>06:26 IBM 意识到个人计算机市场<br>IBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容)<br>生态系统产生雪球效应：<br>因为用户多，软硬件开发人员更愿意花精力在这个平台<br>因为软硬件多，用户也更乐意买 “IBM 兼容” 的计算机</p><p>08:44 苹果选封闭架构，一切都自己来，只有苹果在非 “IBM 兼容” 下保持了足够市场份额</p><h2 id="第-26-集：图形用户界面-GUI"><a href="#第-26-集：图形用户界面-GUI" class="headerlink" title="第 26 集：图形用户界面 (GUI)"></a>第 26 集：图形用户界面 (GUI)</h2><p>01:10 图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）<br>03:20 1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）<br>03:29 1973年完成 Xerox Alto(施乐奥托) 计算机<br>04:42 举例：写一个简单的 GUI 程序<br>06:38 1981年的 Xerox Star system(施乐之星系统)<br>08:18 史蒂夫·乔布斯去施乐参观<br>07:45 所见即所得 WYSIWYG<br>09:15 1983年推出 Apple Lisa<br>09:31 1984年推出 Macintosh<br>10:12 1985年推出 Windows 1.0，之后出到 3.1<br>10:43 1995年推出 Windows 95 提供图形界面<br>11:08 1995年微软做失败的 Microsoft Bob</p><h2 id="第-27-集：3D-图形"><a href="#第-27-集：3D-图形" class="headerlink" title="第 27 集：3D 图形"></a>第 27 集：3D 图形</h2><p>01:15 线框渲染 Wireframe Rendering<br>01:39 正交投影 Orthographic Projection<br>01:50 透视投射 Perspective Projection<br>02:14 网格 Mesh<br>02:37 三角形更常用因为能定义唯一的平面<br>03:09 扫描线渲染 Scanline Rendering<br>05:04 遮挡 Occlusion<br>05:19 画家算法 Painter’s Algorithm<br>06:09 深度缓冲 Z Buffering<br>07:45 Z Fighting 错误<br>07:51 背面剔除 Back Face Culling<br>08:53 表面法线 Surface Normal<br>09:33 平面着色 Flat Shading<br>09:43 高洛德着色 Gouraud shading, 冯氏着色 Phong Shading<br>10:06 纹理映射 Texture Mapping<br>11:24 图形处理单元 GPU, Graphics Processing Unit</p><h2 id="第-28-集：计算机网络"><a href="#第-28-集：计算机网络" class="headerlink" title="第 28 集：计算机网络"></a>第 28 集：计算机网络</h2><p>02:05 局域网 Local Area Networks - LAN<br>02:36 媒体访问控制地址 Media Access Control address - MAC<br>02:55 载波侦听多路访问 Carrier Sense Multiple Access - CSMA<br>05:18 指数退避 Exponential Backoff<br>05:36 冲突域 Collision Domain<br>07:08 电路交换 Circuit Switching<br>07:36 报文交换 Message Switching<br>10:20 分组交换 Packet Switching</p><h2 id="第-29-集：互联网"><a href="#第-29-集：互联网" class="headerlink" title="第 29 集：互联网"></a>第 29 集：互联网</h2><p>02:23 IP - 互联网协议 - Internet Protocol<br>03:00 UDP - 用户数据报协议 - User Datagram Protocol<br>03:41 校验和 - Checksum<br>05:26 TCP - 传输控制协议 - Transmission Control Protocol<br>08:21 DNS - 域名系统 - Domain Name System<br>10:47 OSI - 开放式系统互联通信参考模型 - Open System Interconnection</p><h2 id="第-30-集：万维网"><a href="#第-30-集：万维网" class="headerlink" title="第 30 集：万维网"></a>第 30 集：万维网</h2><p>01:01 超链接 Hyperlinks<br>02:20 URL - 统一资源定位器 - Uniform Resource Locator<br>03:01 HTTP - 超文本传输协议 - HyperText Transfer Protocol<br>04:13 HTML - 超文本标记语言 - HyperText Markup Language<br>04:24 写一个简单网页，用到了 </p><h1> <a> <h2> <ol> <li> 标签<br>06:04 第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的<br>06:32 1991年正式发布，万维网就此诞生<br>07:19 开始讲搜索引擎的故事<br>07:40 Jerry 和 David 的万维网指南 后来改名成 Yahoo<br>07:52 搜索引擎 JumpStation<br>09:07 搜索引擎 Google<br>09:20 网络中立性<p></p><h2 id="第-31-集：计算机安全"><a href="#第-31-集：计算机安全" class="headerlink" title="第 31 集：计算机安全"></a>第 31 集：计算机安全</h2><p>01:00 Secrecy, Integrity, Availability<br>保密性, 完整性, 可用性<br>01:49 Threat Model 威胁模型</p><p>03:14 身份验证 (Authentication) 的三种方式：<br>What you know, 你知道什么<br>What you have, 你有什么<br>What you are, 你是什么</p><p>07:34 访问控制 Access Control<br>08:48 Bell LaPadula model 不能向上读取，不能向下写入<br>11:00 隔离 Isolation, 沙盒 Sandbox</p><h2 id="第-32-集：黑客与攻击"><a href="#第-32-集：黑客与攻击" class="headerlink" title="第 32 集：黑客与攻击"></a>第 32 集：黑客与攻击</h2><p>01:28 社会工程学 Social Engineering<br>01:38 钓鱼 Phishing<br>02:06 假托 Pretexting<br>02:50 木马 Trojan Horses<br>03:32 NAND镜像 NAND Mirroring<br>04:12 漏洞利用 Exploit<br>04:16 缓冲区溢出 Buffer Overflow<br>05:45 边界检查 Bounds Checking<br>06:16 代码注入 Code Injection<br>09:32 零日漏洞 Zero Day Vulnerability<br>09:53 计算机蠕虫 Worms<br>09:58 僵尸网络 Botnet<br>10:11 拒绝服务攻击 DDoS</p><h2 id="第-33-集：加密"><a href="#第-33-集：加密" class="headerlink" title="第 33 集：加密"></a>第 33 集：加密</h2><p>00:16 多层防御 Defence in depth<br>01:00 加密 - Encryption，解密 - Decryption<br>01:11 凯撒加密 Caesar cipher<br>01:27 替换加密 Substitution cipher<br>01:59 移位加密 Permutation cipher<br>02:03 列移位加密 Columnar transposition cipher<br>02:37 德国 Enigma 加密机<br>04:54 1977年”数据加密标准” - Data Encryption Standard (DES)<br>05:24 2001年”高级加密标准” - Advanced Encryption Standard (AES)<br>07:06 密钥交换 - Key exchange<br>07:33 用颜色来举例”单向函数”和”密钥加密”的原理<br>08:24 迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange<br>10:18 非对称加密 - Asymmetric encryption<br>11:22 非对称加密算法 RSA</p><h2 id="第-34-集：机器学习与人工智能"><a href="#第-34-集：机器学习与人工智能" class="headerlink" title="第 34 集：机器学习与人工智能"></a>第 34 集：机器学习与人工智能</h2><p>01:23 分类 Classification<br>01:25 分类器 Classifier<br>01:34 特征 Feature<br>02:03 标记数据 Labeled data<br>02:38 决策边界 Decision boundaries<br>03:00 混淆矩阵 Confusion matrix<br>03:39 未标签数据 Unlabeled data<br>03:49 决策树 Decision tree<br>04:25 支持向量机 Support Vector Machines<br>05:52 人工神经网络 Artificial Neural Network<br>08:34 深度学习 Deep learning<br>09:21 弱AI, 窄AI Weak AI, Narrow AI<br>09:43 强AI Strong AI<br>10:42 强化学习 Reinforcement Learning</p><h2 id="第-35-集：计算机视觉"><a href="#第-35-集：计算机视觉" class="headerlink" title="第 35 集：计算机视觉"></a>第 35 集：计算机视觉</h2><p>02:41 检测垂直边缘的算法<br>03:26 核/过滤器 kernel or filter<br>03:56 卷积 convolution<br>04:23 Prewitt 算子 Prewitt Operators<br>05:34 维奥拉·琼斯 人脸检测 Viola-Jones Face Detection<br>05:35 卷积神经网络 Convolutional Neural Networks<br>07:33 识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息<br>08:52 跟踪全身的标记点，如肩部，手臂等</p><h2 id="第-36-集：自然语言处理"><a href="#第-36-集：自然语言处理" class="headerlink" title="第 36 集：自然语言处理"></a>第 36 集：自然语言处理</h2><p>01:50 词性 Parts of speech<br>02:15 短语结构规则 Phrase structure rules<br>02:32 分析树 Parse tree<br>05:30 语音识别 Speech recognition<br>07:26 谱图 Spectrogram<br>07:44 快速傅立叶变换 Fast Fourier Transform<br>08:42 音素 Phonemes<br>09:29 语音合成 Speech Synthesis</p><h2 id="第-37-集：机器人"><a href="#第-37-集：机器人" class="headerlink" title="第 37 集：机器人"></a>第 37 集：机器人</h2><p>02:08 法国吃饭鸭 - Digesting Duck, Canard Digerateur<br>02:23 土耳其行棋傀儡, 下国际象棋<br>02:43 第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)<br>03:32 1960年 Unimate，第一个商业贩卖的 可编程工业机器人<br>03:47 简单控制回路 simple control loop<br>04:08 负反馈回路 negative feedback loop<br>05:17 比例-积分-微分控制器 Proportional–Integral–Derivative controller PID 控制器<br>10:48 机器人三定律 Three Laws of Robotics</p><h2 id="第-38-集：计算机心理学"><a href="#第-38-集：计算机心理学" class="headerlink" title="第 38 集：计算机心理学"></a>第 38 集：计算机心理学</h2><p>00:45 我们需要了解人类心理学，做出更好的计算机<br>01:12 易用度 - Usability<br>01:31 颜色强度排序 和 颜色排序<br>02:30 分组更好记，电话号码 317-555-3897 比 3175553897 好记<br>03:25 直观功能 - Affordances<br>04:33 认出 vs 回想 Recognition vs Recall<br>05:45 让机器有一定情商以及 Facebook 的研究<br>08:40 用软件修正注视位置。让视频通话时看起来像盯着对方，而不是盯着下方<br>09:58 把机器人做的像人，恐怖谷理论<br>11:35 有很多开放式的问题，心理学帮助我们明白不同选择可能带来的影响</p><h2 id="第-39-集：教育科技"><a href="#第-39-集：教育科技" class="headerlink" title="第 39 集：教育科技"></a>第 39 集：教育科技</h2><p>02:15 通过调速，暂停等技巧，加强学习效率<br>03:15 大型开放式在线课程 - Massive Open Online Courses (MOOC)<br>05:08 智能辅导系统 - Intelligent Tutoring Systems<br>05:22 判断规则 - Production rule<br>06:10 域模型 - Domain Model<br>06:46 贝叶斯知识追踪 Bayesian knowledge tracing</p><ol><li>学生已经学会的概率</li><li>瞎猜的概率</li><li>失误的概率</li><li>做题过程中学会的概率<br>09:27 教育数据挖掘 Educational Data Mining</li></ol><h2 id="（完结）第-40-集：奇点，天网，计算机的未来"><a href="#（完结）第-40-集：奇点，天网，计算机的未来" class="headerlink" title="（完结）第 40 集：奇点，天网，计算机的未来"></a>（完结）第 40 集：奇点，天网，计算机的未来</h2><p>01:21 普适计算 Ubiquitous Computing<br>04:55 奇点 Singularity<br>06:51 把工作分为4个象限，讨论自动化带来的影响<br>10:15 机器人的存在时间可能长过人类，可以长时间探索宇宙</p></li></ol></h2></a></h1>]]></content>
      
      
      <categories>
          
          <category> Online Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-NOTES</title>
      <link href="/2019/12/02/JAVA-NOTES/"/>
      <url>/2019/12/02/JAVA-NOTES/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p> Java学习基础知识</p></blockquote><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><strong>初始化一般遵循3个原则：</strong></p><ul><li>静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；</li><li>父类优先于子类进行初始化；</li><li>按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；</li></ul><p><strong>加载顺序</strong></p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.父类静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.父类非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.父类构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base constructor!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.子类静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.子类非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.子类构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived constructor!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base <span class="keyword">static</span> block!</span><br><span class="line">Derived <span class="keyword">static</span> block!</span><br><span class="line">Base block</span><br><span class="line">Base constructor!</span><br><span class="line">Derived block!</span><br><span class="line">Derived constructor!</span><br></pre></td></tr></table></figure><h2 id="深-浅拷贝"><a href="#深-浅拷贝" class="headerlink" title="深/浅拷贝"></a>深/浅拷贝</h2><ul><li><p>当拷贝一个变量时，原始引用和拷贝的引用指向同一个对象，改变一个引用所指向的对象会对另一个引用产生影响。</p></li><li><p><strong>浅拷贝</strong>：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象。</p></li></ul><p><img src="/2019/12/02/JAVA-NOTES/shadow_copy2.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Company) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用super（即Object）的clone方法只能进行浅拷贝。</p></li><li><p><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，<strong>创建一个新的对象</strong>，并复制其内容，此为深拷贝。</p></li></ul><p><img src="/2019/12/02/JAVA-NOTES/deep_copy2.jpg" alt="img"></p><ul><li>如果希望实现深拷贝，需要修改实现，比如修改为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 如果Company中还有持有其他对象的引用，那么Company中也要像Person这样做。</span></span><br><span class="line">        <span class="comment">// 可以说：想要深拷贝一个子类，那么它的所有父类都必须可以实现深拷贝。</span></span><br><span class="line">        person.setCompany(company.clone()); <span class="comment">// 一个新的Company</span></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一种实现对象深拷贝的方式是序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        os.writeObject(<span class="keyword">this</span>); </span><br><span class="line">        os.close(); </span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bais); </span><br><span class="line">        Object ret = in.readObject(); </span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-amp-C"><a href="#Java-amp-C" class="headerlink" title="Java&amp;C++"></a>Java&amp;C++</h2><ul><li>Java 是<strong>纯粹的面向对象语言</strong>，所有的对象都继承自 java.lang.Object，<strong>C++ 为了兼容 C 即支持面向对象也支持面向过程</strong>。</li><li>Java 通过虚拟机从而实现<strong>跨平台特性</strong>，但是 C++ 依赖于<strong>特定的平台</strong>。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持<strong>自动垃圾回收</strong>，而 C++ 需要<strong>手动回收</strong>。（C++11 中引入智能指针，使用引用计数法垃圾回收）</li><li><strong>Java 不支持多重继承</strong>，只能通过实现多个接口来达到相同目的，而 <strong>C++ 支持多重继承</strong>。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 内置了线程的支持，而 C++ 需要依靠第三方库。</li><li>Java 的 <strong>goto 是保留字</strong>，但是不可用，C++ 可以使用 goto。</li><li>Java <strong>不支持条件编译</strong>，C++ 通过 #ifdef #ifndef 等预处理命令从而实现<strong>条件编译</strong>。</li></ul><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，<ul><li>== 判断两个值是否相等，如：int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。</li><li>基本类型没有 equals() 方法。</li></ul></li><li>对于引用类型，<ul><li>== 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来<strong>判断两个对象的地址是否相同</strong>，即是否是指相同一个对象。</li><li>equals() 它的作用也是<strong>判断两个对象是否相等。</strong>但它一般有两种使用情况：<ul><li>情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过 == 比较这两个对象。</li><li>情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。用来<strong>判断两个对象的内容是否相等</strong>。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>2. 等价关系</strong></p><p>（一）自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（二）对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（三）传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（四）一致性</p><p>多次调用 equals() 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（五）与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比String里面的equals实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hasCode() 返回一个对象的散列值，而 equals() 是用来判断两个实例是否等价。<strong>等价的两个实例散列值一定相同，但是散列值相同的两个实例不一定等价。</strong></p><p>在覆盖 equals() 方法时必须覆盖 hashCode() 方法，保证等价的两个实例散列值也相等。</p><p>下面的代码中，新建了两个等价的实例，并将它们添加到 HashSet 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2:不是我们想要的结果</span></span><br></pre></td></tr></table></figure><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为<strong>散列码的无符号十六进制</strong>表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ToStringExample</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToStringExample example = <span class="keyword">new</span> ToStringExample(<span class="number">123</span>);</span><br><span class="line">System.out.println(example.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToStringExample@4554617c</span></span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p><strong>1. cloneable</strong></p><p>clone() 是 Object 的 protect 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); </span></span><br><span class="line"><span class="comment">// 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>重写 clone() 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.CloneNotSupportedException: CloneTest</span></span><br></pre></td></tr></table></figure><p>以上抛出了 CloneNotSupportedException，这是因为 CloneTest 没有实现 Cloneable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="高分知乎回答"><a href="#高分知乎回答" class="headerlink" title="高分知乎回答"></a>高分知乎回答</h3><p>　　首先看一个在知乎上的优秀回答吧：</p><p>反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到 JVM，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。</p><p>举个例子我们的项目底层有时是用 mysql，有时用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 <code>com.java.dbtest.myqlConnection</code>，<code>com.java.dbtest.oracleConnection</code> 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 <code>Class tc = Class.forName(“com.java.dbtest.***Connection”);</code> 通过类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle 则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出 Java 的特性了！</p><p>Spring中会发现当你配置各种各样的 bean 时，是以配置文件的形式配置的，你需要用到哪些 bean 就配哪些，spring 容器就会根据你的需求去动态加载，你的程序就能健壮地运行。</p><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection）</p><p>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。</p><p>程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射框架主要提供以下功能：</p><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法）</li><li>在运行时构造任意一个类的对象</li><li>在运行时调用任意一个对象的方法</li></ol><p><strong>重点</strong>：是运行时而不是编译时；（两判断一构造一调用）</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><p>当我们在使用 IDE （如Eclipse，IDEA）时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p><p><strong>反射最重要的用途就是开发各种通用框架</strong></p><p>很多框架（比如 Spring ）都是配置化的（比如通过 XML 文件配置 JavaBean,Action 之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><ol><li>调用运行时类本身的 <code>.class</code> 属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(clazz1.getName());</span><br></pre></td></tr></table></figure><ol start="2"><li>通过运行时类的对象获取 <code>getClass();</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz3 = p.getClass();</span><br><span class="line">System.out.println(clazz3.getName());</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Class 类的 <code>forName</code> 静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line"><span class="comment">// 在JDBC开发中常用此方法加载数据库驱动:</span></span><br><span class="line">Class.forName(driver);</span><br></pre></td></tr></table></figure><ol start="4"><li>（了解）通过类的加载器 ClassLoader</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz5 = classLoader.loadClass(className);</span><br><span class="line">System.out.println(clazz5.getName());</span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>Annontation 是 Java5 开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来<strong>将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</strong>。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation 像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <code>java.lang.annotation</code> 包中。</p><p>简单来说：注解其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。</p><h3 id="为什么要用注解"><a href="#为什么要用注解" class="headerlink" title="为什么要用注解"></a>为什么要用注解</h3><p>传统的方式，我们是通过配置文件 <code>.xml</code> 来告诉类是如何运行的。</p><p>有了注解技术以后，我们就可以通过注解告诉类如何运行</p><p>例如：我们以前编写 Servlet 的时候，需要在 web.xml 文件配置具体的信息。我们使用了注解以后，可以直接在 Servlet 源代码上，增加注解后 Servlet 就被配置到 Tomcat 上了。也就是说，注解可以给类、方法上注入信息。</p><p>明显地可以看出，这样是非常直观的，并且 Servlet 规范是推崇这种配置方式的。</p><h3 id="基本Annotation"><a href="#基本Annotation" class="headerlink" title="基本Annotation"></a>基本Annotation</h3><p>在 java.lang 包下存在着5个基本的 Annotation，重点掌握前三个。</p><ol><li>@Override 重写注解</li><li>@Deprecated 过时注解<ul><li>该注解也非常常见，Java 在设计的时候，可能觉得某些方法设计得不好，为了兼容以前的程序，是不能直接把它抛弃的，于是就设置它为过时。</li><li>Date对象中的 toLocalString() 就被设置成过时了</li><li>当我们在程序中调用它的时候，在 IDE 上会出现一条横杠，说明该方法是过时的。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLocaleString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DateFormat formatter = DateFormat.getDateTimeInstance();</span><br><span class="line">    <span class="keyword">return</span> formatter.format(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@SuppressWarnings 抑制编译器警告注解</li><li>@SafeVarargs Java 7“堆污染”警告<ul><li>什么是堆污染呢？？当把一个不是泛型的集合赋值给一个带泛型的集合的时候，这种情况就很容易发生堆污染。</li><li>这个注解也是用来抑制编译器警告的注解，用的地方并不多。</li></ul></li><li>@FunctionalInterface 用来指定该接口是函数式接口<ul><li>用该注解显式指定该接口是一个函数式接口。</li></ul></li></ol><h3 id="自定义注解类编写规则"><a href="#自定义注解类编写规则" class="headerlink" title="自定义注解类编写规则"></a>自定义注解类编写规则</h3><ol><li>Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation 这一接口，并且不能再去继承别的类或是接口.</li><li>参数成员只能用 public 或默认(default)这两个访问权修饰</li><li>参数成员只能用基本类型 byte,short,char,int,long,float,double,boolean 八种基本数据类型和 String、Enum、Class、annotations 等数据类型，以及这一些类型的数组</li><li>要获取类方法和字段的注解信息，必须通过 Java 的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员, 不过这样注解就没啥用了 PS：自定义注解需要使用到元注解</li></ol><h3 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h3><p><strong>@Target({METHOD,TYPE})</strong> 表示这个注解可以用用在类/接口上，还可以用在方法上<br><strong>@Retention(RetentionPolicy.RUNTIME)</strong> 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如<code>@Override</code>那种不用运行，在编译时idea就可以进行相关工作的编译时注解。<br><strong>@Inherited</strong> 表示这个注解可以被子类继承<br><strong>@Documented</strong> 表示当执行javadoc的时候，本注解会生成相关文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.FIELD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果名称注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>通俗的讲，泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。</p><p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 <strong>Java 泛型</strong>。</p><p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>　　你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><p>下面是定义泛型方法的规则：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数 <strong>只能代表引用型类型，不能是原始类型</strong> （像 int,double,char 的等）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 泛型方法 printArray                         </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'O'</span> &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"整型数组元素为:"</span> );</span><br><span class="line">        printArray( intArray  ); <span class="comment">// 传递一个整型数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"\n双精度型数组元素为:"</span> );</span><br><span class="line">        printArray( doubleArray ); <span class="comment">// 传递一个双精度型数组</span></span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"\n字符型数组元素为:"</span> );</span><br><span class="line">        printArray( charArray ); <span class="comment">// 传递一个字符型数组</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p><p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        stringBox.add(<span class="keyword">new</span> String(<span class="string">"菜鸟教程"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"整型值为 :%d\n\n"</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">"字符串为 :%s\n"</span>, stringBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><ol><li>类型通配符一般是使用 <code>?</code> 代替具体的类型参数。例如 <code>List</code> 在逻辑上是 <code>List</code>，<code>List</code> 等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。</li><li>类型通配符上限通过形如 List 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。</li><li>类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如 Objec 类型的实例。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>总体上异常分三类： </p><ol><li>错误（Error）</li></ol><p>指的是<strong>系统级别的异常</strong>，通常是内存用光了。在<strong>默认设置下</strong>，一般java程序启动的时候，最大可以使用16m的内存。如果不停的给StringBuffer追加字符，很快就把内存使用光了。抛出<strong>OutOfMemoryError</strong></p><p><strong>与运行时异常一样，错误也是不要求强制捕捉的</strong></p><ol start="2"><li>运行时异常（Exception ）</li></ol><p>运行时异常RuntimeException指： <strong>不是必须进行try catch的异常</strong><br><strong>常见运行时异常:</strong> </p><ul><li>除数不能为0异常:ArithmeticException </li><li>下标越界异常:ArrayIndexOutOfBoundsException </li><li>空指针异常:NullPointerException</li></ul><p>在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，<strong>即便不进行try catch，也不会有编译错误</strong>。Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟糕。</p><ol start="3"><li>可查异常（Exception ）</li></ol><p>可查异常即<strong>必须进行处理的异常</strong>，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException<br>如果不处理，编译器，就不让你通过</p><p><strong>运行时异常与非运行时异常的区别：</strong></p><p>运行时异常是不可查异常，不需要进行显式的捕捉<br>非运行时异常是可查异常，必须进行显式的捕捉，或者抛出</p><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><p><img src="/2019/12/02/JAVA-NOTES/PPjwP.png" alt="img"></p><h2 id="Java参数传递"><a href="#Java参数传递" class="headerlink" title="Java参数传递"></a>Java参数传递</h2><blockquote><p>值传递（pass by value）是指在调用函数时将实际参数<code>复制</code>一份传递到函数中，这样在函数中如果对<code>参数</code>进行修改，将<strong>不会影响</strong>到实际参数。</p><p>引用传递（pass by reference）是指在调用函数时将实际参数的地址<code>直接</code>传递到函数中，那么在函数中对<code>参数</code>所进行的修改，将<strong>会影响</strong>到实际参数。</p></blockquote><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">"B"</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"A"</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h2><p>Java 面向对象的基本思想之一是封装细节并且公开接口。Java 语言采用访问控制修饰符来控制类及类的方法和变量的访问权限，从而向使用者暴露接口，但隐藏实现细节。访问控制分为四种级别：</p><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同 包</th><th align="left">子 类</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left">public</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">protected</td><td align="left">√</td><td align="left">√</td><td align="left">√</td><td align="left">×</td></tr><tr><td align="left">default</td><td align="left">√</td><td align="left">√</td><td align="left">×</td><td align="left">×</td></tr><tr><td align="left">private</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><ul><li>类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。</li><li>受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</li></ul><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><ul><li>实例化一个对象, 其构造方法会被调用 </li><li>其父类的构造方法也会被调用，并且是父类构造方法先调用 </li><li>子类构造方法会默认调用父类的无参的构造方法</li></ul><p><strong>当父类Hero提供了一个有参的构造方法，但是没有提供无参的构造方法，子类应该怎么处理？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    故意不提供无参的构造方法</span></span><br><span class="line"><span class="comment">//    public Hero()&#123;</span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为子类，无论如何都会调用父类的构造方法。<br>默认情况下，会调用父类的无参的构造方法。<br>但是，当父类没有无参构造方法的时候( 提供了有参构造方法，并且不显示提供无参构造方法)，子类就会抛出异常，因为它尝试去调用父类的无参构造方法。<br>这个时候，必须通过super去调用父类声明的、存在的、有参的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADHero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行物理攻击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Java 中定义一个不做事且没有参数的构造方法的作用</strong></p><p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 </p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li>在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><blockquote><p>简单解释一下：<br>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。</p></blockquote><h2 id="Java封装"><a href="#Java封装" class="headerlink" title="Java封装"></a>Java封装</h2><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类也就是没有名字的内部类。使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p><p><strong>实例1：不使用匿名内部类来实现抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：eat something</p><p>可以看到，我们用 Child 继承了 Person 类，然后实现了 Child 的一个实例，将其向上转型为 Person 类的引用</p><p>但是，如果此处的 Child 类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？这个时候就引入了匿名内部类</p><p><strong>实例2：匿名内部类的基本实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：eat something</p><p>可以看到，我们直接将抽象类 Person 中的方法在大括号中实现了，这样便可以省略一个类的书写，并且，匿名内部类还能用于接口上。</p><p><strong>实例3：在接口上使用匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"eat something"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：eat something</p><p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p><p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承 Thread 类或是继承 Runnable 接口</p><p><strong>实例4：Thread类的匿名内部类实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：1 2 3 4 5</p><p><strong>实例5：Runnable接口的匿名内部类实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Click to copy</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：1 2 3 4 5</p><h2 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h2><p>多态的理解（多态的实现方式）</p><ul><li><strong>方法重载</strong>（overload）：实现的是<strong>编译时的多态性</strong>（也称为前绑定）。</li><li><strong>方法重写</strong>（override）：实现的是<strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西。</li></ul><p>项目中对多态的应用</p><ul><li>举一个简单的例子，在物流信息管理系统中，有两种用户：订购客户和卖房客户，两个客户都可以登录系统，他们有相同的方法 Login，但登陆之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承父类的 Login 方法，但对于不同的对象，拥有不同的操作。</li></ul><p>面相对象开发方式优点</p><ul><li>较高的<strong>开发效率</strong>：可以把事物进行抽象，映射为开发的对象。</li><li>保证软件的<strong>鲁棒性</strong>：高重用性，可以重用已有的而且在相关领域经过长期测试的代码。</li><li>保证软件的<strong>高可维护性</strong>：代码的可读性非常好，设计模式也使得代码结构清晰，拓展性好。</li></ul><h3 id="向上-下转型"><a href="#向上-下转型" class="headerlink" title="向上/下转型"></a>向上/下转型</h3><p>父类引用能指向子类对象，子类引用不能指向父类对象；</p><p><strong>向上转型</strong></p><p>父类引用指向子类对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure><p><strong>向下转型</strong></p><p>把指向子类对象的父类引用赋给子类引用，需要强制转换，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> Son();</span><br><span class="line">Son s1 = (Son)f1;</span><br></pre></td></tr></table></figure><p>但有运行出错的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Father f2 = <span class="keyword">new</span> Father();</span><br><span class="line">Son s2 = (Son)f2; <span class="comment">//编译无错但运行会出现错误</span></span><br></pre></td></tr></table></figure><p>在不确定父类引用是否指向子类对象时，可以用 instanceof 来判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f3 <span class="keyword">instanceof</span> Son)&#123;</span><br><span class="line">     Son s3 = (Son)f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 是 Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>instanceof 是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object testObject = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        displayObjectClass(testObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayObjectClass</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Vector)</span><br><span class="line">            System.out.println(<span class="string">"对象是 java.util.Vector 类的实例"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArrayList)</span><br><span class="line">            System.out.println(<span class="string">"对象是 java.util.ArrayList 类的实例"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"对象是 "</span> + o.getClass() + <span class="string">" 类的实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型-amp-装-拆箱"><a href="#数据类型-amp-装-拆箱" class="headerlink" title="数据类型&amp;装/拆箱"></a>数据类型&amp;装/拆箱</h3><ul><li>4 类 8 种基本数据类型。4 整数型，2 浮点型，1 布尔型，1 字符型</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储</th><th align="left">取值范围</th><th align="left">默认值</th><th align="left">包装类</th></tr></thead><tbody><tr><td align="left"><strong>整数型</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">byte</td><td align="left">8</td><td align="left">最大存储数据量是 255，最小 -2^7^，最大 2^7^-1， [-128~127]</td><td align="left">(byte) 0</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">16</td><td align="left">最大数据存储量是 65536，[-2^15^,2^15^-1]， [-32768,32767]，±3万</td><td align="left">(short) 0</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">32</td><td align="left">最大数据存储容量是 231-1， [-2^31^,2^31^-1]，±21亿，[ -2147483648, 2147483647]</td><td align="left">0</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">64</td><td align="left">最大数据存储容量是 264-1， [-2^63^,2^63^-1]， ±922亿亿（±（922+16个零））</td><td align="left">0L</td><td align="left">Long</td></tr><tr><td align="left"><strong>浮点型</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">float</td><td align="left">32</td><td align="left">数据范围在 3.4e-45~1.4e38，直接赋值时必须在数字后加上 f 或 F</td><td align="left">0.0f</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">64</td><td align="left">数据范围在 4.9e-324~1.8e308，赋值时可以加 d 或 D 也可以不加</td><td align="left">0.0d</td><td align="left">Double</td></tr><tr><td align="left"><strong>布尔型</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">boolean</td><td align="left">1</td><td align="left">true / flase</td><td align="left">false</td><td align="left">Boolean</td></tr><tr><td align="left"><strong>字符型</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">char</td><td align="left">16</td><td align="left">存储 Unicode 码，用单引号赋值</td><td align="left">‘\u0000’ (null)</td><td align="left">Character</td></tr></tbody></table><ul><li>引用数据类型</li><li>自动装箱和拆箱</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk 1.5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer m =<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在 jdk1.4 以后的版本都不会报错，它实现了自动拆装箱的功能</p><h3 id="ValueOf缓存池"><a href="#ValueOf缓存池" class="headerlink" title="ValueOf缓存池"></a>ValueOf缓存池</h3><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于，new Integer(123) 每次都会新建一个对象，而 Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valueOf 源码实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h2><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java 定义了位运算符，应用于整数类型 (int)，长整型 (long)，短整型 (short)，字符型 (char)，和字节型 (byte)等类型。</p><p>下表列出了位运算符的基本运算，假设整数变量A的值为60和变量B的值为13</p><p>A（60）：0011 1100</p><p>B（13）：0000 1101</p><table><thead><tr><th align="left">操作符</th><th align="left">名称</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">＆</td><td align="left">与</td><td align="left">如果相对应位都是 1，则结果为 1，否则为 0</td><td align="left">（A＆B）得到 12，即 0000 1100</td></tr><tr><td align="left">|</td><td align="left">或</td><td align="left">如果相对应位都是 0，则结果为 0，否则为 1</td><td align="left">（A|B）得到 61，即 0011 1101</td></tr><tr><td align="left">^</td><td align="left">异或</td><td align="left">如果相对应位值相同，则结果为 0，否则为 1</td><td align="left">（A^B）得到49，即 0011 0001</td></tr><tr><td align="left">〜</td><td align="left">非</td><td align="left">按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0</td><td align="left">（〜A）得到-61，即1100 0011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移</td><td align="left">（左移一位乘2）按位左移运算符。左操作数按位左移右操作数指定的位数。左移 n 位表示原来的值乘 2n</td><td align="left">A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left"></td><td align="left">（右移一位除2）有符号右移，按位右移运算符。左操作数按位右移右操作数指定的位数</td><td align="left">A &gt;&gt; 2得到15即 1111</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">无符号右移</td><td align="left">无符号右移，按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td align="left">A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h3 id="amp-和-amp-amp-、-和"><a href="#amp-和-amp-amp-、-和" class="headerlink" title="&amp; 和 &amp;&amp; 、| 和 ||"></a>&amp; 和 &amp;&amp; 、| 和 ||</h3><p>（1）&amp;&amp; 和 &amp; 都是表示与，区别是 &amp;&amp; 只要第一个条件不满足，后面条件就不再判断。而 &amp; 要对所有的条件都进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((<span class="number">23</span>!=<span class="number">23</span>) &amp;&amp; (<span class="number">100</span>/<span class="number">0</span>==<span class="number">0</span>))&#123;  </span><br><span class="line">        System.out.println(<span class="string">"运算没有问题。"</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"没有报错"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 输出的是“没有报错”。而将 &amp;&amp; 改为 &amp; 就会如下错误：</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.ArithmeticException: / by zero</span></span><br></pre></td></tr></table></figure><p>（2）|| 和 | 都是表示 “或”，区别是 || 只要满足第一个条件，后面的条件就不再判断，而 | 要对所有的条件进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((<span class="number">23</span>==<span class="number">23</span>)||(<span class="number">100</span>/<span class="number">0</span>==<span class="number">0</span>))&#123;  </span><br><span class="line">        System.out.println(<span class="string">"运算没有问题。"</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"没有报错"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java字符串"><a href="#Java字符串" class="headerlink" title="Java字符串"></a>Java字符串</h2><h3 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h3><p>Java 中字符串对象创建有两种形式，一种为字面量形式，如 <code>String str = &quot;abc&quot;;</code>，另一种就是使用 new 这种标准的构造对象的方法，如 <code>String str = new String(&quot;abc&quot;);</code>，这两种方式我们在代码编写时都经常使用，尤其是字面量的方式。然而<strong>这两种实现其实存在着一些性能和内存占用的差别</strong>。这一切都是源于 JVM 为了减少字符串对象的重复创建，其维护了一个特殊的内存，这段内存被成为<strong>字符串常量池</strong>或者<strong>字符串字面量池</strong>。</p><p><strong>工作原理</strong></p><p>当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以上两个局部变量都存在了常量池中</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// new出来的对象不会放到常量池中,内存地址是不同的</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String();</span><br><span class="line">        String s4 = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 字符串的比较不可以使用双等号,这样会比较内存地址</span></span><br><span class="line"><span class="comment">         * 字符串比较应当用equals,可见String重写了equals</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3.equals(s4)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在这两种情况下会将对象引用自动加入到常量池</span></span><br><span class="line">String str1 = <span class="string">"aaa"</span>;</span><br><span class="line">String str2 = <span class="string">"aa"</span>+<span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他方式下都不会将对象引用自动加入到常量池，如下：</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String str4 = <span class="function">New <span class="title">StringBuilder</span><span class="params">(<span class="string">"aa"</span>)</span>.<span class="title">append</span><span class="params">(<span class="string">"a"</span>)</span>.<span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">StringBuilder sb = <span class="function">New <span class="title">StringBuilder</span><span class="params">()</span></span>;</span><br><span class="line">sb.append(<span class="string">"aa"</span>);</span><br><span class="line">sb.append(<span class="string">"a"</span>);</span><br><span class="line">String str5 = sb.toString();</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 被声明为 final，因此它不可被继承。</p><ul><li>在 Java 8 中，String 内部使用 char 数组存储数据。</li><li>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** String本质是个char数组. 而且用final关键字修饰.*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 用 final 修饰，表示编译器不允许我把 value 指向堆区另一个地址。但如果我直接对数组元素动手，分分钟搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] value=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">value[<span class="number">2</span>]=<span class="number">100</span>;  <span class="comment">//这时候数组里已经是&#123;1,2,100&#125;</span></span><br></pre></td></tr></table></figure><p>或者更粗暴的反射直接改，也是可以的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Array.set(array,<span class="number">2</span>,<span class="number">100</span>); <span class="comment">//数组也被改成&#123;1,2,100&#125;</span></span><br></pre></td></tr></table></figure><p>所以 String 是不可变，关键是因为 SUN 公司的工程师，在后面所有 String 的方法里很小心的没有去动 Array 里的元素，没有暴露内部成员字段。<code>private final char value[]</code>这一句里，private 的私有访问权限的作用都比 final 大。而且设计师还很小心地把整个 String 设成 final 禁止继承，避免被其他人继承后破坏。所以 <strong>String 是不可变的关键都在底层的实现，而不是一个 final。</strong></p><p><strong>不可变的好处</strong></p><ol><li>可以缓存 hash 值</li></ol><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><ol start="2"><li>String Pool 的需要</li></ol><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><ol start="3"><li>安全性</li></ol><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><ol start="4"><li>线程安全</li></ol><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </p><ol start="5"><li>安全性代码示范</li></ol><p>一个函数 appendStr()在不可变的 String 参数后面加上一段 “bbb” 后返回。appendSb( )负责在可变的 StringBuilder 后面加“bbb”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//不可变的String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">appendStr</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s += <span class="string">"bbb"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变的StringBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">appendSb</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">"bbb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//String做参数</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">        String ns = Test.appendStr(s);</span><br><span class="line">        System.out.println(<span class="string">"String aaa &gt;&gt;&gt; "</span>+s.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuilder做参数</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder nsb = Test.appendSb(sb);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder aaa &gt;&gt;&gt; "</span>+sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output: </span></span><br><span class="line"><span class="comment">//String aaa &gt;&gt;&gt; aaa</span></span><br><span class="line"><span class="comment">//StringBuilder aaa &gt;&gt;&gt; aaabbb</span></span><br></pre></td></tr></table></figure><p>如果程序员不小心像上面例子里，直接在传进来的参数上加 “bbb”，因为 Java 对象参数传的是引用，所以可变的的 StringBuffer 参数就被改变了。可以看到变量 sb 在 Test.appendSb(sb) 操作之后，就变成了 “aaabbb”。有的时候这可能不是程序员的本意。所以 String 不可变的安全性就体现在这里。</p><p>再看下面这个 <strong>HashSet</strong> 用 StringBuilder 做元素的场景，问题就更严重了，而且更隐蔽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs = <span class="keyword">new</span> HashSet&lt;StringBuilder&gt;();</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaa"</span>);</span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"aaabbb"</span>);</span><br><span class="line">        hs.add(sb1);</span><br><span class="line">        hs.add(sb2);    <span class="comment">//这时候HashSet里是&#123;"aaa","aaabbb"&#125;</span></span><br><span class="line"></span><br><span class="line">        StringBuilder sb3 = sb1;</span><br><span class="line">        sb3.append(<span class="string">"bbb"</span>);  <span class="comment">//这时候HashSet里是&#123;"aaabbb","aaabbb"&#125;</span></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//[aaabbb, aaabbb]</span></span><br></pre></td></tr></table></figure><p>StringBuilder 型变量 sb1 和 sb2 分别指向了堆内的字面量 “aaa” 和 “aaabbb”。把他们都插入一个 HashSet。到这一步没问题，但如果后面我把变量 sb3 也指向 sb1 的地址，再改变 sb3 的值，因为 StringBuilder 没有不可变性的保护，sb3 直接在原先 “aaa” 的地址上改。导致 sb1 的值也变了。这时候，HashSet 上就出现了两个相等的键值 “aaabbb”。<strong>破坏了 HashSet 键值的唯一性</strong>。所以<strong>千万不要用可变类型做 HashMap 和 HashSet 键值。</strong></p><p>在并发场景下，多个线程同时读一个资源，是不会引发竞争条件的。只有对资源做写操作才有危险。不可变对象不能被写，所以<strong>线程安全</strong>。</p><p>同时String 另外一个<strong>字符串常量池</strong>的属性。这样在大量使用字符串的情况下，可以节省内存空间，提高效率。</p><h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><p>在jdk 6 中，当调用 substring 方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的，字符串中包含的字符个数以及数组的第一个位置索引。</p><p><img src="/2019/12/02/JAVA-NOTES/string-substring-jdk6-650x389.jpeg" alt="string-substring-jdk6"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 6</span></span><br><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk 7 中，substring方法会在堆内存中创建一个新的数组。</p><p><img src="http://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg" alt="string-substring-jdk7"></p><p>Java源码中关于这部分的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是JDK 7中的subString方法，其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p><h4 id="String对于-的重载"><a href="#String对于-的重载" class="headerlink" title="String对于 + 的重载"></a>String对于 + 的重载</h4><ul><li>会创建一个新的字符串；</li><li>编译时会将 + 转为StringBuilder的append方法。</li><li>注意新的字符串是在运行时在堆里创建的。</li><li><code>String str1 = “ABC”;</code>可能创建一个或者不创建对象，如果”ABC”这个字符串在java String池里不存在，会在java String池里创建一个创建一个String对象(“ABC”)，然后str1指向这个内存地址，无论以后用这种方式创建多少个值为”ABC”的字符串对象，始终只有一个内存地址被分配，之后的都是String的拷贝，Java中称为“字符串驻留”，所有的字符串常量都会在编译之后自动地驻留。</li><li>注意只有字符串常量是共享的，+ 和 substring等操作的结果不是共享的，substring也会在堆中重新创建字符串。</li></ul><h4 id="String拼接"><a href="#String拼接" class="headerlink" title="String拼接"></a>String拼接</h4><p>所有的所谓字符串拼接，都是重新生成了一个新的字符串。</p><p><img src="/2019/12/02/JAVA-NOTES/15472897908391.jpg" alt="img"></p><p><strong>使用<code>+</code>拼接字符串</strong></p><p>在Java中，拼接字符串最简单的方式就是直接使用符号<code>+</code>来拼接。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat + <span class="string">","</span> + introduce;</span><br></pre></td></tr></table></figure><p>这里要特别说明一点，有人把Java中使用<code>+</code>拼接字符串的功能理解为<strong>运算符重载</strong>。这其实只是Java提供的一个<strong>语法糖</strong>。</p><p>注意：阿里巴巴Java开发手册中不建议在循环体中使用<code>+</code>进行字符串拼接呢？</p><p><img src="/2019/12/02/JAVA-NOTES/15472850170230.jpg" alt="img"></p><p>原代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str += s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"+ cost:"</span> + (t2 - t1));</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str = (<span class="keyword">new</span> StringBuilder()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">new</span> StringBuilder()).append(<span class="string">"+ cost:"</span>).append(t2 - t1).toString());</span><br></pre></td></tr></table></figure><p>我们可以看到，反编译后的代码，在<code>for</code>循环中，每次都是<code>new</code>了一个<code>StringBuilder</code>，然后再把<code>String</code>转成<code>StringBuilder</code>，再进行<code>append</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">String i1 = <span class="string">""</span> + i;</span><br><span class="line"><span class="comment">// 上行代码的原理</span></span><br><span class="line">String i1 = (<span class="keyword">new</span> StringBuilder()).append(i).toString();</span><br></pre></td></tr></table></figure><p>而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。</p><p>所以，阿里巴巴Java开发手册建议：循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。而不要使用<code>+</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两行也相等，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。</span></span><br><span class="line">String i2 = String.valueOf(i);</span><br><span class="line">String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure><p><strong>concat</strong><br>除了使用<code>+</code>拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat.concat(<span class="string">","</span>).concat(introduce);</span><br></pre></td></tr></table></figure><p><strong>StringBuffer</strong></p><p>关于字符串，Java中除了定义了一个可以用来定义<strong>字符串常量</strong>的<code>String</code>类以外，还提供了可以用来定义<strong>字符串变量</strong>的<code>StringBuffer</code>类，它的对象是可以扩充和修改的。</p><p>使用<code>StringBuffer</code>可以方便的对字符串进行拼接。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer wechat = <span class="keyword">new</span> StringBuffer(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuffer hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure><p><strong>StringBuilder</strong><br>除了<code>StringBuffer</code>以外，还有一个类<code>StringBuilder</code>也可以使用，其用法和<code>StringBuffer</code>类似。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder wechat = <span class="keyword">new</span> StringBuilder(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuilder hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>本文介绍了什么是字符串拼接，虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。</p><p>常用的字符串拼接方式有五种，分别是使用<code>+</code>、使用<code>concat</code>、使用<code>StringBuilder</code>、使用<code>StringBuffer</code>以及使用<code>StringUtils.join</code>。</p><p>由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。</p><p>因此，经过对比，我们发现，直接使用<code>StringBuilder</code>的方式是效率最高的。因为<code>StringBuilder</code>天生就是设计来定义可变字符串和字符串的变化操作的。</p><p>但是，还要强调的是：</p><p>1、如果不是在循环体中进行字符串拼接的话，直接使用<code>+</code>就好了。</p><p>2、如果在并发场景中进行字符串拼接的话，要使用<code>StringBuffer</code>来代替<code>StringBuilder</code>。</p><h4 id="String里面的equals"><a href="#String里面的equals" class="headerlink" title="String里面的equals"></a>String里面的equals</h4><p>String重写了Object的hashCode和equals</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer、StringBuilder、String"><a href="#StringBuffer、StringBuilder、String" class="headerlink" title="StringBuffer、StringBuilder、String"></a>StringBuffer、StringBuilder、String</h3><ol><li>可变性</li></ol><p>String 不可变<br>StringBuffer 和 StringBuilder 可变</p><ol start="2"><li>线程安全</li></ol><p>String 不可变，因此是线程安全的<br>StringBuilder 不是线程安全的<br>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</p><ol start="3"><li>性能</li></ol><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><ol start="4"><li>对于三者使用的总结：</li></ol><p>操作少量的数据：适用String<br>单线程操作字符串缓冲区下操作大量数据：适用StringBuilder<br>多线程操作字符串缓冲区下操作大量数据：适用StringBuffer</p><ol start="5"><li>代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br></pre></td></tr></table></figure><p>AbstractStringBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; <span class="number">0</span>)</span><br><span class="line">        ensureCapacityInternal(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的方法最终是由<code>expandCapacity()</code>实现的，在这个方法中首先把容量扩大为<strong>原来的容量加2</strong>，如果此时仍小于指定的容量，那么就把新的容量设为<code>minimumCapacity</code>。然后判断是否溢出，如果溢出了，把容量设为<code>Integer.MAX_VALUE</code>。最后把<code>value</code>值进行拷贝，<strong>这显然是耗时操作</strong>。</p><p>append()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>append()</code>是最常用的方法，用于追加字符串。如果<code>str</code>是<code>null</code>,则会调用<code>appendNull()</code>方法，会追加<code>&#39;n&#39;</code>、<code>&#39;u&#39;</code>、<code>&#39;l&#39;</code>、<code>&#39;l&#39;</code>这几个字符。如果不是<code>null</code>，则首先扩容，然后调用<code>String</code>的<code>getChars()</code>方法将<code>str</code>追加到<code>value</code>末尾。最后返回对象本身，所以<code>append()</code>可以连续调用。</p><p><strong>StringBuilder</strong></p><p><code>AbstractStringBuilder</code>已经实现了大部分需要的方法，<code>StringBuilder</code>和<code>StringBuffer</code>只需要调用即可。</p><p>append()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toString()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>toString()</code>方法返回了一个新的<code>String</code>对象，与原来的对象不共享内存。</p><p>SringBuffer</p><p><code>StiringBuffer</code>跟<code>StringBuilder</code>类似，只不过为了实现同步，很多方法使用l<code>Synchronized</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.setLength(newLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，方法前面确实加了<code>Synchronized</code>。另外，在上面的<code>append()</code>以及<code>setLength()</code>方法里面还有个变量<code>toStringCache</code>。这个变量是用于最近一次<code>toString()</code>方法的缓存，任何时候只要<code>StringBuffer</code>被修改了这个变量会被赋值为<code>null</code>。<code>StringBuffer</code>的<code>toString</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，如果<code>toStringCache</code>为<code>null</code>则先缓存。最终返回的<code>String</code>对象有点不同，这个构造方法还有个参数<code>true</code>。找到<code>String</code>的源码看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来这个构造方法构造出来的<code>String</code>对象并没有实际复制字符串，只是把<code>value</code>指向了构造参数，这是为了节省复制元素的时间。不过这个构造器是具有包访问权限，一般情况下是不能调用的。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="并发编程需要解决的问题"><a href="#并发编程需要解决的问题" class="headerlink" title="并发编程需要解决的问题"></a>并发编程需要解决的问题</h3><blockquote><p>线程间<strong>通信</strong>&amp;线程间<strong>同步</strong></p></blockquote><p>线程之间通信机制分为两种：<strong>共享内存</strong>、<strong>消息传递</strong></p><p> <strong>共享内存</strong>通信与同步</p><table><thead><tr><th>操作类型</th><th>实现方式</th></tr></thead><tbody><tr><td>通信</td><td>线程之间共享程序的公共状态，通过写－读内存中的变量的公共状态进行隐式通信</td></tr><tr><td>同步</td><td>显式进行同步，必须显式制定某个方法或某段代码需要在线程之间互斥执行</td></tr></tbody></table><p><strong>消息传递</strong>通信与同步</p><table><thead><tr><th>操作类型</th><th>实现方式</th></tr></thead><tbody><tr><td>通信</td><td>线程之间没有公共状态，线程之间通过发送消息显式进行通信</td></tr><tr><td>同步</td><td>隐式进行同步，消息发送必须在消息发送之前</td></tr></tbody></table><p>注意：<strong>java并发采用的是共享内存模型</strong>，java线程之间的通信总是隐式进行的。</p><h3 id="内存模型概念"><a href="#内存模型概念" class="headerlink" title="内存模型概念"></a>内存模型概念</h3><ul><li><p>在Java中所有的实例对象、静态数据域、和数组元素都存储在堆内存当中，堆内存在线程之间是共享的。 ——堆中数据域是线程共享的</p></li><li><p>局部变量、方法定义参数、和异常处理器参数不会在线程之间共享、他们不会有内存可见性问题，也不受内存模型的影响。——线程独享的</p></li></ul><h4 id="JMM简介"><a href="#JMM简介" class="headerlink" title="JMM简介"></a>JMM简介</h4><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见。(可见性保证)</p><blockquote><p>JMM同步规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ul></blockquote><ul><li>由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行看。</li><li>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</li><li>内存模型图</li></ul><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20190416211412.png" alt="搜狗截图20190416211412"></p><p><img src="/2019/12/02/JAVA-NOTES/java-volatile.png" alt="img"></p><h3 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><blockquote><p>是 Java 虚拟机提供的轻量级的同步机制</p></blockquote><ul><li>保证可见性</li><li>禁止指令排序</li><li>不保证原子性</li></ul><h5 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h5><ul><li><p>可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data.addOne();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" updated..."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data.a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// looping</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" job is done..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新线程修改a值后，可通知main线程，即可见性</span></span><br></pre></td></tr></table></figure><p>如果不加 volatile 关键字，则主线程会进入死循环，加 volatile 则主线程能够退出，说明加了 volatile 关键字变量，当有一个线程修改了值，会马上被另一个线程感知到，当前值作废，从新从主内存中获取值。对其他线程可见，这就叫可见性。</p></li><li><p>原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// test01();</span></span><br><span class="line">       test02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    data.addOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认有 main 线程和 gc 线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并不能输入 20000</p></li></ul><h5 id="禁止指令排序"><a href="#禁止指令排序" class="headerlink" title="禁止指令排序"></a>禁止指令排序</h5><p>volatile 实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象</p><p>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，他的作用有两个：</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0e75180bf35c40e2921493d0bf6bd684_th.png" alt="0e75180bf35c40e2921493d0bf6bd684_th"></p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p><p><img src="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/21ebc7e8190c4966948c4ef4424088be_th.png" alt="21ebc7e8190c4966948c4ef4424088be_th"></p><h5 id="线程安全性保证"><a href="#线程安全性保证" class="headerlink" title="线程安全性保证"></a>线程安全性保证</h5><ul><li>工作内存与主内存同步延迟现象导致可见性问题<ul><li>可以使用 synchronzied 或 volatile 关键字解决，它们可以使用一个线程修改后的变量立即对其他线程可见</li></ul></li><li>对于指令重排导致可见性问题和有序性问题<ul><li>可以利用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排序优化</li></ul></li></ul><h4 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><ul><li><p>多线程环境下可能存在的安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton01.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现构造器里的内容会多次输出</p></li><li><p>双重锁单例</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton02 instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton01<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton02.getInstance());</span><br><span class="line">      &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有加 volatile 就不一定是线程安全的，原因是指令重排序的存在，加入 volatile 可以禁止指令重排。</p></li><li><p>原因是在于某一个线程执行到第一次检测，读取到的 instance 不为 null 时，<strong>instance 的引用对象可能还没有完成初始化。</strong></p></li><li><p><code>instance = new Singleton()</code> 可以分为以下三步完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null</span></span><br></pre></td></tr></table></figure></li><li><p>步骤 2 和步骤 3 不存在依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种优化是允许的。</p></li><li><p>发生重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null，但对象还没有初始化完成</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br></pre></td></tr></table></figure></li><li><p>所以不加 volatile 返回的实例不为空，但可能是未初始化的实例</p></li></ul></li></ul><h2 id="SpringBoot与SSM"><a href="#SpringBoot与SSM" class="headerlink" title="SpringBoot与SSM"></a>SpringBoot与SSM</h2><p>首先看搭建 SSM 框架时，我们需要哪些步骤</p><ol><li><p>加相关的 jar 包</p></li><li><p>配置 web.xml，加载 Spring，SpringMVC</p></li><li><p>配置数据库连接，spring 事务</p></li><li><p>配置加载配置文件的读取，开启注解</p></li><li><p>配置日志文件</p></li><li><p>配置完成，部署 tomcat 调试</p></li></ol><p>而这些配置 SpringBoot 都帮我们做好了：</p><p><img src="/2019/12/02/JAVA-NOTES/926090-20190324114958133-488948960.png" alt="img"></p><p>就是这些 starter 依赖，帮我们做了很多配置。</p><p>springboot 框架使用 starter 依赖主要帮我们做了两点：</p><p>1.引入相关的 jar</p><p>2.自动完成 bean 配置。</p><p>总结：</p><ol><li>Springboot 将原有的 xml 配置，简化为 java 注解</li><li>使用 IDE 可以很方便的搭建一个 springboot 项目，选择对应的 maven 依赖，简化Spring应用的初始搭建以及开发过程</li><li>springboot 有内置的 tomcat 服务器，可以 jar 形式启动一个服务,可以快速部署发布 web 服务</li><li>springboot 使用 starter 依赖自动完成 bean 配置，，解决 bean 之间的冲突，并引入相关的 jar 包（这一点最重要）</li></ol><h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable&amp;Comparator"></a>Comparable&amp;Comparator</h2><h3 id="Comparable-是排序接口"><a href="#Comparable-是排序接口" class="headerlink" title="Comparable 是排序接口"></a>Comparable 是排序接口</h3><p>若一个类实现了Comparable接口，就意味着“<strong>该类支持排序</strong>”。  即实现Comparable接口的类支持排序，实现Comparable接口的类的对象的List列表（或数组），该List列表（或数组）可以通过 Collections.sort（或 Arrays.sort）进行排序。</p><p>在用Collections类的sort方法排序时若不指定Comparator，那就以自然顺序排序。所谓自然顺序就是实现Comparable接口中按照 compareTo 方法中的规则进行。</p><p>若一个类实现了comparable接口，则意味着该类支持排序。如String、Integer自己就实现了Comparable接口，可完成比较大小操作。</p><p>实际上所有实现了 Comparable 接口的 Java 核心类的结果都和 equlas 方法保持一致。</p><p>实现了 Comparable 接口的对象才能够直接被用作 SortedMap (SortedSet) 的 key，要不然得在外边指定 Comparator 排序规则。因此自己定义的类如果想要使用有序的集合类，需要实现 Comparable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 若返回“负数”，意味着“x比y小”；返回“正数”，意味着“x大于y”</span></span><br><span class="line">    <span class="comment">// e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</span></span><br><span class="line">    <span class="comment">// e1.compareTo(e2) = 0 即 e1 = e2</span></span><br><span class="line">    <span class="comment">// e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookBean</span><span class="params">(String name, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> BookBean)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        BookBean bean = (BookBean) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getCount() != bean.getCount()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getName().equals(bean.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 hashCode 的计算方法</span></span><br><span class="line"><span class="comment">     * 根据所有属性进行 迭代计算，避免重复</span></span><br><span class="line"><span class="comment">     * 计算 hashCode 时 计算因子 31 见得很多，是一个质数，不能再被除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 String 的 hashCode(), 唯一表示一个字符串内容</span></span><br><span class="line">        <span class="keyword">int</span> result = getName().hashCode();</span><br><span class="line">        <span class="comment">//乘以 31, 再加上 count</span></span><br><span class="line">        result = <span class="number">31</span> * result + getCount();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BookBean&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", count="</span> + count +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向 TreeSet 中添加 BookBean 时，会调用这个方法进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> another</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (another <span class="keyword">instanceof</span> BookBean)&#123;</span><br><span class="line">            BookBean anotherBook = (BookBean) another;</span><br><span class="line">            <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//比如这里按照书价排序</span></span><br><span class="line">            result = getCount() - anotherBook.getCount();     </span><br><span class="line"></span><br><span class="line">          <span class="comment">//或者按照 String 的比较顺序</span></span><br><span class="line">          <span class="comment">//result = getName().compareTo(anotherBook.getName());</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>)&#123;   <span class="comment">//当书价一致时，再对比书名。 保证所有属性比较一遍</span></span><br><span class="line">                result = getName().compareTo(anotherBook.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一样就返回 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparator-是比较器接口"><a href="#Comparator-是比较器接口" class="headerlink" title="Comparator 是比较器接口"></a>Comparator 是比较器接口</h3><p>我们若需要控制某个类的次序，而该类本身不支持排序（即没有实现Comparable接口）；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。</p><p>也就是说，我们可以通过“<strong>实现Comparator类来新建一个比较器</strong>”，然后通过该比较器对类进行排序。<strong>Comparator体现了一种策略模式(strategy design pattern)，就是不改变对象自身，而用一个策略对象(strategy object)来改变它的行为。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 若返回“负数”，意味着“x比y小”；返回“正数”，意味着“x大于y”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="comment">// 数值等同==，未重写表示对象引值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：若一个类要实现Comparator接口，它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。因为任何类，默认都是已经实现了equals(Object obj)的。</p></blockquote><h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><p>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。<br>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> compar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: "Comparator"和“Comparable”的比较汇总程序。</span></span><br><span class="line"><span class="comment"> * (01) "Comparable"</span></span><br><span class="line"><span class="comment"> * 它是一个排序接口，只包含一个函数compareTo()。</span></span><br><span class="line"><span class="comment"> * 一个类实现了Comparable接口，就意味着“该类本身支持排序”，它可以直接通过Arrays.sort() 或 Collections.sort()进行排序。</span></span><br><span class="line"><span class="comment"> * (02) "Comparator"</span></span><br><span class="line"><span class="comment"> * 它是一个比较器接口，包括两个函数：compare() 和 equals()。</span></span><br><span class="line"><span class="comment"> * 一个类实现了Comparator接口，那么它就是一个“比较器”。其它的类，可以根据该比较器去排序。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 综上所述：Comparable是内部比较器，而Comparator是外部比较器。</span></span><br><span class="line"><span class="comment"> * 一个类本身实现了Comparable比较器，就意味着它本身支持排序；若它本身没实现Comparable，也可以通过外部比较器Comparator进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建ArrayList(动态数组)</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        <span class="comment">// 添加对象到ArrayList中</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ccc"</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"AAA"</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"bbb"</span>, <span class="number">10</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ddd"</span>, <span class="number">40</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印list的原始序列</span></span><br><span class="line">        System.out.printf(<span class="string">"Original  sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list进行排序</span></span><br><span class="line">        <span class="comment">// 这里会根据“Person实现的Comparable&lt;String&gt;接口”进行排序，即会根据“name”进行排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.printf(<span class="string">"Name      sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过“比较器(AscAgeComparator)”，对list进行排序</span></span><br><span class="line">        <span class="comment">// AscAgeComparator的排序方式是：根据“age”的升序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> AscAgeComparator());</span><br><span class="line">        System.out.printf(<span class="string">"Asc(age)  sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过“比较器(DescAgeComparator)”，对list进行排序</span></span><br><span class="line">        <span class="comment">// DescAgeComparator的排序方式是：根据“age”的降序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> DescAgeComparator());</span><br><span class="line">        System.out.printf(<span class="string">"Desc(age) sort, list:%s\n"</span>, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个person是否相等</span></span><br><span class="line">        testEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 测试两个Person比较是否相等。</span></span><br><span class="line"><span class="comment">     * 由于Person实现了equals()函数：若两person的age、name都相等，则认为这两个person相等。</span></span><br><span class="line"><span class="comment">     * 所以，这里的p1和p2相等。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * TODO：若去掉Person中的equals()函数，则p1不等于p2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1.equals(p2)) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s NOT EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">     * Person实现了Comparable接口，这意味着Person本身支持排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">" - "</span> + age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。</span></span><br><span class="line"><span class="comment">         * 这里是通过“person的名字”进行比较的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.compareTo(person.name);</span><br><span class="line">            <span class="comment">//return this.name - person.name;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> AscAgeComparator比较器</span></span><br><span class="line"><span class="comment">     * 它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AscAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> DescAgeComparator比较器</span></span><br><span class="line"><span class="comment">     * 它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DescAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postgraduate Life</title>
      <link href="/2019/12/02/Postgraduate-Life/"/>
      <url>/2019/12/02/Postgraduate-Life/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>无聊的摘抄</p></blockquote><a id="more"></a><h2 id="日常摘录"><a href="#日常摘录" class="headerlink" title="日常摘录"></a>日常摘录</h2><h3 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h3><p><a href="https://www.zhihu.com/question/295424569/answer/660635912" target="_blank" rel="noopener">房东和租客的故事</a></p><h3 id="迅哥儿"><a href="#迅哥儿" class="headerlink" title="迅哥儿"></a>迅哥儿</h3><ol><li>从来如此，便对么？</li><li>猛兽总是独行，牛羊才成群结队。</li><li>假使牡丹是中国的“国花”，那么，“他妈的！”就可以算是中国的“国骂”了。</li><li>自由固不是钱所能买到的，但能够为钱而卖掉。</li><li>勇者愤怒，抽刃向更强者；怯者愤怒，却抽刃向更弱者。</li><li>面具戴太久，就会长到脸上，再想揭下来，除非伤筋动骨扒皮。</li><li>有缺点的战士终竟是战士，完美的苍蝇也终竟不过是苍蝇。</li><li>当我沉默的时候，我觉得很充实，当我开口说话，就感到了空虚。</li><li>我家门前有两棵树，一棵是枣树，另一棵也是枣树。</li><li>社会上崇敬名人，于是以为名人的话就是名言，却忘记了他之所以得名是那一种学问或事业。</li><li>哪里有天才，我是把别人喝咖啡的工夫都用在了工作上。</li><li>“急不择言”的病源，并不在没有想的功夫，而在有功夫的时候没有想。</li><li>浪费别人的时间等于谋财害命。</li><li>无刺的蔷薇是没有的，然而没有蔷薇的刺却很多。</li><li>父母之于子女，应该健全的产生，尽力的教育，完全的解放。</li><li>贪安稳就没有自由，要自由就要历些危险，只有这两条路。</li><li>小的时候不把他当人，大了以后也做不了人。</li><li>试到公园去，大概总可以遇见祖母带着她孙女儿在玩的。这位祖母的模样，就预示着那娃儿的未来。所以倘有谁要预知令夫人日后的丰姿，也只要看丈母。不同是当然要有些不同的，但总归相去不远。</li><li>希望是本无所谓有，无所谓无的。正如地上的路，其实地上本没有路，走的人多了，也便成了路。</li></ol><h4 id="趣用迅哥的话"><a href="#趣用迅哥的话" class="headerlink" title="趣用迅哥的话"></a>趣用迅哥的话</h4><p><a href="https://www.zhihu.com/question/25072853/answer/397657493" target="_blank" rel="noopener">来源：知乎</a></p><p>如何打“凑合”怪：</p><blockquote><p>中国人的性情是总喜欢调和折中的，譬如你说，这屋子太暗，须在这里开一个窗，大家一定不允许的。但如果你主张拆掉屋顶他们就来调和，愿意开窗了。</p></blockquote><p>如何打“认命”怪：</p><blockquote><p>运命并不是中国人的事前的指导，乃是事后的一种不费心思的解释。</p></blockquote><p>如何打“连马云都说了，你难道比马爸爸牛逼”怪：</p><blockquote><p>社会上崇敬名人，于是以为名人的话就是名言，却忘记了他之所以得名是那一种学问或事业。名人被崇奉所诱惑，也忘记了自己之所以得名是那一种学问或事业，渐以为一切无不胜人，无所不谈，于是乎就悖起来了。其实，专门家除了他的专长之外，许多见识是往往不及博识家或常识者的。</p></blockquote><p>如何打“何不食肉糜“怪：</p><blockquote><p>钱这个字很难听，或者要被高尚的君子们所非笑，但我总觉得人们的议论是不但昨天和今天，即使饭前和饭后，也往往有些差别。凡承认饭需要钱买，而以说钱为卑鄙者，倘能按一按他的胃，那里面怕总有鱼肉没有消化完，须得饿他一天之后，再来听他发议论。</p></blockquote><p>如何打“键盘圣人“怪：</p><blockquote><p>人的言行，在白天和在深夜，在日下和在灯前，常常显得两样。</p></blockquote><p>如何打“键盘杀手”怪：</p><blockquote><p>我想辩论事情，威吓和诬陷，是没有用处的。用笔的人，一来就发你的脾气，要我的性命，更其可笑得很。</p></blockquote><p>如何打“偏架理中客”怪：</p><blockquote><p>有些东西，为要显示他伤害你的时候的公正，在不相干的地方就称赞你几句，似乎有赏有罚，使别人看去，很像无私。</p></blockquote><p>如何打“不服井冈山”怪：</p><blockquote><p>“你敢出来！出来！躲在背后说风凉话不算好汉！”但是，如果你上了他们的当，真的赤膊奔上前阵，像许褚似的充好汉，那他那边立刻就会给你一枪，老实不客气，然后，再学着金圣叹批《三国演义》的笔法，骂一声“谁叫你赤膊的”——活该。</p></blockquote><p>如何打“恢复国学恢复儒教恢复乡贤各路恢复”怪：</p><blockquote><p>然而看看中国的一些人，至少是上等人，他们的对于神，宗教，传统的权威，是“信”和“从”呢，还是“怕”和“利用”？只要看他们的善于变化，豪无特操，是什么也不信从的，但总要摆出和内心两样的架子来</p></blockquote><p>如何打“精赵”怪：</p><blockquote><p>从指挥刀下骂出去，从裁判席上骂下去，从官营的报上骂开去，真是伟哉一世之雄，妙在被骂者不敢开口。</p></blockquote><p>如何打“我不喜欢的都禁得好“怪：</p><blockquote><p>暴君的臣民，只愿暴政暴在他人的头上，他却看着高兴，拏“残酷”做娱乐，拏“他人的苦”做赏玩，做慰安。<br>自己的本领只是“倖免”。</p></blockquote><p>如何打“外国也一样”怪：（鲁迅原文标题就是《外国也有》）</p><blockquote><p>外国人说中国多臭虫，但西洋也有臭虫；……（引用古巴前总统贪腐案）……以三十八人之多，而财产一共只有这区区二千五百万美元，手段虽不能谓之高，但有些近乎发财却总是确凿的，这已足为我们的“上峰”雪耻。不过我还希望他们在外国买有地皮，在外国银行里另有存款，那么，我们和外人折冲樽俎就更加振振有词了。假使世界上只有一家有臭虫，而遭别人指摘的时候，实在也不大舒服的，但捉起来却也真费事。况且北京有一种学说，说臭虫是捉不得的，越捉越多。即使捉尽了，又有什么价值呢，不过是一种消极的办法。最好还是希望别家也有臭虫，而竟发见了就更好。发见，这是积极的事业。</p></blockquote><p>鲁迅是不会过时的。虽然先生八十年前就去世了，然而万幸，他讽刺的人，活到了现在。</p><h3 id="云村"><a href="#云村" class="headerlink" title="云村"></a>云村</h3><h3 id="散落"><a href="#散落" class="headerlink" title="散落"></a>散落</h3><ol><li>少年就是少年，他们看春风不喜，看夏蝉不烦，看秋风不悲，看冬雪不叹，看满身富贵懒察觉，看不公不允敢面对，只因他们是少年。</li></ol><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><h4 id="犯罪悬疑："><a href="#犯罪悬疑：" class="headerlink" title="犯罪悬疑："></a>犯罪悬疑：</h4><p>《控方证人》（1957年、1982年）</p><blockquote><p>导演：比利·怀尔德、艾伦·吉布森<br>编剧：阿加莎·克里斯蒂</p></blockquote><p>《一级恐惧》（1996年）</p><blockquote><p>导演：格里高利·霍布里特<br>主演：爱德华·诺顿，理查·基尔（忠犬八公男主）</p></blockquote><p>《搏击俱乐部》（1999年）</p><blockquote><p>导演：大卫·芬奇<br>主演：爱德华·诺顿，</p></blockquote><p>《非常嫌疑犯》（1995年）</p><blockquote><p>导演：布莱恩·辛格<br>主演：凯文·史派西（纸牌屋男主）</p></blockquote><h3 id="红楼梦"><a href="#红楼梦" class="headerlink" title="红楼梦"></a>红楼梦</h3><p>优质学习课程：</p><blockquote><p>胡文彬老师讲“国内外红学研究概况”；<br>朱家溍讲“《红楼梦》中的北方生活习俗”；<br>邓云乡先生讲“南方生活习俗”；<br>周汝昌先生讲“《红楼梦》原著的优与续书的劣”；<br>王朝闻先生讲“怎样正确理解《红楼梦》的角色”；<br>李希凡先生讲“《红楼梦》的历史背景”；<br>刘耕路老师讲的“《红楼梦》的诗词曲赋”；<br>周岭老师讲的“《红楼梦》的主要人物”。</p></blockquote><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p><img src="/2019/12/02/Postgraduate-Life/image-20200414123653293.png" alt="image-20200414123653293"></p><p><img src="/2019/12/02/Postgraduate-Life/image-20200414123922579.png" alt="image-20200414123922579"></p><h2 id="2020年春节特别篇"><a href="#2020年春节特别篇" class="headerlink" title="2020年春节特别篇"></a>2020年春节特别篇</h2><h3 id="关于武汉疫情"><a href="#关于武汉疫情" class="headerlink" title="关于武汉疫情"></a>关于武汉疫情</h3><p>值得关注的点：</p><ol><li>首次提出可能发生疫情的医生被训诫</li><li>武汉封城以及当天“逃离”的500万人口</li><li>河南城乡的强力防疫举措</li><li>救灾物资预湖北红十字会的纠葛</li><li>“抱薪者”的离去——李文亮医生</li><li>大众舆论与党政透明</li></ol><p>引发的行业思考</p><p>引自知乎：<a href="https://zhuanlan.zhihu.com/p/105588404" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105588404</a></p><blockquote><p>首当其冲的是医疗健康行业的重塑。<br>其次，疫情对中小微企业的影响将加速各个行业的整合，部分在线上布局有所落后的企业将加速淘汰。</p><p>再者，线上服务线下配送，催生网络基础设施、物流与供应链体系大发展，用户使用习惯因此改变。</p><p>今天我们是不得不居家办公，线上购物，原本很多人是不接受的。尤其是现在各大企业的领导都是70后，对线上服务还不是很接受，但是这一次，让所有人都不得不做出改变，间接性的培养了全民的线上使用习惯。</p><p>要提供线上服务，网络基础设施是基础，在5G商业化的过程中，很多人还在质疑5G的实际使用价值。远超医疗、遥控挖掘机感觉还是为了5G而5G，现在看来却是一种必需。这将极大的加速5G的部署速度。</p><p>以线上办公、远程医疗、网上问诊、线上教育等等为代表的线上服务将在此大环境下加速发展。像腾讯会议、小鱼易联、网易云课堂、得到等都因此得到推广应用。</p><p>与线上对应的是线下的物流配送，其实经过多年的电商发展，我们的中国邮政、菜鸟网联、京东物流、顺丰快递已经在这次疫情中发挥了重大作用。</p><p>面向消费者的供销体系经受住了考验，但是我们看不见的面向生产领域的物流还有很多亟待改善的地方，在物联网的大背景下，整合5G等信息化技术，将对工业界带来深刻的变革。</p></blockquote><h3 id="关于疫情导致的“长假”"><a href="#关于疫情导致的“长假”" class="headerlink" title="关于疫情导致的“长假”"></a>关于疫情导致的“长假”</h3><blockquote><p>2020年2月3号农历正月初十和婷婷一起到合肥，我算是占婷婷的光，弟弟和阿姨来送的。今天2月9号正月十六，我们刚好一周。</p></blockquote><h4 id="生活："><a href="#生活：" class="headerlink" title="生活："></a>生活：</h4><p>日常早饭</p><p><img src="/2019/12/02/Postgraduate-Life/image-20200209213429349.png" alt="image-20200209213429349"></p><p>日常护肤</p><p><img src="/2019/12/02/Postgraduate-Life/image-20200209213552565.png" alt="image-20200209213552565"></p><h4 id="学习计划："><a href="#学习计划：" class="headerlink" title="学习计划："></a>学习计划：</h4><h5 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h5><p>大论文：基于深度学习的皮肤癌细粒度分类以及可解释性研究。</p><p>已完成：</p><blockquote><p>绪论</p></blockquote><p>待完成：</p><blockquote><p>细粒度研究现状<br>技术介绍：迁移学习、卷积神经网络、细粒度分类、可解释分析<br>主题章节一：迁移学习模型<br>主题章节二：细粒度分类：BCNN、NTSNet<br>主题章节三：可解释分析：CAM<br>实验：迁移学习实验结果搜集；BCNN、NTSNet对照组实验；CAM实验</p></blockquote><h5 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h5><p>剑指offer[68道题]</p><p>完成方式：</p><blockquote><p>剑指offer书本阅读一遍<br>Markdown文档记录每题笔记<br>IDEA上完成代码<br>项目地址：<a href="https://www.cnblogs.com/yongh/p/9637260.html" target="_blank" rel="noopener">https://www.cnblogs.com/yongh/p/9637260.html</a></p></blockquote><p>时间计划</p><table><thead><tr><th align="center">时间</th><th align="center">题目1</th><th align="center">题目2</th><th align="center">题目3</th><th align="center">时间</th><th align="center">题目1</th><th align="center">题目2</th><th align="center">题目3</th></tr></thead><tbody><tr><td align="center">2月10号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月11号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月12号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月13号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月14号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月15号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月16号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月17号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月18号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月19号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月20号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月21号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月22号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月23号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月24号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月25号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月26号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月27号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2月28号</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2月29号</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h5 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h5><p>Java秒杀系统方案优化 高性能高并发实战网课学习</p><blockquote><p>本机地址：E:\BaiduNetdiskDownload\Java秒杀系统方案优化 高性能高并发实战</p><p>项目地址：<a href="https://github.com/Grootzz/seckill" target="_blank" rel="noopener">https://github.com/Grootzz/seckill</a></p></blockquote><p>时间安排：一周（2月10号-2月16号）</p><table><thead><tr><th align="center">时间</th><th align="center">完成度</th></tr></thead><tbody><tr><td align="center">2月10号</td><td align="center"></td></tr><tr><td align="center">2月11号</td><td align="center"></td></tr><tr><td align="center">2月12号</td><td align="center"></td></tr><tr><td align="center">2月13号</td><td align="center"></td></tr><tr><td align="center">2月14号</td><td align="center"></td></tr><tr><td align="center">2月15号</td><td align="center"></td></tr><tr><td align="center">2月16号</td><td align="center"></td></tr></tbody></table><h5 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h5><p>项目回顾</p><blockquote><p>微信点餐</p><ol><li>代码回顾</li><li>文档回顾</li><li>项目地址：<a href="https://github.com/sqmax/springboot-project" target="_blank" rel="noopener">https://github.com/sqmax/springboot-project</a></li></ol><p>完成方式</p><ol><li>Markdown文档记录笔记</li></ol></blockquote><p>时间安排：一周（2月17号-2月23号）</p><table><thead><tr><th align="center">时间</th><th align="center">完成度</th></tr></thead><tbody><tr><td align="center">2月17号</td><td align="center"></td></tr><tr><td align="center">2月18号</td><td align="center"></td></tr><tr><td align="center">2月19号</td><td align="center"></td></tr><tr><td align="center">2月20号</td><td align="center"></td></tr><tr><td align="center">2月21号</td><td align="center"></td></tr><tr><td align="center">2月22号</td><td align="center"></td></tr><tr><td align="center">2月23号</td><td align="center"></td></tr></tbody></table><h5 id="任务五"><a href="#任务五" class="headerlink" title="任务五"></a>任务五</h5><p>2019秋招笔记汇总</p><p><img src="/2019/12/02/Postgraduate-Life/image-20200209213208386.png" alt="image-20200209213208386"></p><h5 id="任务六"><a href="#任务六" class="headerlink" title="任务六"></a>任务六</h5><p>网课刷题</p><p>E:\BaiduNetdiskDownload\玩转算法面试 从真题到思维全面提升算法思维</p><p>要求：</p><blockquote><p>IDEA完成代码<br>相关知识点笔记</p></blockquote><h5 id="任务七"><a href="#任务七" class="headerlink" title="任务七"></a>任务七</h5><p>待定</p><blockquote><p>E:\BaiduNetdiskDownload\RabbitMQ 完整版(慕课网)<br>E:\BaiduNetdiskDownload\SpringCloud Finchley三版本(M2+RELEASE+SR2)微服务实战</p></blockquote><h6 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h6><table><thead><tr><th align="center">时间</th><th align="center">任务</th></tr></thead><tbody><tr><td align="center">上午早饭后——做午饭</td><td align="center">任务一：写大论文</td></tr><tr><td align="center">午饭后——做晚饭</td><td align="center">任务三：看网课</td></tr><tr><td align="center"></td><td align="center">任务二：刷题</td></tr><tr><td align="center">晚饭后——睡觉</td><td align="center">任务五：整理笔记</td></tr><tr><td align="center"></td><td align="center">任务六：刷题网课</td></tr></tbody></table><h2 id="学习计划特别篇"><a href="#学习计划特别篇" class="headerlink" title="学习计划特别篇"></a>学习计划特别篇</h2><h3 id="任务清单"><a href="#任务清单" class="headerlink" title="任务清单"></a>任务清单</h3><ul><li><input checked disabled type="checkbox"> 大论文</li></ul><ul><li><input disabled type="checkbox"> 剑指offer[68道题]</li></ul><ul><li><input disabled type="checkbox"> Java秒杀系统方案优化 高性能高并发实战网课学习</li></ul><ul><li><input disabled type="checkbox"> 项目回顾：微信点餐</li></ul><ul><li><input disabled type="checkbox"> <p>2019秋招笔记汇总</p></li><li><input disabled type="checkbox"> <p>网课</p></li></ul><h3 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h3><h4 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h4><table><thead><tr><th align="center">周一</th><th align="center">周二</th><th align="center">周三</th><th align="center">周四</th><th align="center">周五</th><th align="center">周六</th><th align="center">周日</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center">04-08</td><td align="center">04-09</td><td align="center">04-10</td><td align="center">04-11</td><td align="center">04-12</td></tr><tr><td align="center">04-13</td><td align="center">04-14</td><td align="center">04-15</td><td align="center">04-16</td><td align="center">04-17</td><td align="center">04-18</td><td align="center">04-19</td></tr><tr><td align="center">04-20</td><td align="center">04-21</td><td align="center">04-22</td><td align="center">04-23</td><td align="center">04-24</td><td align="center">04-25</td><td align="center">04-26</td></tr><tr><td align="center">04-27</td><td align="center">04-28</td><td align="center">04-29</td><td align="center">04-30</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>三周时间，答辩加上面试准备，有点紧张。</p><h4 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h4><table><thead><tr><th align="center">时间</th><th align="center">安排</th></tr></thead><tbody><tr><td align="center">6：30 - 07：30</td><td align="center">一道算法题</td></tr><tr><td align="center">8：40 - 11：00</td><td align="center">Java笔记整理</td></tr><tr><td align="center">12：00 - 1：00</td><td align="center">娱乐</td></tr><tr><td align="center">1：00 - 2：00</td><td align="center">休息</td></tr><tr><td align="center">2：00 - 4：00</td><td align="center">三道算法题</td></tr><tr><td align="center">7：00 - 10：00</td><td align="center">视频课</td></tr><tr><td align="center">10：00 - 11：30</td><td align="center">英语</td></tr><tr><td align="center">12：00 - 6：30</td><td align="center">睡觉</td></tr></tbody></table><h4 id="算法题库"><a href="#算法题库" class="headerlink" title="算法题库"></a>算法题库</h4>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgraduate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experimental points</title>
      <link href="/2019/12/02/Experimental-points/"/>
      <url>/2019/12/02/Experimental-points/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>论文实验要点，一些简要的安装、执行和debug命令行记录</p></blockquote><a id="more"></a><h2 id="实验要点"><a href="#实验要点" class="headerlink" title="实验要点"></a>实验要点</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><h4 id="训练环境"><a href="#训练环境" class="headerlink" title="训练环境"></a>训练环境</h4><p>服务器：<code>192.168.71.215</code>，用户：<code>root</code>，文件位置：<code>home/zw/</code>，硬件：<code>Tesla P40</code>，conda虚拟环境：<code>zw</code>，版本：<code>python=3.6</code>，<code>tensorflow-gpu=1.14</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">keras                     2.2.5                    pypi_0    pypi</span><br><span class="line">keras-applications        1.0.8                    pypi_0    pypi</span><br><span class="line">keras-preprocessing       1.1.0                    pypi_0    pypi</span><br><span class="line">matplotlib                3.0.3                    pypi_0    pypi</span><br><span class="line">notebook                  6.0.3                    py36_0  </span><br><span class="line">numpy                     1.17.1                   pypi_0    pypi</span><br><span class="line">opencv-python             4.1.0.25                 pypi_0    pypi</span><br><span class="line">pandas                    0.25.3                   pypi_0    pypi</span><br><span class="line">pandoc                    2.2.3.2                       0  </span><br><span class="line">pandocfilters             1.4.2                    py36_1  </span><br><span class="line">pillow                    6.1.0                    pypi_0    pypi</span><br><span class="line">pip                       19.2.2                   py36_0  </span><br><span class="line">python                    3.6.9                h265db76_0  </span><br><span class="line">python-dateutil           2.8.0                    pypi_0    pypi</span><br><span class="line">scikit-image              0.15.0                   pypi_0    pypi</span><br><span class="line">scikit-learn              0.21.3                   pypi_0    pypi</span><br><span class="line">scipy                     1.3.1                    pypi_0    pypi</span><br><span class="line">sklearn                   0.0                      pypi_0    pypi</span><br><span class="line">tensorboard               1.14.0                   pypi_0    pypi</span><br><span class="line">tensorflow-estimator      1.14.0                   pypi_0    pypi</span><br><span class="line">tensorflow-gpu            1.14.0                   pypi_0    pypi</span><br></pre></td></tr></table></figure><h4 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h4><p>先查看它的各个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看各个版本</span></span><br><span class="line">conda search tensorflow</span><br><span class="line">conda search tensorflow-gpu</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看环境</span></span><br><span class="line">conda env list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建环境</span></span><br><span class="line">conda create -n xxxx python=X.X</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除环境</span></span><br><span class="line">conda remove -n XXXX --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制环境</span></span><br><span class="line">conda create -n XXXX --clone XXXX_new</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除没有用的包</span></span><br><span class="line">conda clean -p      </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除tar包</span></span><br><span class="line">conda clean -t      </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有的安装包及cache</span></span><br><span class="line">conda clean -y -all </span><br><span class="line"><span class="meta">#</span><span class="bash"> pip 安装本地包</span></span><br><span class="line">pip install   ～/Downloads/a.whl</span><br><span class="line"><span class="meta">#</span><span class="bash"> conda 安装本地包</span></span><br><span class="line">conda install --use-local  ~/Downloads/a.tar.bz2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加镜像</span></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h4 id="安装jupuyer-notebook"><a href="#安装jupuyer-notebook" class="headerlink" title="安装jupuyer notebook"></a>安装jupuyer notebook</h4><h5 id="安装IPython和jupyter"><a href="#安装IPython和jupyter" class="headerlink" title="安装IPython和jupyter"></a>安装IPython和jupyter</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install ipython</span><br><span class="line">sudo pip3 install jupyter notebook</span><br><span class="line">==================================================================</span><br><span class="line">ipython                   7.12.0           py36h5ca1d4c_0  </span><br><span class="line">ipython-genutils          0.2.0                    pypi_0    pypi</span><br><span class="line">ipython_genutils          0.2.0                    py36_0  </span><br><span class="line">jupyter                   1.0.0                    py36_7  </span><br><span class="line">jupyter-console           6.0.0                    pypi_0    pypi</span><br><span class="line">jupyter-core              4.6.3                    pypi_0    pypi</span><br><span class="line">jupyter_client            5.3.4                    py36_0  </span><br><span class="line">jupyter_console           6.1.0                      py_0  </span><br><span class="line">jupyter_core              4.6.1                    py36_0</span><br></pre></td></tr></table></figure><h5 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line">[y]</span><br></pre></td></tr></table></figure><h5 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h5><p>在终端输入ipython进入IPython交互环境，创建登录密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from notebook.auth import passwd</span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">Out[2]: 'sha1:***************************************'</span><br></pre></td></tr></table></figure><p>注意把生成的密文（Out[2]）保存起来，在接下来的配置中要用。</p><h5 id="修改默认配置文件"><a href="#修改默认配置文件" class="headerlink" title="修改默认配置文件"></a>修改默认配置文件</h5><p>打开<code>~/.jupyter/jupyter_notebook_config.py</code>配置文件，在文件开头添加如下代码（该文件很长，但都是注释行）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip='*'  # 就是设置所有ip皆可访问</span><br><span class="line">c.NotebookApp.password = u'sha1:*********************' #前边保存的密码信息</span><br><span class="line">c.NotebookApp.open_browser = False #禁止自动打开浏览器</span><br><span class="line">c.NotebookApp.port =8899 #随便指定一个端口，默认为8888</span><br><span class="line">c.NotebookApp.allow_root = True #是否允许notebook在root用户下运行.</span><br></pre></td></tr></table></figure><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>在终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><h5 id="windows的远程访问"><a href="#windows的远程访问" class="headerlink" title="windows的远程访问"></a>windows的远程访问</h5><p>登录地址为 <code>http://服务器IP:端口号</code></p><p>打开浏览器在地址栏直接输入<a href="http://192.168.71.215:8899，在登录页面中输入之前设置的IPython密码即可完成远程登录。" target="_blank" rel="noopener">http://192.168.71.215:8899，在登录页面中输入之前设置的IPython密码即可完成远程登录。</a></p><h4 id="展示环境"><a href="#展示环境" class="headerlink" title="展示环境"></a>展示环境</h4><p>本机，conda虚拟环境：<code>zw</code>，版本：<code>python=3.6</code>，<code>tensorflow-gpu=1.12</code></p><h3 id="CNN迁移学习要点"><a href="#CNN迁移学习要点" class="headerlink" title="CNN迁移学习要点"></a>CNN迁移学习要点</h3><h4 id="1-模型训练"><a href="#1-模型训练" class="headerlink" title="1.模型训练"></a>1.模型训练</h4><p><strong>模型构建</strong></p><p>对于模型输入图片大小，使用全局平均池化代替全连接层，可以输入不同规格大小的图片。</p><p>感觉这是一个可以在文中介绍一下的点。</p><blockquote><p>分析：<a href="https://www.zhihu.com/question/56688854" target="_blank" rel="noopener">知乎</a>，<a href="https://www.cnblogs.com/touch-skyer/p/9150039.html" target="_blank" rel="noopener">博客园</a></p></blockquote><h4 id="2-模型精度"><a href="#2-模型精度" class="headerlink" title="2.模型精度"></a>2.模型精度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential,load_model</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_generator = test_datagen.flow_from_directory(<span class="string">'/home/zw/isic_2019_dataset/test'</span>,target_size=(<span class="number">448</span>, <span class="number">448</span>),batch_size=<span class="number">64</span>,shuffle=<span class="literal">False</span>)</span><br><span class="line">nsteps=len(test_generator)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model = load_model("model/BCNN_keras/model-9c.h5")</span></span><br><span class="line"><span class="comment"># model.load_weights('./model/BCNN_keras/model-9c.h5')</span></span><br><span class="line"></span><br><span class="line">test_loss, test_acc = model.evaluate_generator(test_generator, steps=nsteps) </span><br><span class="line"><span class="comment"># test_loss, test_acc = model.evaluate(test_generator, steps=5) </span></span><br><span class="line">print(<span class="string">'test acc:'</span>, test_acc)</span><br></pre></td></tr></table></figure><h4 id="3-结果指标"><a href="#3-结果指标" class="headerlink" title="3.结果指标"></a>3.结果指标</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line"></span><br><span class="line">test_datagen = ImageDataGenerator(rescale=<span class="number">1.</span>/<span class="number">255</span>)</span><br><span class="line">test_generator = test_datagen.flow_from_directory(<span class="string">'/home/zw/isic_2019_dataset/test'</span>,target_size=(<span class="number">448</span>, <span class="number">448</span>),batch_size=<span class="number">64</span>,shuffle=<span class="literal">False</span>)</span><br><span class="line">nsteps=len(test_generator)</span><br><span class="line"></span><br><span class="line">y_true=test_generator.classes</span><br><span class="line">class_label=test_generator.class_indices.keys()</span><br><span class="line">test_generator.reset()</span><br><span class="line">y_pred = model.predict_generator(test_generator,steps=nsteps)</span><br><span class="line">y_pred_final = np.argmax(y_pred, axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Confusion Matrix'</span>)</span><br><span class="line">cm=confusion_matrix(y_true, y_pred_final)</span><br><span class="line">print(cm)</span><br><span class="line">print(<span class="string">'Classification Report'</span>)</span><br><span class="line">print(classification_report(y_true, y_pred_final, target_names=class_label))</span><br></pre></td></tr></table></figure><h4 id="4-图像展示"><a href="#4-图像展示" class="headerlink" title="4.图像展示"></a>4.图像展示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(cm, classes,</span></span></span><br><span class="line"><span class="function"><span class="params">                          normalize=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                          title=<span class="string">'Confusion matrix'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                          cmap=plt.cm.Blues)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        cm = cm.astype(<span class="string">'float'</span>) / cm.sum(axis=<span class="number">1</span>)[:, np.newaxis]</span><br><span class="line">        print(<span class="string">"Normalized confusion matrix"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Confusion matrix, without normalization'</span>)</span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">'nearest'</span>, cmap=cmap)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    tick_marks = np.arange(len(classes))</span><br><span class="line">    plt.xticks(tick_marks, classes, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(tick_marks, classes)</span><br><span class="line"></span><br><span class="line">    fmt = <span class="string">'.2f'</span> <span class="keyword">if</span> normalize <span class="keyword">else</span> <span class="string">'d'</span></span><br><span class="line">    thresh = cm.max() / <span class="number">2.</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(range(cm.shape[<span class="number">0</span>]), range(cm.shape[<span class="number">1</span>])):</span><br><span class="line">        plt.text(j, i, format(cm[i, j], fmt),</span><br><span class="line">                 horizontalalignment=<span class="string">"center"</span>,</span><br><span class="line">                 color=<span class="string">"white"</span> <span class="keyword">if</span> cm[i, j] &gt; thresh <span class="keyword">else</span> <span class="string">"black"</span>)</span><br><span class="line"></span><br><span class="line">    plt.ylabel(<span class="string">'True label'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Predicted label'</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">plot_confusion_matrix(cm, classes=class_label,title=<span class="string">'Confusion matrix, without normalization'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="TensorBoard展示"><a href="#TensorBoard展示" class="headerlink" title="TensorBoard展示"></a>TensorBoard展示</h3><p>本机展示，一行命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activate zw</span><br><span class="line">tensorboard --logdir=F:\CondaProjects\tensorboard\vgg-<span class="number">8</span> --host=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-本地远程访问服务器TensorBoard网页不能显示"><a href="#1-本地远程访问服务器TensorBoard网页不能显示" class="headerlink" title="1.本地远程访问服务器TensorBoard网页不能显示"></a>1.本地远程访问服务器TensorBoard网页不能显示</h4><p><strong>解决：</strong></p><p>本人使用的Xshell，需要对其进行设置，添加隧道监听，如下：</p><p><img src="/2019/12/02/Experimental-points/image-20191216111339014.png" alt="image-20191216111339014"></p><p><img src="/2019/12/02/Experimental-points/image-20191216111526736.png" alt="image-20191216111526736"></p><p>按以上数据修改保存，之后重新访问即可正常访问。</p><h4 id="2-python画混淆矩阵尺寸无法对齐"><a href="#2-python画混淆矩阵尺寸无法对齐" class="headerlink" title="2.python画混淆矩阵尺寸无法对齐"></a>2.python画混淆矩阵尺寸无法对齐</h4><p><strong>解决：</strong></p><p>更改matplotlib版本即可，本人使用的初始版本为3.1.1，重装3.0.3即可解决</p><p><img src="/2019/12/02/Experimental-points/image-20191216112226592.png" alt="image-20191216112226592">)<img src="/2019/12/02/Experimental-points/image-20191216112255034.png" alt="image-20191216112255034"></p><p>完美解决，感谢<a href="https://blog.csdn.net/xqlily/article/details/102518533" target="_blank" rel="noopener">博主</a></p><h2 id="论文梳理"><a href="#论文梳理" class="headerlink" title="论文梳理"></a>论文梳理</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h3 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h3>]]></content>
      
      
      <categories>
          
          <category> Postgraduate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm-Sort</title>
      <link href="/2019/11/29/Algorithm-Sort/"/>
      <url>/2019/11/29/Algorithm-Sort/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>八大排序算法</p></blockquote><a id="more"></a><h2 id="排序模板"><a href="#排序模板" class="headerlink" title="排序模板"></a>排序模板</h2><p>模板一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 八大排序算法</span></span><br><span class="line">    <span class="comment">// 这里暗喻数组a实现了接口Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">/*...*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">        Comparable t = a[i]; </span><br><span class="line">        a[i] = a[j]; </span><br><span class="line">        a[j] = t; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 在单行中打印数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) </span><br><span class="line">            StdOut.print(a[i] + <span class="string">" "</span>); </span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) </span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 八大排序算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回v是否小于w</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T v, T w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 在单行中打印数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) </span><br><span class="line">            StdOut.print(a[i] + <span class="string">" "</span>); </span><br><span class="line">        StdOut.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(T[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 测试数组元素是否有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) </span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例如选择排序在改模板下的用法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Example</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j], nums[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下文使用的均为模板一。</p><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>在序列完全有序时，该算法只需遍历一遍数组，不用执行任何交换操作，时间复杂度为O(N) 。在最坏情况下，冒泡排序要执行n(n-1)/2 次交换操作，时间复杂度为O(N2) 。在平均情况下，冒泡排序的时间复杂度也是O(N2)。</p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161126001352300-2027386210.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N -<span class="number">1</span> &amp;&amp; !isSort; i ++)&#123;</span><br><span class="line">            isSort = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j + <span class="number">1</span>], a[j]))&#123;</span><br><span class="line">                    isSort = <span class="keyword">false</span>;</span><br><span class="line">                    swap(a, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　根据上面这种冒泡实现，若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成；若是倒序，比较次数为 n-1+n-2+…+1=n(n-1)/2，交换次数和比较次数等值。所以，其时间复杂度依然为O(n2）。综合来看，冒泡排序性能还还是稍差于上面那种选择排序的。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="/2019/11/29/Algorithm-Sort/psb.png" alt="1565514415843"></p><p>简介：<strong>在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)&#123;<span class="comment">// 递归出口</span></span><br><span class="line">            swap(a, start, (<span class="keyword">int</span>) (Math.random() * (end - start + <span class="number">1</span>) + start));</span><br><span class="line">            <span class="comment">// 基准值</span></span><br><span class="line">            <span class="keyword">int</span> base = arr[start];</span><br><span class="line">            <span class="comment">// 排序下标</span></span><br><span class="line">            <span class="keyword">int</span> low = start; </span><br><span class="line">            <span class="keyword">int</span> high = end;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)&#123;<span class="comment">// while直到一个数</span></span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; base &lt;= a[high])<span class="comment">// 只移动下标</span></span><br><span class="line">                    high --;</span><br><span class="line">                a[low] = a[high];</span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= base)<span class="comment">// 只移动下标</span></span><br><span class="line">                    low ++;</span><br><span class="line">                a[high] = a[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// while结束（下标相同），把基数赋给低位置的元素（这里low=high）</span></span><br><span class="line">            a[low] = base;</span><br><span class="line">            <span class="comment">// 开始递归</span></span><br><span class="line">            <span class="comment">// 处理所有的小的数字</span></span><br><span class="line">            quickSort(a, start, low);</span><br><span class="line">            <span class="comment">// 处理所有的大的数字</span></span><br><span class="line">            quickSort(a, low+<span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，可以肯定的是对于大小为 N 的数组，的运行时间在 NlogN 的范围之内。归并排序也能做到这一点，但是快速排序一般会更快（尽管它的比较次数多 39%），因为它移动数据的次数更少。</p><blockquote><p>扩展：<a href="https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F?id=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">参考</a>，<a href="https://www.cnblogs.com/noKing/archive/2017/11/29/7922397.html" target="_blank" rel="noopener">优化</a></p></blockquote><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><p>简介：每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161126000335346-416319390.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++)&#123;</span><br><span class="line">            <span class="comment">// 挨个来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j --)&#123;</span><br><span class="line">                swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);在最坏情况下，时间复杂度依然为O(n2)。但是在数组元素随机排列的情况下，插入排序还是要优于上面两种排序的。</p><p>优化：在插入时使用二分法查找插入的位置。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161128110416068-1421707828.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 设置步长</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 小于 N 的最长步长</span></span><br><span class="line">        <span class="keyword">while</span>(h &lt; N / <span class="number">3</span>)</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>;<span class="comment">// 1, 4, 13, 40</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序、本质为插入排序</span></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 从步长 h 开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i ++)&#123;</span><br><span class="line">                <span class="comment">// 区间[0,h)内为有序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h)&#123;</span><br><span class="line">                    swap(a, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeletSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">int</span> min = i;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j], a[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 从标准输入读取字符串，将它们排序并输出 </span></span><br><span class="line">        String[] a = In.readStrings(); </span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>; </span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。其他算法会更善于利用输入的初始状态。</li><li>数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了N次交换 ——交换次数和数组的大小是线性关系。其他任何算法都不具备这个特征（大部分的增长数量级都是线性对数或是平方级别）。</li><li>简单选择排序通过上面优化之后，无论数组原始排列如何，比较次数是不变的；对于交换操作，在最好情况下也就是数组完全有序的时候，无需任何交换移动，在最差情况下，也就是数组倒序的时候，交换次数为n-1次。综合下来，时间复杂度为O(n2)</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217182750011-675658660.png" alt="img"></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217182857323-2092264199.png" alt="img"></p><p>该数组从逻辑上讲就是一个堆结构，公式描述为：</p><ul><li><p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]  </p></li><li><p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]  </p></li></ul><blockquote><p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><ol><li>假设给定无序序列结构如下</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217192038651-934327647.png" alt="img"></p><ol start="2"><li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217192209433-270379236.png" alt="img"></p><ol start="3"><li>找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217192854636-1823585260.png" alt="img"></p><ol start="4"><li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217193347886-1142194411.png" alt="img"></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><ol><li>将堆顶元素9和末尾元素4进行交换</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161217194207620-1455153342.png" alt="img"></p><ol start="2"><li>重新调整结构，使其继续满足堆定义</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161218153110495-1280388728.png" alt="img"></p><ol start="3"><li>再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</li></ol><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161218152929339-1114983222.png" alt="img"></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161218152348229-935654830.png" alt="img"></p><p>再简单总结下堆排序的基本思路：</p><ol><li><strong>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></li><li><strong>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></li><li><strong>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>简介：即将两个有序的数组归并成一个更大的有序数组。先（递归地）将它分成两半分别排序，然后将结果归并起来。归并排序最吸引人的性质是它能够保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；它的主要缺点则是它所需的额外空间和 N 成正比。</p><p>归并排序分为三个过程：</p><ul><li>将数列随意划分为两部分（在均匀划分时时间复杂度为O(NlogN) ）</li><li>递归地分别对两个子序列进行归并排序</li><li>合并两个子序列</li></ul><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161218163120151-452283750.png" alt="img"></p><p><img src="/2019/11/29/Algorithm-Sort/1024555-20161218194508761-468169540.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L == R) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        sort(arr, L, mid);</span><br><span class="line">        sort(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        merge(arr, L, mid, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = L;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">            temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环退出后，把剩余的元素依次填入到temp中</span></span><br><span class="line">        <span class="comment">// 以下两个while只有一个会执行</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid) &#123;</span><br><span class="line">            temp[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= R) &#123;</span><br><span class="line">            temp[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把最终的排序的结果复制给原数组</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            arr[L + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShareBike Project</title>
      <link href="/2019/11/25/ShareBike-Project/"/>
      <url>/2019/11/25/ShareBike-Project/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>《共享单车可视化项目》——基于Spring Boot快速构建项目。包含核心的SSM框架即：SpringMVC，Spring，Mybatis，基于Maven项目管理工具。</p></blockquote><a id="more"></a><p><strong>整个流程大致为</strong>：地址栏输入网址，前端控制器（Controller）拦截请求进行处理，调用服务层（Service）方法，服务层再调用数据访问层（Dao/Mapper）与数据库进行交互获取数据，进行返回。</p><h3 id="表结构："><a href="#表结构：" class="headerlink" title="表结构："></a>表结构：</h3><table><thead><tr><th>字段</th><th>类型</th><th>长度</th><th>为空</th><th>说明</th></tr></thead><tbody><tr><td>company_id</td><td>string</td><td>6</td><td>否</td><td>企业标识</td></tr><tr><td>bicycle_id</td><td>string</td><td>14</td><td>否</td><td>车辆标识</td></tr><tr><td>longitude</td><td>decimal</td><td>10</td><td>否</td><td>车辆实时坐标-经度</td></tr><tr><td>latitude</td><td>decimal</td><td>9</td><td>否</td><td>车辆实时坐标-纬度</td></tr><tr><td>lock_status</td><td>number</td><td>1</td><td>否</td><td>车锁状态：车锁实时状态 0-开，1-关</td></tr><tr><td>update_time</td><td>timestamp</td><td>15</td><td>否</td><td>更新时间：当前UTC时间戳</td></tr></tbody></table><p>补充：数据为单车当天采集的一小时内的位置信息。</p><h3 id="sql建表"><a href="#sql建表" class="headerlink" title="sql建表"></a>sql建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`history_bike_status`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`history_bike_status`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`bicycle_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`longitude`</span> <span class="built_in">decimal</span>(<span class="number">11</span>,<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`latitude`</span> <span class="built_in">decimal</span>(<span class="number">11</span>,<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`company_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lock_status`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`upload_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1058621</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sharebike?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.sstl.sharebikevisualization.model</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span></span><br></pre></td></tr></table></figure><h3 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogLatObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Double log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double lat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bicycleId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String companyId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLog</span><span class="params">(Double log)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.log = log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getLat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLat</span><span class="params">(Double lat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lat = lat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBicycleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bicycleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBicycleId</span><span class="params">(String bicycleId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bicycleId = bicycleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCompanyId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> companyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompanyId</span><span class="params">(String companyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.companyId = companyId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BikeMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库中单车数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT Count(DISTINCT bicycle_id) FROM history_bike_status"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">getTotalBikeAmount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6.13单车最后位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT longitude lng, latitude lat, bicycle_id "</span>  +</span><br><span class="line">            <span class="string">"FROM "</span> +</span><br><span class="line">            <span class="string">"( SELECT * FROM history_bike_status AS hbs WHERE hbs.company_id = #&#123;companyId&#125; AND "</span>+</span><br><span class="line">            <span class="string">"hbs.upload_time BETWEEN '2018-06-13 00:00:00' AND '2018-06-14 00:00:00' "</span> +</span><br><span class="line">            <span class="string">"    ORDER BY hbs.upload_time DESC "</span> +</span><br><span class="line">            <span class="string">" ) temp "</span>+</span><br><span class="line">            <span class="string">"GROUP BY bicycle_id"</span>)</span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyId</span><span class="params">(String companyId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchBeginDate, String searchEndDate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;LngLatObject&gt; <span class="title">getAllPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchBeginDate, String searchEndDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mybatis自定义查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getLastPositionByCompanyIdAndTime" resultMap="BaseResultMap"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">    longitude <span class="keyword">log</span>,</span><br><span class="line">    latitude lat,</span><br><span class="line">    bicycle_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        history_bike_status <span class="keyword">AS</span> hbs</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        hbs.company_id = <span class="comment">#&#123;arg0&#125; AND hbs.upload_time BETWEEN #&#123;arg1&#125;</span></span><br><span class="line">        <span class="keyword">AND</span> <span class="comment">#&#123;arg2&#125;</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> hbs.upload_time <span class="keyword">DESC</span></span><br><span class="line">    ) temp</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> bicycle_id</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="getAllPositionByCompanyIdAndTime" resultMap="BaseResultMap"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">    longitude <span class="keyword">log</span>,</span><br><span class="line">    latitude lat,</span><br><span class="line">    bicycle_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    history_bike_status <span class="keyword">AS</span> hbs</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">    hbs.company_id = <span class="comment">#&#123;arg0&#125;</span></span><br><span class="line">    <span class="keyword">AND</span> hbs.upload_time <span class="keyword">BETWEEN</span> <span class="comment">#&#123;arg1&#125;</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="comment">#&#123;arg2&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BikeServiceImpl</span> <span class="keyword">implements</span> <span class="title">BikeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BikeMapper bikeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTotalBikeAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getTotalBikeAmount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyId</span><span class="params">(String companyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getLastPositionByCompanyId(companyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getLastPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchDate)</span> </span>&#123;</span><br><span class="line">        String searchBeginDate = searchDate+<span class="string">" 00:00:00"</span>;</span><br><span class="line">        String searchEndDate = searchDate+<span class="string">" 23:59:59"</span>;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getLastPositionByCompanyIdAndTime(companyId,searchBeginDate,searchEndDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LngLatObject&gt; <span class="title">getAllPositionByCompanyIdAndTime</span><span class="params">(String companyId, String searchDate)</span> </span>&#123;</span><br><span class="line">        String searchBeginDate = searchDate+<span class="string">" 00:00:00"</span>;</span><br><span class="line">        String searchEndDate = searchDate+<span class="string">" 23:59:59"</span>;</span><br><span class="line">        <span class="keyword">return</span> bikeMapper.getAllPositionByCompanyIdAndTime(companyId,searchBeginDate,searchEndDate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BikeService bikeService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String SEARCH_DATE = <span class="string">"2018-06-13"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getOfoLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getOfoData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"05ofo"</span>,SEARCH_DATE);</span><br><span class="line">            System.out.println(SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getMobikeLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getMobikeData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatMobikeObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"07mobike"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatMobikeObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getXqLastPositionData"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getXqData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatXqObjects = bikeService.getLastPositionByCompanyIdAndTime(<span class="string">"01xqcx"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatXqObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getOfoAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getOfoAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"05ofo"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getMobikeAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getMobikeAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"07mobike"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/getXqAllPositionByTime"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getXqAllPositionByTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;LngLatObject&gt; lngLatOfoObjects = bikeService.getAllPositionByCompanyIdAndTime(<span class="string">"01xqcx"</span>,SEARCH_DATE);</span><br><span class="line">            r.setResult(lngLatOfoObjects);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面展示基于html实现，展示，分区域，弹窗等基本展示功能就完结。</p><p>下面是一个基于缩放的点聚合优化；</p><h3 id="点聚合优化"><a href="#点聚合优化" class="headerlink" title="点聚合优化"></a>点聚合优化</h3><p>问题：加载大量点时候卡顿</p><p>缘由： 点是否聚合的判断是计算其是否在聚合点的范围内；百度地图开发文档的操作是，是在加点过程中进行DOM操作</p><blockquote><p> document文档 object 对象 model模型，Dom翻译中文：文档对象模型 </p><p> dom操作就是元素节点操作,指的是改变html的标签结构，它有两种情况： </p><ol><li>移动现有标签的位置；</li><li>将新创建的标签插入到现有的标签中 。</li></ol></blockquote><p>解决： addMarker() 方法内不停的去进行dom操作是最主要的弊端，所以在只要批量加点时，屏蔽DOM操作，计算完成后，再一次遍历DOM显示，速度就极大提升。 </p><p>参考链接：<a href="https://www.zhihu.com/question/24023333" target="_blank" rel="noopener"> 知乎 </a>，<a href="https://www.cnblogs.com/hss-blog/p/9040666.html" target="_blank" rel="noopener">博客园</a>，<a href="https://www.cnblogs.com/lightnull/p/6184867.html" target="_blank" rel="noopener">博主</a></p><ul><li><input disabled type="checkbox"> 后续的各种可视化功能也没开发出来</li></ul>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecKill Project</title>
      <link href="/2019/11/25/SecKill-Project/"/>
      <url>/2019/11/25/SecKill-Project/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>基于SpringBoot框架构建热点商品秒杀项目，亮点： Redis实现分布式Session， 页面缓存，RabbitMQ+接口优化， 线上部署</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2019/11/25/SecKill-Project/image-20200411143727434.png" alt="image-20200411143727434"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144022521.png" alt="image-20200411144022521"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144315168.png" alt="image-20200411144315168"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144431348.png" alt="image-20200411144431348"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144519383.png" alt="image-20200411144519383"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144550929.png" alt="image-20200411144550929"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144619165.png" alt="image-20200411144619165"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144719295.png" alt="image-20200411144719295"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144759843.png" alt="image-20200411144759843"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144901230.png" alt="image-20200411144901230"></p><p><img src="/2019/11/25/SecKill-Project/image-20200411144938608.png" alt="image-20200411144938608"></p><h2 id="第一章小点"><a href="#第一章小点" class="headerlink" title="第一章小点"></a>第一章小点</h2><h3 id="Redis缓存key值统一设置规则，以及通用缓存Key封装方式。"><a href="#Redis缓存key值统一设置规则，以及通用缓存Key封装方式。" class="headerlink" title="Redis缓存key值统一设置规则，以及通用缓存Key封装方式。"></a>Redis缓存key值统一设置规则，以及通用缓存Key封装方式。</h3><p><img src="/2019/11/25/SecKill-Project/image-20200411154218042.png" alt="image-20200411154218042"></p><h2 id="第二章小点"><a href="#第二章小点" class="headerlink" title="第二章小点"></a>第二章小点</h2><h3 id="两次MD5"><a href="#两次MD5" class="headerlink" title="两次MD5"></a>两次MD5</h3><p><img src="/2019/11/25/SecKill-Project/image-20200411153913886.png" alt="image-20200411153913886"></p><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jquery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/jquery.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bootstrap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/bootstrap/css/bootstrap.min.css&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/bootstrap/js/bootstrap.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jquery-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/jquery-validation/jquery.validate.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/jquery-validation/localization/messages_zh.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- layer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/layer/layer.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- md5.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/md5.min.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- common.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/common.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@{/js/jquery.min.js}</code>中第一个<code>/</code>代表的是<code>resources/static</code>路径</p><p><code>required=&quot;true&quot; minlength=&quot;6&quot; maxlength=&quot;16&quot;</code>是<code>jquery-validator</code>提供的验证</p><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><p>前台传的参数与对象里的属性名字相同spring就会自动包装，比如前台传的参数名字是<code>mobile</code>和<code>password</code>，<code>LoginVo</code>对象里的属性名字也是<code>mobile</code>和<code>password</code>就会自动包装</p><p>ajax前端传入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 首先进行参数校验</span></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#loginForm"</span>).validate(&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 通过时回调方法</span></span></span><br><span class="line"><span class="actionscript">        submitHandler:<span class="function"><span class="keyword">function</span><span class="params">(form)</span></span>&#123;</span></span><br><span class="line">             doLogin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">doLogin</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// loading框</span></span></span><br><span class="line">g_showLoading();</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// md5加密密码</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> inputPass = $(<span class="string">"#password"</span>).val();<span class="comment">// 获取表单明文密码</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> salt = g_passsword_salt;<span class="comment">// 盐值</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> str = <span class="string">""</span>+salt.charAt(<span class="number">0</span>)+salt.charAt(<span class="number">2</span>) + inputPass +salt.charAt(<span class="number">5</span>) + salt.charAt(<span class="number">4</span>);</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> password = md5(str);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">// ajax异步提交</span></span></span><br><span class="line"><span class="javascript">$.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">url: <span class="string">"/login/do_login"</span>,</span></span><br><span class="line"><span class="actionscript">    type: <span class="string">"POST"</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 参数1直接从表单</span></span></span><br><span class="line"><span class="javascript">    mobile:$(<span class="string">"#mobile"</span>).val(),</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 参数2是经过md加密计算的</span></span></span><br><span class="line">    password: password</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 回调1</span></span></span><br><span class="line"><span class="actionscript">    success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 关框</span></span></span><br><span class="line">    layer.closeAll();</span><br><span class="line">    if(data.code == 0)&#123;</span><br><span class="line"><span class="actionscript">    layer.msg(<span class="string">"成功"</span>);</span></span><br><span class="line"><span class="actionscript">                 <span class="comment">// 跳转到商品列表页面</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.location.href=<span class="string">"/goods/to_list"</span>;</span></span><br><span class="line"><span class="actionscript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">    layer.msg(data.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 回调2</span></span></span><br><span class="line"><span class="actionscript">    error:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 关框</span></span></span><br><span class="line">    layer.closeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsr303参数校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;IsMobileValidator<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span>  <span class="title">IsMobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "手机号码格式错误"</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsMobileValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">IsMobile</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> required = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IsMobile constraintAnnotation)</span> </span>&#123;</span><br><span class="line">required = constraintAnnotation.required();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(required) &#123;</span><br><span class="line"><span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(value)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ValidatorUtil.isMobile(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用自定义的注解进行参数校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@IsMobile</span>   <span class="comment">// 自定义的验证器</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LoginVo [mobile="</span> + mobile + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(LoginController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/do_login"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title">doLogin</span><span class="params">(HttpServletResponse response, @Valid LoginVo loginVo)</span> </span>&#123;</span><br><span class="line">        log.info(loginVo.toString());</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        userService.login(response, loginVo);</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>service层为业务逻辑层，该层方法返回值一定要是跟业务相关逻辑（一些异常情况的返回最好不要出现在这里），对该层的异常采取的是抛出全局异常的方式，然后定义一个全局异常处理器。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> CodeMsg cm;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GlobalException</span><span class="params">(CodeMsg cm)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(cm.toString());</span><br><span class="line"><span class="keyword">this</span>.cm = cm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> CodeMsg <span class="title">getCm</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@ExceptionHandler</span>(value=Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Result</span>&lt;<span class="title">String</span>&gt; <span class="title">exceptionHandler</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> GlobalException) &#123;</span><br><span class="line">GlobalException ex = (GlobalException)e;</span><br><span class="line"><span class="keyword">return</span> Result.error(ex.getCm());</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">BindException ex = (BindException)e;</span><br><span class="line">List&lt;ObjectError&gt; errors = ex.getAllErrors();</span><br><span class="line">ObjectError error = errors.get(<span class="number">0</span>);</span><br><span class="line">String msg = error.getDefaultMessage();</span><br><span class="line"><span class="keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><p>现实情况下会有多台服务器，用户的请求会落在不同的服务器上。</p><p>第一步：目标是用户登录成功后将用户标识信息token存入cookie可供后续获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKI_NAME_TOKEN = <span class="string">"token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserDao miaoshaUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MiaoshaUser <span class="title">getById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> miaoshaUserDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MiaoshaUser <span class="title">getByToken</span><span class="params">(HttpServletResponse response, String token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一定要养成参数验证的习惯</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MiaoshaUser user = redisService.get(MiaoshaUserKey.token, token, MiaoshaUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//延长有效期</span></span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addCookie(response, token, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登陆业务逻辑</span></span><br><span class="line">    <span class="comment">// 包装登陆验证方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(HttpServletResponse response, LoginVo loginVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loginVo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异常时直接抛</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.SERVER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        String mobile = loginVo.getMobile();</span><br><span class="line">        String formPass = loginVo.getPassword();</span><br><span class="line">        <span class="comment">//判断手机号是否存在</span></span><br><span class="line">        MiaoshaUser user = getById(Long.parseLong(mobile));</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.MOBILE_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//验证密码</span></span><br><span class="line">        String dbPass = user.getPassword();</span><br><span class="line">        String saltDB = user.getSalt();</span><br><span class="line">        <span class="comment">// 计算从表单密码进行二次MD5后的值</span></span><br><span class="line">        String calcPass = MD5Util.formPassToDBPass(formPass, saltDB);</span><br><span class="line">        <span class="comment">// 两者比较</span></span><br><span class="line">        <span class="keyword">if</span>(!calcPass.equals(dbPass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成cookie</span></span><br><span class="line">        String token = UUIDUtil.uuid();</span><br><span class="line">        addCookie(response, token, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCookie</span><span class="params">(HttpServletResponse response, String token, MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">        redisService.set(MiaoshaUserKey.token, token, user);</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(COOKI_NAME_TOKEN, token);</span><br><span class="line">        cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便后续将token对应用户信息，，需要将用户信息存入第三方缓存中（redis）</p><blockquote><p><code>redisService.set(MiaoshaUserKey.token, token, user);</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当个对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(KeyPrefix prefix, String key,  Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            String  str = jedis.get(realKey);</span><br><span class="line">            T t =  stringToBean(str, clazz);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(KeyPrefix prefix, String key,  T value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            String str = beanToString(value);</span><br><span class="line">            <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">int</span> seconds =  prefix.expireSeconds();</span><br><span class="line">            <span class="keyword">if</span>(seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                jedis.set(realKey, str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                jedis.setex(realKey, seconds, str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否存在</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.exists(realKey);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">incr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.incr(realKey);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减少值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Long <span class="title">decr</span><span class="params">(KeyPrefix prefix, String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis =  jedisPool.getResource();</span><br><span class="line">            <span class="comment">//生成真正的key</span></span><br><span class="line">            String realKey  = prefix.getPrefix() + key;</span><br><span class="line">            <span class="keyword">return</span>  jedis.decr(realKey);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            returnToPool(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">String <span class="title">beanToString</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; clazz = value.getClass();</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Integer<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (String)value;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Long<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>+value;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">stringToBean</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span> || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">int</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Integer<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T)Integer.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T)str;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clazz == <span class="keyword">long</span><span class="class">.<span class="keyword">class</span> || <span class="title">clazz</span> </span>== Long<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  (T)Long.valueOf(str);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJavaObject(JSON.parseObject(str), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">returnToPool</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/25/SecKill-Project/image-20200412160254459.png" alt="image-20200412160254459"></p><p><img src="/2019/11/25/SecKill-Project/image-20200412160401214.png" alt="image-20200412160401214"></p><p>第二步：根据cookie中token信息确定用户。完成将一个token映射成一个用户MiaoshaUser</p><p><img src="/2019/11/25/SecKill-Project/image-20200412160901918.png" alt="image-20200412160901918"></p><p>上面两步就基本完成了分布式Session的概况。</p><blockquote><p>不足：</p><p>有效期设置。通过token获取用户信息时添加一个延长有限期的方法，即重新设置一个token，并将用户信息存入缓存中。（上述代码已经改过了）</p><p>并不优雅。这里是实现商品列表页(<code>to_list</code>)的用户登录判断，会有一大串代码，再到商品详情页（<code>/to_detail</code>）又会重新在验证一遍，很冗余。（上述代码已经改过了）</p></blockquote><p>第三步：直接将MiaoshaUser对象传入方法参数中</p><p><img src="/2019/11/25/SecKill-Project/image-20200412162746692.png" alt="image-20200412162746692"></p><p>这里方法是实现ArgumentResolver，SpringMVC中controller方法中会有很多参数，例如<code>HttpServletResponse response, Model model</code>，这些参数的值是怎么来的？</p><p><img src="/2019/11/25/SecKill-Project/image-20200412163350761.png" alt="image-20200412163350761"></p><p>就是由上面这个方法实现的。框架会回调这个方法向我们的controller方法中赋值。这里想将MiaoshaUser添加入参数中，就需要在<code>List&lt;HandlerMethodArgumentResolver&gt;</code>中添加一个该类型的参数占住位置。UserArgumentResolver定义该参数，WebConfig中注入该参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入进去</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加进参数列表中</span></span><br><span class="line">        argumentResolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义这个参数</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = parameter.getParameterType();</span><br><span class="line">        <span class="keyword">return</span> clazz== MiaoshaUser<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line">        String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;</span><br><span class="line">        <span class="keyword">return</span> userService.getByToken(response, token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookiName)</span> </span>&#123;</span><br><span class="line">        Cookie[]  cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(cookiName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/goods"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model, MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>list</code>方法变得很清爽，业务逻辑全部由<code>UserArgumentResolver</code>类中<code>resolveArgument</code>方法实现，以后更改获取session的方法也只需要到这个方法中变更。</p></blockquote><h2 id="第三章小点"><a href="#第三章小点" class="headerlink" title="第三章小点"></a>第三章小点</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><img src="/2019/11/25/SecKill-Project/image-20200412165739790.png" alt="image-20200412165739790"></p><p>秒杀商品和秒杀订单两张表同其余两个表分开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`goods`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  <span class="string">`goods_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品名称'</span>,</span><br><span class="line">  <span class="string">`goods_title`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品标题'</span>,</span><br><span class="line">  <span class="string">`goods_img`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品的图片'</span>,</span><br><span class="line">  <span class="string">`goods_detail`</span> longtext <span class="keyword">COMMENT</span> <span class="string">'商品的详情介绍'</span>,</span><br><span class="line">  <span class="string">`goods_price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'商品单价'</span>,</span><br><span class="line">  <span class="string">`goods_stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'商品库存，-1表示没有限制'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 秒杀表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`miaosha_goods`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'秒杀的商品表'</span>,</span><br><span class="line">  <span class="comment">-- 对应goods表id</span></span><br><span class="line">  <span class="string">`goods_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  <span class="string">`miaosha_price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀价'</span>,</span><br><span class="line">  <span class="string">`stock_count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀库存数量'</span>,</span><br><span class="line">  <span class="string">`start_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀开始时间'</span>,</span><br><span class="line">  <span class="string">`end_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀结束时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`goods_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  <span class="string">`delivery_addr_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'收获地址ID'</span>,</span><br><span class="line">  <span class="comment">-- 避免了从goods表中关联</span></span><br><span class="line">  <span class="string">`goods_name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'冗余过来的商品名称'</span>,</span><br><span class="line">  <span class="string">`goods_count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'商品数量'</span>,</span><br><span class="line">  <span class="string">`goods_price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">'0.00'</span> <span class="keyword">COMMENT</span> <span class="string">'商品单价'</span>,</span><br><span class="line">  <span class="string">`order_channel`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'1pc，2android，3ios'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成'</span>,</span><br><span class="line">  <span class="string">`create_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单的创建时间'</span>,</span><br><span class="line">  <span class="string">`pay_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1565</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 秒杀订单表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`miaosha_order`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`miaosha_order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`order_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单ID'</span>,</span><br><span class="line">  <span class="string">`goods_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`u_uid_gid`</span> (<span class="string">`user_id`</span>,<span class="string">`goods_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1551</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="Vo类介绍"><a href="#Vo类介绍" class="headerlink" title="Vo类介绍"></a>Vo类介绍</h3><p>例如：LoginVo，表示的是表单提交信息的包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@IsMobile</span></span><br><span class="line"><span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Length</span>(min=<span class="number">32</span>)</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"LoginVo [mobile="</span> + mobile + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GoodsVo是对商品和秒杀商品的包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsVo</span> <span class="keyword">extends</span> <span class="title">Goods</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Double miaoshaPrice;</span><br><span class="line"><span class="keyword">private</span> Integer stockCount;</span><br><span class="line"><span class="keyword">private</span> Date startDate;</span><br><span class="line"><span class="keyword">private</span> Date endDate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getStockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stockCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStockCount</span><span class="params">(Integer stockCount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stockCount = stockCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getStartDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> startDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartDate</span><span class="params">(Date startDate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startDate = startDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getEndDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> endDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEndDate</span><span class="params">(Date endDate)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.endDate = endDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">getMiaoshaPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> miaoshaPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMiaoshaPrice</span><span class="params">(Double miaoshaPrice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.miaoshaPrice = miaoshaPrice;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类包装类一般都是作为各层方法参数上的传输。</p><h3 id="页面倒计时"><a href="#页面倒计时" class="headerlink" title="页面倒计时"></a>页面倒计时</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> remainSeconds = $(<span class="string">"#remainSeconds"</span>).val();</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">if</span>(remainSeconds &gt; <span class="number">0</span>)&#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">"#countDown"</span>).text(remainSeconds - <span class="number">1</span>);</span><br><span class="line">            $(<span class="string">"#remainSeconds"</span>).val(remainSeconds - <span class="number">1</span>);</span><br><span class="line">            countDown();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainSeconds == <span class="number">0</span>)&#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀进行中"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span><br><span class="line">        $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀已经结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="秒杀执行"><a href="#秒杀执行" class="headerlink" title="秒杀执行"></a>秒杀执行</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"miaoshaForm"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/miaosha/do_miaosha"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"buyButton"</span>&gt;</span>立即秒杀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"goodsId"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;goods.id&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>页面form表单的提交，里面的数据就是商品的ID（<code>goodsId</code>），提交到的路径是：<code>/miaosha/do_miaosha</code></p></blockquote><p>之后就再MiaoshaController里面完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/goods"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_detail/&#123;goodsId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">detail</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @PathVariable(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line">        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">        model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startAt = goods.getStartDate().getTime();</span><br><span class="line">        <span class="keyword">long</span> endAt = goods.getEndDate().getTime();</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(now &lt; startAt ) &#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">            miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">            remainSeconds = (<span class="keyword">int</span>)((startAt - now )/<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(now &gt; endAt)&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">            miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">            remainSeconds = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">            miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">            remainSeconds = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">"miaoshaStatus"</span>, miaoshaStatus);</span><br><span class="line">        model.addAttribute(<span class="string">"remainSeconds"</span>, remainSeconds);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_detail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 减库存 下订单 写入秒杀订单</span></span><br><span class="line">        <span class="comment">// 在这里同样是对于库存的操作，通用方式是再service中引入service，不可直接使用别的dao</span></span><br><span class="line">        <span class="comment">// 所以，减库存操作由GoodsService完成</span></span><br><span class="line">        goodsService.reduceStock(goods);</span><br><span class="line">        <span class="comment">// order_info maiosha_order</span></span><br><span class="line">        <span class="comment">// 这里是生成两个表，订单表和秒杀订单表，返回的是订单表</span></span><br><span class="line">        <span class="keyword">return</span> orderService.createOrder(user, goods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MiaoshaOrder <span class="title">getMiaoshaOrderByUserIdGoodsId</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成订单</span></span><br><span class="line">    <span class="comment">// 事务</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">createOrder</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 商品订单</span></span><br><span class="line">        OrderInfo orderInfo = <span class="keyword">new</span> OrderInfo();</span><br><span class="line">        orderInfo.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">        orderInfo.setDeliveryAddrId(<span class="number">0L</span>);</span><br><span class="line">        orderInfo.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">        orderInfo.setGoodsId(goods.getId());</span><br><span class="line">        orderInfo.setGoodsName(goods.getGoodsName());</span><br><span class="line">        orderInfo.setGoodsPrice(goods.getMiaoshaPrice());</span><br><span class="line">        orderInfo.setOrderChannel(<span class="number">1</span>);</span><br><span class="line">        orderInfo.setStatus(<span class="number">0</span>);</span><br><span class="line">        orderInfo.setUserId(user.getId());</span><br><span class="line">        <span class="comment">// 订单id</span></span><br><span class="line">        <span class="keyword">long</span> orderId = orderDao.insert(orderInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 秒杀商品订单</span></span><br><span class="line">        MiaoshaOrder miaoshaOrder = <span class="keyword">new</span> MiaoshaOrder();</span><br><span class="line">        miaoshaOrder.setGoodsId(goods.getId());</span><br><span class="line">        miaoshaOrder.setOrderId(orderId);</span><br><span class="line">        miaoshaOrder.setUserId(user.getId());</span><br><span class="line">        orderDao.insertMiaoshaOrder(miaoshaOrder);</span><br><span class="line">        <span class="keyword">return</span> orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章小点"><a href="#第四章小点" class="headerlink" title="第四章小点"></a>第四章小点</h2><h3 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h3><p>并发测试：是指当并发达到多少时，网站的QPS是多少</p><blockquote><p>QPS每秒查询率(Query Per Second)<br>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p></blockquote><p>添加线程数</p><p><img src="/2019/11/25/SecKill-Project/image-20200413093504398.png" alt="image-20200413093504398"></p><p>配置一个Http请求的默认值</p><p><img src="/2019/11/25/SecKill-Project/image-20200413093703330.png" alt="image-20200413093703330"></p><p>配置http请求</p><p><img src="/2019/11/25/SecKill-Project/image-20200413093822087.png" alt="image-20200413093822087"></p><p>添加结果</p><p><img src="/2019/11/25/SecKill-Project/image-20200413094028350.png" alt="image-20200413094028350"></p><p>无任何优化的结果大概是在84的QPS</p><p><img src="/2019/11/25/SecKill-Project/image-20200413094559371.png" alt="image-20200413094559371"></p><p>使用<code>top</code>命令查看系统进程情况，load average参数已经严重过载，mysql进程占用CPU最多，所有的负载被其占尽。（说明瓶颈在这）</p><p>测试二：带参数的接口压测（新建一个获取用户信息的接口）</p><p><img src="/2019/11/25/SecKill-Project/image-20200413095116321.png" alt="image-20200413095116321"></p><p>多用户时，可以添加一个配置文件，然后引用配置文件即可。</p><p><img src="/2019/11/25/SecKill-Project/image-20200413095811883.png" alt="image-20200413095811883"></p><h3 id="命令行测试"><a href="#命令行测试" class="headerlink" title="命令行测试"></a>命令行测试</h3><p><img src="/2019/11/25/SecKill-Project/image-20200413095911842.png" alt="image-20200413095911842"></p><p>将程序打jar包：<code>F:/IdeaProjects/miaosha&gt;mvn clean package</code></p><p>分析一下这个包：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413103917986.png" alt="image-20200413103917986"></p><p>将jar包传到服务器上，开始运行：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413104155718.png" alt="image-20200413104155718"></p><blockquote><p>nohup会将运行结果输入到当前文件夹下的nohup.out文件中。</p></blockquote><p>查看nohup.out文件能看到程序运行结果</p><p><img src="/2019/11/25/SecKill-Project/image-20200413104418400.png" alt="image-20200413104418400"></p><p>将Jmeter中商品列表的接口测试另存为生成一个<code>.jmx</code>文件，上传到服务器中，开始在服务器中压测。</p><p><img src="/2019/11/25/SecKill-Project/image-20200413104845014.png" alt="image-20200413104845014"></p><p>结果：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413105137072.png" alt="image-20200413105137072"></p><blockquote><p>/goods_list接口、QPS1267、5000并发*10</p></blockquote><p><code>/do_miaosha</code>接口测试</p><p>先生成Jmeter配置文件</p><p><img src="/2019/11/25/SecKill-Project/image-20200413105533274.png" alt="image-20200413105533274"></p><p>同时将所需文件上传服务器，（将miaosha.jmx配置文件上传路径修改）执行</p><p><img src="/2019/11/25/SecKill-Project/image-20200413105730203.png" alt="image-20200413105730203"></p><p>结果：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413105926592.png" alt="image-20200413105926592"></p><p><img src="/2019/11/25/SecKill-Project/image-20200413110044182.png" alt="image-20200413110044182"></p><blockquote><p><code>/do_miaosha</code>接口、QPS1161、5000并发*10</p></blockquote><h3 id="Redis压测"><a href="#Redis压测" class="headerlink" title="Redis压测"></a>Redis压测</h3><p><img src="/2019/11/25/SecKill-Project/image-20200413095952307.png" alt="image-20200413095952307"></p><blockquote><p>方式为使用redis自带的压测工具benchmark。第一条命令行含义为模拟100个并发，100000个请求。第二条命令标识更改为100字节测试（第一条命令时3字节），-p表示简化结果输出</p></blockquote><p>结果：1秒能完成62695个请求</p><p><img src="/2019/11/25/SecKill-Project/image-20200413100301929.png" alt="image-20200413100301929"></p><p>第三条测试命令：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413100927007.png" alt="image-20200413100927007"></p><blockquote><p>表示只测试 <code>set</code>和<code>lpush</code>命令，同样是100000个请求。</p></blockquote><p>第四条命令：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413101034562.png" alt="image-20200413101034562"></p><blockquote><p>只测试指定的一条命令。</p></blockquote><h3 id="SpringBoot打war包"><a href="#SpringBoot打war包" class="headerlink" title="SpringBoot打war包"></a>SpringBoot打war包</h3><p>需求：将程序打成war包放到tomcat下运行。</p><p>方法：（pom引入两个依赖就好）</p><p><img src="/2019/11/25/SecKill-Project/image-20200413101304638.png" alt="image-20200413101304638"></p><blockquote><p>1是编译时依赖，2是war包插件</p></blockquote><p>最后还要修改一下主方法：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413102452760.png" alt="image-20200413102452760"></p><p>打包：<code>F:/IdeaProjects/miaosha&gt;mvn clean package</code></p><p>完成后会生成文件：miaosha.war</p><p>放入tomcat文件加下：</p><p><img src="/2019/11/25/SecKill-Project/image-20200413101943255.png" alt="image-20200413101943255"></p><blockquote><p>启动后会有个路径问题<code>/miaosha</code>，可以直接将war包放入ROOT文件下，或者将<code>/miaosha</code>部署为空。</p></blockquote><p>附加：linux删除<code>rm -rf file_name</code>；下载<code>sz file_name</code></p><h2 id="第五章-页面优化"><a href="#第五章-页面优化" class="headerlink" title="第五章-页面优化"></a>第五章-页面优化</h2><blockquote><p>页面级采用缓存</p></blockquote><h3 id="页面缓存-URL缓存-对象缓存"><a href="#页面缓存-URL缓存-对象缓存" class="headerlink" title="页面缓存+URL缓存+对象缓存"></a>页面缓存+URL缓存+对象缓存</h3><blockquote><p>粒度：页面缓存 &gt; URL缓存 &gt; 对象缓存</p></blockquote><h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>商品列表为例：</p><p>原：thymeleaf模板渲染<code>goods_list</code>，将数据放入<code>model</code>中，然后加载渲染</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model,MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">    model.addAttribute(<span class="string">"goodsList"</span>, goodsList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改：将整个页面作为一个对象存入缓存</p><p><img src="/2019/11/25/SecKill-Project/image-20200413143543547.png" alt="image-20200413143543547"></p><p>实现方式：<code>第三方取页面缓存 ? 输出 : 手动渲染页面（使用SpringBoot框架自带）+ 存入第三方缓存中</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/to_list"</span>, produces=<span class="string">"text/html"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="comment">// 取缓存</span></span><br><span class="line">    String html = redisService.get(GoodsKey.getGoodsList, <span class="string">""</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">    model.addAttribute(<span class="string">"goodsList"</span>, goodsList);</span><br><span class="line">    SpringWebContext ctx = <span class="keyword">new</span> SpringWebContext(request,response,</span><br><span class="line">                                                request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );</span><br><span class="line">    <span class="comment">// 手动渲染</span></span><br><span class="line">    html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_list"</span>, ctx);</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">        redisService.set(GoodsKey.getGoodsList, <span class="string">""</span>, html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常页面缓存有限期时间较短（60秒差不多了）</p><h4 id="URL缓存"><a href="#URL缓存" class="headerlink" title="URL缓存"></a>URL缓存</h4><p>与页面缓存原理一样，页面缓存类似于一个商品列表页的缓存，而URL缓存类似于商品详情页的缓存。</p><p>同样对于商品详情页面的缓存</p><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_detail/&#123;goodsId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">detail</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                     @PathVariable(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startAt = goods.getStartDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> endAt = goods.getEndDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; startAt ) &#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">        miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">        remainSeconds = (<span class="keyword">int</span>)((startAt - now )/<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(now &gt; endAt)&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">        miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">        remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">        miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">        remainSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"miaoshaStatus"</span>, miaoshaStatus);</span><br><span class="line">    model.addAttribute(<span class="string">"remainSeconds"</span>, remainSeconds);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"goods_detail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/to_detail2/&#123;goodsId&#125;"</span>,produces=<span class="string">"text/html"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">detail2</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                      @PathVariable(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取缓存</span></span><br><span class="line">    String html = redisService.get(GoodsKey.getGoodsDetail, <span class="string">""</span>+goodsId, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//手动渲染</span></span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startAt = goods.getStartDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> endAt = goods.getEndDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; startAt ) &#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">        miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">        remainSeconds = (<span class="keyword">int</span>)((startAt - now )/<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(now &gt; endAt)&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">        miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">        remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">        miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">        remainSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"miaoshaStatus"</span>, miaoshaStatus);</span><br><span class="line">    model.addAttribute(<span class="string">"remainSeconds"</span>, remainSeconds);</span><br><span class="line">    <span class="comment">//        return "goods_detail";</span></span><br><span class="line"></span><br><span class="line">    SpringWebContext ctx = <span class="keyword">new</span> SpringWebContext(request,response,</span><br><span class="line">                                                request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );</span><br><span class="line">    html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_detail"</span>, ctx);</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">        redisService.set(GoodsKey.getGoodsDetail, <span class="string">""</span>+goodsId, html);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h4><p>与上面两个的页面和URL缓存不同，这里的粒度最细，对象级别。例如上述的分布式session实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MiaoshaUser <span class="title">getByToken</span><span class="params">(HttpServletResponse response, String token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MiaoshaUser user = redisService.get(MiaoshaUserKey.token, token, MiaoshaUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//延长有效期</span></span><br><span class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addCookie(response, token, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="这里将修改秒杀用户获取方式："><a href="#这里将修改秒杀用户获取方式：" class="headerlink" title="这里将修改秒杀用户获取方式："></a>这里将修改秒杀用户获取方式：</h4><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MiaoshaUser <span class="title">getById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> miaoshaUserDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方式：<code>第三方取对象缓存 ? 输出 : 访问数据库取出 + 存入第三方缓存中</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MiaoshaUser <span class="title">getById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取缓存</span></span><br><span class="line">    MiaoshaUser user = redisService.get(MiaoshaUserKey.getById, <span class="string">""</span>+id, MiaoshaUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取数据库</span></span><br><span class="line">    user = miaoshaUserDao.getById(id);</span><br><span class="line">    <span class="comment">// 再存入缓存</span></span><br><span class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        redisService.set(MiaoshaUserKey.getById, <span class="string">""</span>+id, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：当有对对象的修改操作发生时，同时需要对缓存的更新。<strong>且顺序一定是先更新数据库数据，再更新缓存数据。</strong></p><p>这里涉及缓存和数据库数据一致性问题，最常用的逻辑如下：</p><ul><li><p><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p></li><li><p><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</p></li><li><p><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</p></li></ul><p>为什么呢？因为如果是先修改缓存，再数据库，当缓存失效时发生读操作，缓存无效，从数据库中读取脏数据，再存入缓存，后数据库更新，就会产生数据不一致现象。</p><blockquote><p>这里也可以解释，在service层中调用的一定是别的service而不是别的dao，因为在各个service层中可能会有缓存数据的存在。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如对对象密码进行修改时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updatePassword</span><span class="params">(String token, <span class="keyword">long</span> id, String formPass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取user</span></span><br><span class="line">    MiaoshaUser user = getById(id);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(CodeMsg.MOBILE_NOT_EXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.更新数据库</span></span><br><span class="line">    MiaoshaUser toBeUpdate = <span class="keyword">new</span> MiaoshaUser();</span><br><span class="line">    toBeUpdate.setId(id);</span><br><span class="line">    toBeUpdate.setPassword(MD5Util.formPassToDBPass(formPass, user.getSalt()));</span><br><span class="line">    miaoshaUserDao.update(toBeUpdate);</span><br><span class="line">    <span class="comment">// 2.处理缓存</span></span><br><span class="line">    <span class="comment">// 删缓存</span></span><br><span class="line">    redisService.delete(MiaoshaUserKey.getById, <span class="string">""</span>+id);</span><br><span class="line">    user.setPassword(toBeUpdate.getPassword());</span><br><span class="line">    <span class="comment">// 重存缓存</span></span><br><span class="line">    redisService.set(MiaoshaUserKey.token, token, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="这里将修改秒杀商品订单获取方式："><a href="#这里将修改秒杀商品订单获取方式：" class="headerlink" title="这里将修改秒杀商品订单获取方式："></a>这里将修改秒杀商品订单获取方式：</h4><p>引入第三方缓存，执行秒杀验证用户是否重复秒杀时不直接从数据库中查找订单。</p><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MiaoshaOrder <span class="title">getMiaoshaOrderByUserIdGoodsId</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MiaoshaOrder <span class="title">getMiaoshaOrderByUserIdGoodsId</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//return orderDao.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);</span></span><br><span class="line">    <span class="keyword">return</span> redisService.get(OrderKey.getMiaoshaOrderByUidGid, <span class="string">""</span>+userId+<span class="string">"_"</span>+goodsId, MiaoshaOrder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderInfo <span class="title">createOrder</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">    OrderInfo orderInfo = <span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo.setCreateDate(<span class="keyword">new</span> Date());</span><br><span class="line">    orderInfo.setDeliveryAddrId(<span class="number">0L</span>);</span><br><span class="line">    orderInfo.setGoodsCount(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setGoodsId(goods.getId());</span><br><span class="line">    orderInfo.setGoodsName(goods.getGoodsName());</span><br><span class="line">    orderInfo.setGoodsPrice(goods.getMiaoshaPrice());</span><br><span class="line">    orderInfo.setOrderChannel(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setStatus(<span class="number">0</span>);</span><br><span class="line">    orderInfo.setUserId(user.getId());</span><br><span class="line">    <span class="keyword">long</span> orderId = orderDao.insert(orderInfo);</span><br><span class="line">    MiaoshaOrder miaoshaOrder = <span class="keyword">new</span> MiaoshaOrder();</span><br><span class="line">    miaoshaOrder.setGoodsId(goods.getId());</span><br><span class="line">    miaoshaOrder.setOrderId(orderId);</span><br><span class="line">    miaoshaOrder.setUserId(user.getId());</span><br><span class="line">    orderDao.insertMiaoshaOrder(miaoshaOrder);</span><br><span class="line"></span><br><span class="line">    redisService.set(OrderKey.getMiaoshaOrderByUidGid, <span class="string">""</span>+user.getId()+<span class="string">"_"</span>+goods.getId(), miaoshaOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压测结果：QPS-2884</p><h3 id="页面静态化，前后端分离"><a href="#页面静态化，前后端分离" class="headerlink" title="页面静态化，前后端分离"></a>页面静态化，前后端分离</h3><p><strong>页面缓存与页面静态话的区别</strong></p><blockquote><p>页面静态化即所有页面都是纯HTML，通过JS和Ajax请求服务端拉取数据渲染页面。静态化后浏览器可以将HTML缓存在客户端，就不用重复下载页面数据，只需要下载动态数据即可，极大节省了网络流量。</p><p>而页面缓存仍是服务器端缓，仍需要从服务端下载数据，会耗费很大的流量。</p></blockquote><p><img src="/2019/11/25/SecKill-Project/image-20200413152722071.png" alt="image-20200413152722071"></p><p>实现，这里不用上面的技术实现，而是使用jquery模拟实现方式。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>案例1：使用的商品详情页面<code>/to_detail/{goodsId}</code>。</p><p>页面只存HTML（纯HTML），动态数据通过接口和服务端获取。</p><p>1.先将商品详情信息重新封装为GoodsDetailVo类，在详情页面方法中传递，该方法体中没有页面渲染操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/detail/&#123;goodsId&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;GoodsDetailVo&gt; <span class="title">detail</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    HttpServletResponse response, Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    @PathVariable(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="keyword">long</span> startAt = goods.getStartDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> endAt = goods.getEndDate().getTime();</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> remainSeconds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; startAt ) &#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">        miaoshaStatus = <span class="number">0</span>;</span><br><span class="line">        remainSeconds = (<span class="keyword">int</span>)((startAt - now )/<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(now &gt; endAt)&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">        miaoshaStatus = <span class="number">2</span>;</span><br><span class="line">        remainSeconds = -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">        miaoshaStatus = <span class="number">1</span>;</span><br><span class="line">        remainSeconds = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GoodsDetailVo vo = <span class="keyword">new</span> GoodsDetailVo();</span><br><span class="line">    vo.setGoods(goods);</span><br><span class="line">    vo.setUser(user);</span><br><span class="line">    vo.setRemainSeconds(remainSeconds);</span><br><span class="line">    vo.setMiaoshaStatus(miaoshaStatus);</span><br><span class="line">    <span class="keyword">return</span> Result.success(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.页面修改</p><p>案例2：秒杀执行静态化<code>/do_miaosha</code>。</p><p>页面只存HTML，动态数据通过接口和服务端获取。先将秒杀订单封装为MiaoshaOrderVo，传递到页面中。</p><blockquote><p>附加：浏览器缓存（的时间定义）<br>Pragma ：HTTP1.0<br>Expire ：HTTP1.0&amp;1.1 服务器标准时间（带时区）<br>Cache-Controller ：HTTP1.0&amp;1.1 客户端定义i时间（300秒）</p></blockquote><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/do_miaosha"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    <span class="keyword">int</span> stock = goods.getStockCount();</span><br><span class="line">    <span class="keyword">if</span>(stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">"errmsg"</span>, CodeMsg.MIAO_SHA_OVER.getMsg());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"miaosha_fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否已经秒杀到了</span></span><br><span class="line">    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">"errmsg"</span>, CodeMsg.REPEATE_MIAOSHA.getMsg());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"miaosha_fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">    OrderInfo orderInfo = miaoshaService.miaosha(user, goods);</span><br><span class="line">    model.addAttribute(<span class="string">"orderInfo"</span>, orderInfo);</span><br><span class="line">    model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"order_detail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/do_miaosha"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;OrderInfo&gt; <span class="title">miaosha</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断库存</span></span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<span class="comment">//10个商品，req1 req2</span></span><br><span class="line">    <span class="keyword">int</span> stock = goods.getStockCount();</span><br><span class="line">    <span class="keyword">if</span>(stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否已经秒杀到了</span></span><br><span class="line">    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">    OrderInfo orderInfo = miaoshaService.miaosha(user, goods);</span><br><span class="line">    <span class="keyword">return</span> Result.success(orderInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面动态调用服务端接口获取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doMiaosha</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">"/miaosha/do_miaosha"</span>,</span><br><span class="line">        type:<span class="string">"POST"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            goodsId:$(<span class="string">"#goodsId"</span>).val(),</span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.code == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">window</span>.location.href=<span class="string">"/order_detail.htm?orderId="</span>+data.data.id;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                layer.msg(data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            layer.msg(<span class="string">"客户端请求有误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">detail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> miaoshaStatus = detail.miaoshaStatus;</span><br><span class="line">    <span class="keyword">var</span>  remainSeconds = detail.remainSeconds;</span><br><span class="line">    <span class="keyword">var</span> goods = detail.goods;</span><br><span class="line">    <span class="keyword">var</span> user = detail.user;</span><br><span class="line">    <span class="keyword">if</span>(user)&#123;</span><br><span class="line">        $(<span class="string">"#userTip"</span>).hide();</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">"#goodsName"</span>).text(goods.goodsName);</span><br><span class="line">    $(<span class="string">"#goodsImg"</span>).attr(<span class="string">"src"</span>, goods.goodsImg);</span><br><span class="line">    $(<span class="string">"#startTime"</span>).text(<span class="keyword">new</span> <span class="built_in">Date</span>(goods.startDate).format(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br><span class="line">    $(<span class="string">"#remainSeconds"</span>).val(remainSeconds);</span><br><span class="line">    $(<span class="string">"#goodsId"</span>).val(goods.id);</span><br><span class="line">    $(<span class="string">"#goodsPrice"</span>).text(goods.goodsPrice);</span><br><span class="line">    $(<span class="string">"#miaoshaPrice"</span>).text(goods.miaoshaPrice);</span><br><span class="line">    $(<span class="string">"#stockCount"</span>).text(goods.stockCount);</span><br><span class="line">    countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//countDown();</span></span><br><span class="line">    getDetail();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDetail</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> goodsId = g_getQueryString(<span class="string">"goodsId"</span>);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">"/goods/detail/"</span>+goodsId,</span><br><span class="line">        type:<span class="string">"GET"</span>,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.code == <span class="number">0</span>)&#123;</span><br><span class="line">                render(data.data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                layer.msg(data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            layer.msg(<span class="string">"客户端请求有误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDown</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> remainSeconds = $(<span class="string">"#remainSeconds"</span>).val();</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">if</span>(remainSeconds &gt; <span class="number">0</span>)&#123;<span class="comment">//秒杀还没开始，倒计时</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span><br><span class="line">        $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀倒计时："</span>+remainSeconds+<span class="string">"秒"</span>);</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">"#countDown"</span>).text(remainSeconds - <span class="number">1</span>);</span><br><span class="line">            $(<span class="string">"#remainSeconds"</span>).val(remainSeconds - <span class="number">1</span>);</span><br><span class="line">            countDown();</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainSeconds == <span class="number">0</span>)&#123;<span class="comment">//秒杀进行中</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀进行中"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//秒杀已经结束</span></span><br><span class="line">        $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span><br><span class="line">        $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀已经结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>案例3：获取订单详情页面<code>/order/detail</code>。</p><p>页面只存HTML，动态数据通过接口和服务端获取。先将秒杀订单封装为MiaoshaOrderVo，传递到页面中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/detail"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;OrderDetailVo&gt; <span class="title">info</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @RequestParam(<span class="string">"orderId"</span>)</span> <span class="keyword">long</span> orderId) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    OrderInfo order = orderService.getOrderById(orderId);</span><br><span class="line">    <span class="keyword">if</span>(order == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.ORDER_NOT_EXIST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> goodsId = order.getGoodsId();</span><br><span class="line">    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">    OrderDetailVo vo = <span class="keyword">new</span> OrderDetailVo();</span><br><span class="line">    vo.setOrder(order);</span><br><span class="line">    vo.setGoods(goods);</span><br><span class="line">    <span class="keyword">return</span> Result.success(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>第一步：在减库存操作中修改Updat sql语句：</p><p><img src="/2019/11/25/SecKill-Project/image-20200414215009331.png" alt="image-20200414215009331"></p><blockquote><p>这是因为数据库会在Update执行时在执行语句的线程上加上锁，不会允许同时有多个线程执行。</p></blockquote><p>第二部：设置同一用户不允许重买，即同一个用户秒杀到两个商品。</p><p>解决方法：利用数据库的唯一索引，在<code>miaosha_order</code>表中调价一个由<code>用户id+商品id</code>的唯一索引。</p><p><img src="/2019/11/25/SecKill-Project/image-20200414215351562.png" alt="image-20200414215351562"></p><p><img src="/2019/11/25/SecKill-Project/image-20200414215703666.png" alt="image-20200414215703666"></p><blockquote><p>这样在创建订单的方法中，生成秒杀订单过程中如果有唯一索引冲突就会报错然后由于springboot的事务机制产生回滚。</p></blockquote><p>总结：</p><p><img src="/2019/11/25/SecKill-Project/image-20200414222739879.png" alt="image-20200414222739879"></p><h3 id="静态资源优化"><a href="#静态资源优化" class="headerlink" title="静态资源优化"></a>静态资源优化</h3><p><img src="/2019/11/25/SecKill-Project/image-20200414220416041.png" alt="image-20200414220416041"></p><p>总结：并发问题的根源在于数据库的访问，最有效的解决方式时添加缓存，缓存的种类有很多，从用户的角度来说，从用户发起请求，在浏览器上可以通过页面的静态化将页面缓存在用户的浏览器端，在请求到达服务器之前，可以布置一些CDN节点，让请求访问CDN节点，再发来的请求访问时，可以在Nginx上添加缓存，再过来时可以在应用程序上添加缓存，即页面缓存。更细粒度的就是对象缓存，一直到最后的数据库缓存。</p><h2 id="第六章-接口优化"><a href="#第六章-接口优化" class="headerlink" title="第六章-接口优化"></a>第六章-接口优化</h2><blockquote><p>服务级接口优化</p><p>总体思路：较少数据库访问。</p></blockquote><p><img src="/2019/11/25/SecKill-Project/image-20200511211400986.png" alt="image-20200511211400986"></p><p><img src="/2019/11/25/SecKill-Project/image-20200414223030637.png" alt="image-20200414223030637"></p><p><img src="/2019/11/25/SecKill-Project/image-20200414223148943.png" alt="image-20200414223148943"></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装erlang</p><p>安装RebbitMQ</p><blockquote><p>涉及一些linux命令行可供参考</p></blockquote><h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><p><img src="/2019/11/25/SecKill-Project/image-20200414230810058.png" alt="image-20200414230810058"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MIAOSHA_QUEUE = <span class="string">"miaosha.queue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"queue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_QUEUE1 = <span class="string">"topic.queue1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_QUEUE2 = <span class="string">"topic.queue2"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_QUEUE = <span class="string">"header.queue"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_EXCHANGE = <span class="string">"topicExchage"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FANOUT_EXCHANGE = <span class="string">"fanoutxchage"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADERS_EXCHANGE = <span class="string">"headersExchage"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Direct模式 交换机Exchange</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Topic模式 交换机Exchange</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE1, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">topicQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TOPIC_QUEUE2, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOPIC_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchage()).with(<span class="string">"topic.key1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchage()).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fanout模式 交换机Exchange</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(FANOUT_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">FanoutBinding1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1()).to(fanoutExchage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">FanoutBinding2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(fanoutExchage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Header模式 交换机Exchange</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeadersExchange <span class="title">headersExchage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeadersExchange(HEADERS_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">headerQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(HEADER_QUEUE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">headerBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"header1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        map.put(<span class="string">"header2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(headerQueue1()).to(headersExchage()).whereAll(map).match();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQSender<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示一个发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        String msg = RedisService.beanToString(message);</span><br><span class="line">        log.info(<span class="string">"send message:"</span>+msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送真实秒杀消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMiaoshaMessage</span><span class="params">(MiaoshaMessage mm)</span> </span>&#123;</span><br><span class="line">        String msg = RedisService.beanToString(mm);</span><br><span class="line">        log.info(<span class="string">"send message:"</span>+msg);</span><br><span class="line">        amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(MQReceiver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaService miaoshaService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示接受消息</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues=MQConfig.QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message:"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 秒杀消息出队</span></span><br><span class="line">    <span class="comment">// 类似之前的controller方法执行秒杀任务</span></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues=MQConfig.MIAOSHA_QUEUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive message:"</span>+message);</span><br><span class="line">        MiaoshaMessage mm  = RedisService.stringToBean(message, MiaoshaMessage<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 获取秒杀用户和秒杀商品</span></span><br><span class="line">        MiaoshaUser user = mm.getUser();</span><br><span class="line">        <span class="keyword">long</span> goodsId = mm.getGoodsId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查库存，这里访问的是DB</span></span><br><span class="line">        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);</span><br><span class="line">        <span class="keyword">int</span> stock = goods.getStockCount();</span><br><span class="line">        <span class="keyword">if</span>(stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否已经秒杀到了</span></span><br><span class="line">        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">        <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">        miaoshaService.miaosha(user, goods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a>秒杀优化</h3><blockquote><p>目标：将系统的同步下单改为异步下单</p></blockquote><ol><li>商品库存加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/miaosha"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaController</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统初始化</span></span><br><span class="line"><span class="comment"> * 系统启动时加载秒杀商品库存数量到redis中</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();</span><br><span class="line">        <span class="keyword">if</span>(goodsList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(GoodsVo goods : goodsList) &#123;</span><br><span class="line">            <span class="comment">// 存入redis</span></span><br><span class="line">            redisService.set(GoodsKey.getMiaoshaGoodsStock, <span class="string">""</span>+goods.getId(), goods.getStockCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>redis预减库存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/do_miaosha"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Integer&gt; <span class="title">miaosha</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// redis预减库存，返回减后的值</span></span><br><span class="line">    <span class="keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="string">""</span>+goodsId);<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">if</span>(stock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经秒杀到了</span></span><br><span class="line">    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="comment">// 秒杀消息对象</span></span><br><span class="line">    <span class="comment">// 这里需要将上文的MQ配置更改</span></span><br><span class="line">    MiaoshaMessage mm = <span class="keyword">new</span> MiaoshaMessage();</span><br><span class="line">    mm.setUser(user);</span><br><span class="line">    mm.setGoodsId(goodsId);</span><br><span class="line">    sender.sendMiaoshaMessage(mm);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="number">0</span>);<span class="comment">// 排队中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再修改一下秒杀代码，</p><p>原代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">    goodsService.reduceStock(goods);</span><br><span class="line">    <span class="comment">//order_info maiosha_order</span></span><br><span class="line">    <span class="keyword">return</span> orderService.createOrder(user, goods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">    <span class="keyword">boolean</span> success = goodsService.reduceStock(goods);</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">        <span class="comment">//order_info maiosha_order</span></span><br><span class="line">        <span class="keyword">return</span> orderService.createOrder(user, goods);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        setGoodsOver(goods.getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>前端的代码修改</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getMiaoshaResult</span><span class="params">(goodsId)</span></span>&#123;</span></span><br><span class="line">        g_showLoading();</span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">"/miaosha/result"</span>,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">"GET"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                goodsId:$(<span class="string">"#goodsId"</span>).val(),</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line">                if(data.code == 0)&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> result = data.data;</span></span><br><span class="line">                    if(result &lt; 0)&#123;</span><br><span class="line"><span class="actionscript">                        layer.msg(<span class="string">"对不起，秒杀失败"</span>);</span></span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;<span class="comment">//继续轮询</span></span></span><br><span class="line"><span class="actionscript">                        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                            getMiaoshaResult(goodsId);</span><br><span class="line">                        &#125;, 50);</span><br><span class="line"><span class="actionscript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">                        layer.confirm(<span class="string">"恭喜你，秒杀成功！查看订单？"</span>, &#123;btn:[<span class="string">"确定"</span>,<span class="string">"取消"</span>]&#125;,</span></span><br><span class="line"><span class="actionscript">                                      <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">window</span>.location.href=<span class="string">"/order_detail.htm?orderId="</span>+result;</span></span><br><span class="line">                        &#125;,</span><br><span class="line"><span class="actionscript">                                      <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">                            layer.closeAll();</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    layer.msg(data.msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            error:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                layer.msg(<span class="string">"客户端请求有误"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">doMiaosha</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">"/miaosha/do_miaosha"</span>,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">"POST"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                goodsId:$(<span class="string">"#goodsId"</span>).val(),</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line">                if(data.code == 0)&#123;</span><br><span class="line"><span class="actionscript">                    <span class="comment">//window.location.href="/order_detail.htm?orderId="+data.data.id;</span></span></span><br><span class="line"><span class="javascript">                    getMiaoshaResult($(<span class="string">"#goodsId"</span>).val());</span></span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    layer.msg(data.msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            error:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                layer.msg(<span class="string">"客户端请求有误"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(detail)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> miaoshaStatus = detail.miaoshaStatus;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span>  remainSeconds = detail.remainSeconds;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> goods = detail.goods;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> user = detail.user;</span></span><br><span class="line">        if(user)&#123;</span><br><span class="line"><span class="javascript">            $(<span class="string">"#userTip"</span>).hide();</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        $(<span class="string">"#goodsName"</span>).text(goods.goodsName);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#goodsImg"</span>).attr(<span class="string">"src"</span>, goods.goodsImg);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#startTime"</span>).text(<span class="keyword">new</span> <span class="built_in">Date</span>(goods.startDate).format(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#remainSeconds"</span>).val(remainSeconds);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#goodsId"</span>).val(goods.id);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#goodsPrice"</span>).text(goods.goodsPrice);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#miaoshaPrice"</span>).text(goods.miaoshaPrice);</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#stockCount"</span>).text(goods.stockCount);</span></span><br><span class="line">        countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//countDown();</span></span></span><br><span class="line">        getDetail();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getDetail</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> goodsId = g_getQueryString(<span class="string">"goodsId"</span>);</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">"/goods/detail/"</span>+goodsId,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">"GET"</span>,</span></span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line">                if(data.code == 0)&#123;</span><br><span class="line">                    render(data.data);</span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    layer.msg(data.msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            error:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                layer.msg(<span class="string">"客户端请求有误"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">countDown</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> remainSeconds = $(<span class="string">"#remainSeconds"</span>).val();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> timeout;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(remainSeconds &gt; <span class="number">0</span>)&#123;<span class="comment">//秒杀还没开始，倒计时</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀倒计时："</span>+remainSeconds+<span class="string">"秒"</span>);</span></span><br><span class="line"><span class="actionscript">            timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#countDown"</span>).text(remainSeconds - <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#remainSeconds"</span>).val(remainSeconds - <span class="number">1</span>);</span></span><br><span class="line">                countDown();</span><br><span class="line">            &#125;,1000);</span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainSeconds == <span class="number">0</span>)&#123;<span class="comment">//秒杀进行中</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">false</span>);</span></span><br><span class="line">            if(timeout)&#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀进行中"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//秒杀已经结束</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀已经结束"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>客户端轮询请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * orderId：成功</span></span><br><span class="line"><span class="comment">     * -1：秒杀失败</span></span><br><span class="line"><span class="comment">     * 0： 排队中</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/result"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title">miaoshaResult</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> result  =miaoshaService.getMiaoshaResult(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">return</span> Result.success(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>设置内存标记</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Long, Boolean&gt; localOverMap =  <span class="keyword">new</span> HashMap&lt;Long, Boolean&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/do_miaosha"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Integer&gt; <span class="title">miaosha</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内存标记，减少redis访问</span></span><br><span class="line">    <span class="keyword">boolean</span> over = localOverMap.get(goodsId);</span><br><span class="line">    <span class="keyword">if</span>(over) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redis预减库存</span></span><br><span class="line">    <span class="keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="string">""</span>+goodsId);<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">if</span>(stock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        localOverMap.put(goodsId, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经秒杀到了</span></span><br><span class="line">    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="comment">// 秒杀消息对象</span></span><br><span class="line">    MiaoshaMessage mm = <span class="keyword">new</span> MiaoshaMessage();</span><br><span class="line">    mm.setUser(user);</span><br><span class="line">    mm.setGoodsId(goodsId);</span><br><span class="line">    sender.sendMiaoshaMessage(mm);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="number">0</span>);<span class="comment">//排队中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h3><p>配置文件的主要参数</p><p><img src="/2019/11/25/SecKill-Project/image-20200415211335146.png" alt="image-20200415211335146"></p><blockquote><p>Nginx监听服务器80端口，将所有请求反向代理（<code>proxy_pass</code>）给<code>http://server_pool_miaosha</code>，在<code>http://server_pool_miaosha</code>中可以配置多个tomcat服务器接受请求，这样就实现了横向扩展。<code>weight</code>参数表示的是请求分配的比重，即负载均衡的实现。<code>max_fails</code>和<code>fail_timeout</code>是一种服务器探活机制，</p></blockquote><h2 id="第七章-安全优化"><a href="#第七章-安全优化" class="headerlink" title="第七章-安全优化"></a>第七章-安全优化</h2><h3 id="秒杀接口隐藏"><a href="#秒杀接口隐藏" class="headerlink" title="秒杀接口隐藏"></a>秒杀接口隐藏</h3><p><img src="/2019/11/25/SecKill-Project/image-20200511214319724.png" alt="image-20200511214319724"></p><blockquote><p>原因：因为我们的前端地址代码都是透明的，很容易受到攻击</p></blockquote><ol><li>前端代码修改</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"miaoshaForm"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/miaosha/do_miaosha"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"buyButton"</span> <span class="attr">onclick</span>=<span class="string">"getMiaoshaPath()"</span>&gt;</span>立即秒杀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"goodsId"</span>  <span class="attr">id</span>=<span class="string">"goodsId"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"goodsId"</span>  <span class="attr">id</span>=<span class="string">"goodsId"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getMiaoshaPath</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> goodsId = $(<span class="string">"#goodsId"</span>).val();</span></span><br><span class="line">        g_showLoading();</span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url:<span class="string">"/miaosha/path"</span>,</span></span><br><span class="line"><span class="actionscript">            type:<span class="string">"GET"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                goodsId:goodsId,</span><br><span class="line"><span class="javascript">                verifyCode:$(<span class="string">"#verifyCode"</span>).val()</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line">                if(data.code == 0)&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> path = data.data;</span></span><br><span class="line">                    doMiaosha(path);</span><br><span class="line"><span class="actionscript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">                    layer.msg(data.msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            error:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                layer.msg(<span class="string">"客户端请求有误"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>后端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;path&#125;/do_miaosha"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Integer&gt; <span class="title">miaosha</span><span class="params">(Model model,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId,</span></span><br><span class="line"><span class="function">                               @<span class="title">PathVariable</span><span class="params">(<span class="string">"path"</span>)</span> String path) </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证path</span></span><br><span class="line">    <span class="keyword">boolean</span> check = miaoshaService.checkPath(user, goodsId, path);</span><br><span class="line">    <span class="keyword">if</span>(!check)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内存标记，减少redis访问</span></span><br><span class="line">    <span class="keyword">boolean</span> over = localOverMap.get(goodsId);</span><br><span class="line">    <span class="keyword">if</span>(over) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预减库存</span></span><br><span class="line">    <span class="keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, <span class="string">""</span>+goodsId);<span class="comment">//10</span></span><br><span class="line">    <span class="keyword">if</span>(stock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        localOverMap.put(goodsId, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否已经秒杀到了</span></span><br><span class="line">    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);</span><br><span class="line">    <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    MiaoshaMessage mm = <span class="keyword">new</span> MiaoshaMessage();</span><br><span class="line">    mm.setUser(user);</span><br><span class="line">    mm.setGoodsId(goodsId);</span><br><span class="line">    sender.sendMiaoshaMessage(mm);</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="number">0</span>);<span class="comment">//排队中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/path"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getMiaoshaPath</span><span class="params">(HttpServletRequest request, MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId,</span></span><br><span class="line"><span class="function">                                    ) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String path  =miaoshaService.createMiaoshaPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> Result.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形验证"><a href="#图形验证" class="headerlink" title="图形验证"></a>图形验证</h3><p><img src="/2019/11/25/SecKill-Project/image-20200415213915167.png" alt="image-20200415213915167"></p><ol><li>前端，在秒杀进行中情况下显示图形验证码</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-inline"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"verifyCodeImg"</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"32"</span>  <span class="attr">style</span>=<span class="string">"display:none"</span> <span class="attr">onclick</span>=<span class="string">"refreshVerifyCode()"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"verifyCode"</span>  <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--点击秒杀返回的是获取接口参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"buyButton"</span><span class="attr">onclick</span>=<span class="string">"getMiaoshaPath()"</span>&gt;</span>立即秒杀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">countDown</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> remainSeconds = $(<span class="string">"#remainSeconds"</span>).val();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> timeout;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(remainSeconds &gt; <span class="number">0</span>)&#123;<span class="comment">//秒杀还没开始，倒计时</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀倒计时："</span>+remainSeconds+<span class="string">"秒"</span>);</span></span><br><span class="line"><span class="actionscript">            timeout = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#countDown"</span>).text(remainSeconds - <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                $(<span class="string">"#remainSeconds"</span>).val(remainSeconds - <span class="number">1</span>);</span></span><br><span class="line">                countDown();</span><br><span class="line">            &#125;,1000);</span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(remainSeconds == <span class="number">0</span>)&#123;<span class="comment">//秒杀进行中</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">false</span>);</span></span><br><span class="line">            if(timeout)&#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀进行中"</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#verifyCodeImg"</span>).attr(<span class="string">"src"</span>, <span class="string">"/miaosha/verifyCode?goodsId="</span>+$(<span class="string">"#goodsId"</span>).val());</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#verifyCodeImg"</span>).show();</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#verifyCode"</span>).show();</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//秒杀已经结束</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#buyButton"</span>).attr(<span class="string">"disabled"</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#miaoshaTip"</span>).html(<span class="string">"秒杀已经结束"</span>);</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#verifyCodeImg"</span>).hide();</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#verifyCode"</span>).hide();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">refreshVerifyCode</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#verifyCodeImg"</span>).attr(<span class="string">"src"</span>, <span class="string">"/miaosha/verifyCode?goodsId="</span>+$(<span class="string">"#goodsId"</span>).val()+<span class="string">"&amp;timestamp="</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>后端对应验证码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/verifyCode"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getMiaoshaVerifyCod</span><span class="params">(HttpServletResponse response,MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedImage image  = miaoshaService.createVerifyCode(user, goodsId);</span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        ImageIO.write(image, <span class="string">"JPEG"</span>, out);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.MIAOSHA_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>验证</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/path"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getMiaoshaPath</span><span class="params">(HttpServletRequest request, MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId,</span></span><br><span class="line"><span class="function">                                     @<span class="title">RequestParam</span><span class="params">(value=<span class="string">"verifyCode"</span>, defaultValue=<span class="string">"0"</span>)</span><span class="keyword">int</span> verifyCode</span></span><br><span class="line"><span class="function">                                    ) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> check = miaoshaService.checkVerifyCode(user, goodsId, verifyCode);</span><br><span class="line">    <span class="keyword">if</span>(!check) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);</span><br><span class="line">    &#125;</span><br><span class="line">    String path  =miaoshaService.createMiaoshaPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> Result.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的MiaoshaService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//减库存 下订单 写入秒杀订单</span></span><br><span class="line">        <span class="keyword">boolean</span> success = goodsService.reduceStock(goods);</span><br><span class="line">        <span class="keyword">if</span>(success) &#123;</span><br><span class="line">            <span class="comment">//order_info maiosha_order</span></span><br><span class="line">            <span class="keyword">return</span> orderService.createOrder(user, goods);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            setGoodsOver(goods.getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMiaoshaResult</span><span class="params">(Long userId, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(userId, goodsId);</span><br><span class="line">        <span class="keyword">if</span>(order != <span class="keyword">null</span>) &#123;<span class="comment">//秒杀成功</span></span><br><span class="line">            <span class="keyword">return</span> order.getOrderId();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isOver = getGoodsOver(goodsId);</span><br><span class="line">            <span class="keyword">if</span>(isOver) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGoodsOver</span><span class="params">(Long goodsId)</span> </span>&#123;</span><br><span class="line">        redisService.set(MiaoshaKey.isGoodsOver, <span class="string">""</span>+goodsId, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getGoodsOver</span><span class="params">(<span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisService.exists(MiaoshaKey.isGoodsOver, <span class="string">""</span>+goodsId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(List&lt;GoodsVo&gt; goodsList)</span> </span>&#123;</span><br><span class="line">        goodsService.resetStock(goodsList);</span><br><span class="line">        orderService.deleteOrders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPath</span><span class="params">(MiaoshaUser user, <span class="keyword">long</span> goodsId, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || path == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String pathOld = redisService.get(MiaoshaKey.getMiaoshaPath, <span class="string">""</span>+user.getId() + <span class="string">"_"</span>+ goodsId, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> path.equals(pathOld);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createMiaoshaPath</span><span class="params">(MiaoshaUser user, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || goodsId &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = MD5Util.md5(UUIDUtil.uuid()+<span class="string">"123456"</span>);</span><br><span class="line">        redisService.set(MiaoshaKey.getMiaoshaPath, <span class="string">""</span>+user.getId() + <span class="string">"_"</span>+ goodsId, str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedImage <span class="title">createVerifyCode</span><span class="params">(MiaoshaUser user, <span class="keyword">long</span> goodsId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || goodsId &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">32</span>;</span><br><span class="line">        <span class="comment">//create the image</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics g = image.getGraphics();</span><br><span class="line">        <span class="comment">// set the background color</span></span><br><span class="line">        g.setColor(<span class="keyword">new</span> Color(<span class="number">0xDCDCDC</span>));</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="comment">// draw the border</span></span><br><span class="line">        g.setColor(Color.black);</span><br><span class="line">        g.drawRect(<span class="number">0</span>, <span class="number">0</span>, width - <span class="number">1</span>, height - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// create a random instance to generate the codes</span></span><br><span class="line">        Random rdm = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">// make some confusion</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rdm.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y = rdm.nextInt(height);</span><br><span class="line">            g.drawOval(x, y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// generate a random code</span></span><br><span class="line">        String verifyCode = generateVerifyCode(rdm);</span><br><span class="line">        g.setColor(<span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>));</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="string">"Candara"</span>, Font.BOLD, <span class="number">24</span>));</span><br><span class="line">        g.drawString(verifyCode, <span class="number">8</span>, <span class="number">24</span>);</span><br><span class="line">        g.dispose();</span><br><span class="line">        <span class="comment">//把验证码存到redis中</span></span><br><span class="line">        <span class="keyword">int</span> rnd = calc(verifyCode);</span><br><span class="line">        redisService.set(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="string">","</span>+goodsId, rnd);</span><br><span class="line">        <span class="comment">//输出图片</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkVerifyCode</span><span class="params">(MiaoshaUser user, <span class="keyword">long</span> goodsId, <span class="keyword">int</span> verifyCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || goodsId &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer codeOld = redisService.get(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="string">","</span>+goodsId, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(codeOld == <span class="keyword">null</span> || codeOld - verifyCode != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        redisService.delete(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="string">","</span>+goodsId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ScriptEngineManager manager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">            ScriptEngine engine = manager.getEngineByName(<span class="string">"JavaScript"</span>);</span><br><span class="line">            <span class="keyword">return</span> (Integer)engine.eval(exp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] ops = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * + - * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateVerifyCode</span><span class="params">(Random rdm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> num2 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> num3 = rdm.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">char</span> op1 = ops[rdm.nextInt(<span class="number">3</span>)];</span><br><span class="line">        <span class="keyword">char</span> op2 = ops[rdm.nextInt(<span class="number">3</span>)];</span><br><span class="line">        String exp = <span class="string">""</span>+ num1 + op1 + num2 + op2 + num3;</span><br><span class="line">        <span class="keyword">return</span> exp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口防刷"><a href="#接口防刷" class="headerlink" title="接口防刷"></a>接口防刷</h3><p>缓存记录用户访问次数进行限制</p><ol><li>一般方式：在秒杀接口中加入如下代码</li></ol><p><img src="/2019/11/25/SecKill-Project/image-20200512223440072.png" alt="image-20200512223440072"></p><ol start="2"><li>通用方式：注解拦截器</li></ol><p>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">seconds</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">needLogin</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessInterceptor</span>  <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">MiaoshaUser user = getUser(request, response);</span><br><span class="line">UserContext.setUser(user);</span><br><span class="line">HandlerMethod hm = (HandlerMethod)handler;</span><br><span class="line">AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span>(accessLimit == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> seconds = accessLimit.seconds();</span><br><span class="line"><span class="keyword">int</span> maxCount = accessLimit.maxCount();</span><br><span class="line"><span class="keyword">boolean</span> needLogin = accessLimit.needLogin();</span><br><span class="line">String key = request.getRequestURI();</span><br><span class="line"><span class="keyword">if</span>(needLogin) &#123;</span><br><span class="line"><span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">render(response, CodeMsg.SESSION_ERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">key += <span class="string">"_"</span> + user.getId();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">AccessKey ak = AccessKey.withExpire(seconds);</span><br><span class="line">Integer count = redisService.get(ak, key, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(count  == <span class="keyword">null</span>) &#123;</span><br><span class="line">     redisService.set(ak, key, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &lt; maxCount) &#123;</span><br><span class="line">     redisService.incr(ak, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    render(response, CodeMsg.ACCESS_LIMIT_REACHED);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(HttpServletResponse response, CodeMsg cm)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">OutputStream out = response.getOutputStream();</span><br><span class="line">String str  = JSON.toJSONString(Result.error(cm));</span><br><span class="line">out.write(str.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MiaoshaUser <span class="title">getUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line">String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;</span><br><span class="line"><span class="keyword">return</span> userService.getByToken(response, token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookiName)</span> </span>&#123;</span><br><span class="line">Cookie[]  cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Cookie cookie : cookies) &#123;</span><br><span class="line"><span class="keyword">if</span>(cookie.getName().equals(cookiName)) &#123;</span><br><span class="line"><span class="keyword">return</span> cookie.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改了获取用户代码，修改前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = parameter.getParameterType();</span><br><span class="line">        <span class="keyword">return</span> clazz==MiaoshaUser<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line">        String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;</span><br><span class="line">        <span class="keyword">return</span> userService.getByToken(response, token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookiName)</span> </span>&#123;</span><br><span class="line">        Cookie[]  cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName().equals(cookiName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = parameter.getParameterType();</span><br><span class="line">        <span class="keyword">return</span> clazz==MiaoshaUser<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserContext.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证信息包装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MiaoshaUser&gt; userHolder = <span class="keyword">new</span> ThreadLocal&lt;MiaoshaUser&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(MiaoshaUser user)</span> </span>&#123;</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MiaoshaUser <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span>  <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccessInterceptor accessInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        argumentResolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(accessInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AccessLimit</span>(seconds=<span class="number">5</span>, maxCount=<span class="number">5</span>, needLogin=<span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/path"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;String&gt; <span class="title">getMiaoshaPath</span><span class="params">(HttpServletRequest request, MiaoshaUser user,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     @RequestParam(<span class="string">"goodsId"</span>)</span><span class="keyword">long</span> goodsId,</span></span><br><span class="line"><span class="function">                                     @<span class="title">RequestParam</span><span class="params">(value=<span class="string">"verifyCode"</span>, defaultValue=<span class="string">"0"</span>)</span><span class="keyword">int</span> verifyCode</span></span><br><span class="line"><span class="function">                                    ) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> check = miaoshaService.checkVerifyCode(user, goodsId, verifyCode);</span><br><span class="line">    <span class="keyword">if</span>(!check) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);</span><br><span class="line">    &#125;</span><br><span class="line">    String path  =miaoshaService.createMiaoshaPath(user, goodsId);</span><br><span class="line">    <span class="keyword">return</span> Result.success(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Top100</title>
      <link href="/2019/11/25/LeetCode-Top100/"/>
      <url>/2019/11/25/LeetCode-Top100/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>LeetCode Top100 tags题解</p></blockquote><a id="more"></a><p>学习观看：</p><p><a href="https://www.bilibili.com/video/av51692387" target="_blank" rel="noopener">B站视频题解</a></p><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>数组和链表</p><p>栈和队列</p><p>二叉树</p><h2 id="刷题分类"><a href="#刷题分类" class="headerlink" title="刷题分类"></a>刷题分类</h2><h3 id="树题库"><a href="#树题库" class="headerlink" title="树题库"></a>树题库</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><img src="/2019/11/25/LeetCode-Top100/image-20200408145800813.png" alt="image-20200408145800813"></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p><img src="/2019/11/25/LeetCode-Top100/image-20200408145911287.png" alt="image-20200408145911287"></p><p>17题。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Notes</title>
      <link href="/2019/11/25/Redis-Notes/"/>
      <url>/2019/11/25/Redis-Notes/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>针对面试中redis问答形式的总结</p><ul><li><input disabled type="checkbox"> 数据库与redis数据一致性问题</li></ul></blockquote><a id="more"></a><h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p><p><strong>1、速度快</strong></p><p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p><blockquote><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p></blockquote><p><strong>2、支持丰富数据类型</strong></p><p>支持 String ，List，Set，Sorted Set，Hash 。</p><blockquote><ul><li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li><li>用他的 Set 可以做高性能的 tag 系统等等。</li></ul></blockquote><p><strong>3、持久化存储</strong></p><p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p><h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul><li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</li></ul><p><strong>TODO网络 IO 模型</strong></p><ul><li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li><li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li></ul><p>TODO 有点看不懂，找亚普表弟确认中。</p><h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/2019/11/25/Redis-Notes/image-20191125110950740.png" alt="image-20191125110950740"></p><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="/2019/11/25/Redis-Notes/image-20191125111306113.png" alt="image-20191125111306113"></p><ul><li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li></ul><p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。</p><h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul><li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li><li>数据结构简单，操作也就简单；全程使用 hash 结构，读取速度快；</li><li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li><li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li><li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li></ul><h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p><ul><li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li></ul><h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p><ul><li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ul><p><strong>RDB又存在哪些劣势呢？</strong></p><ul><li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>AOF的优势有哪些呢？</strong></p><ul><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul><p><strong>AOF的劣势有哪些呢？</strong></p><ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul><p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p><p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure><p><strong>AOF持久化配置</strong></p><p>在Redis的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p></li><li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p><ul><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p><blockquote><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p></blockquote></li></ul></li></ul><p>在 Redis4.0 版本开始，当使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034" target="_blank" rel="noopener">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。</p><h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul><li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行 Debug Reload</li><li>执行 Shutdown 且没有开启 AOF 持久化</li></ul><p><strong>重要知识：</strong></p><ul><li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li><li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li><li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><p>BGSAVE底层实现方式：</p><p><img src="/2019/11/25/Redis-Notes/1566521057383.png" alt="1566521057383"></p><ol><li>查询子进程是否有冲突</li><li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li></ol><p><img src="/2019/11/25/Redis-Notes/1566521457362.png" alt="1566521457362"></p><p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p><p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p><h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><p>Redis 提供了 3 种数据过期策略：</p><ul><li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li><li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「数据“淘汰”策略」</a> 。</li></ul><p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html" target="_blank" rel="noopener">《关于 Redis 数据过期策略》</a> 文章。</p><h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p><p>Redis 提供了 6 种数据淘汰策略：</p><ol><li>volatile-lru</li><li>volatile-ttl</li><li>volatile-random</li><li>allkeys-lru</li><li>allkeys-random</li><li>no-enviction</li></ol><p><img src="/2019/11/25/Redis-Notes/image-20191125135302360.png" alt="image-20191125135302360"></p><p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">《Redis实战（二） 内存淘汰机制》</a> 。</p><p><strong>Redis LRU 算法</strong></p><p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p><ul><li><p>具体的可以看看 <a href="http://ifeve.com/lru-cache/" target="_blank" rel="noopener">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p><p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p></li></ul><blockquote><p>这个问题的目的是，如何保证热点数据不要被淘汰。</p></blockquote><p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p><p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p><p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p><h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p><p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul><li>数据缓存</li><li>会话缓存</li><li>时效性数据</li><li>访问频率</li><li>计数器</li><li>社交列表</li><li>记录用户判定信息</li><li>交集、并集和差集</li><li>热门列表与排行榜</li><li>最新动态</li><li>消息队列</li><li>分布式锁</li></ul><p>详细的介绍，可以看看如下文章：</p><ul><li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li><li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li><li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li><li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li></ul><p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p><p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p><p>具体的代码实现，可以看看 <a href="https://www.jianshu.com/p/e3abbfc59d77" target="_blank" rel="noopener">《一道 Redis 面试题》</a> 。</p><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p><ul><li><p>Redisson</p><blockquote><p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p></blockquote></li><li><p>Jedis</p><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p><p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><p>Lettuce</p><blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p></blockquote></li></ul><p>Spring Boot 2.x 内置使用 Lettuce 。</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p><ul><li>互斥性：任意时刻，只能有一个客户端获取锁；</li><li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li><li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li><li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li></ul><p><strong>方案一：set 指令</strong></p><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><ul><li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li><li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li></ul><p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span> [EX <span class="keyword">seconds</span>] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/25/Redis-Notes/Sword-For-java%5C1566518903284.png" alt="1566518903284"></p><ul><li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。<ul><li>具体的实现，可以参考 <a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/" target="_blank" rel="noopener">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li></ul></li><li><a href="https://www.cnblogs.com/wlwl/p/11651409.html" target="_blank" rel="noopener">增加可重入锁</a></li></ul><p><strong>方案二：redlock</strong></p><p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p><p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">《Redlock：Redis分布式锁最牛逼的实现》</a></li><li><a href="https://www.jianshu.com/p/f302aa345ca8" target="_blank" rel="noopener">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li></ul><p><strong>对比 Zookeeper 分布式锁</strong></p><ul><li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li><li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li></ul><p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p><h2 id="Redis并发竞争key"><a href="#Redis并发竞争key" class="headerlink" title="Redis并发竞争key"></a>Redis并发竞争key</h2><p>即：多个系统同时对一个 key 进行操作</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><ul><li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li><li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li><li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li><li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li></ul><p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p><p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p><h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p><p><strong>Redis 如何做大量数据插入？</strong></p><p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p><p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">《Redis 大量数据插入》</a> 文章。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p><ul><li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p></li><li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p></li><li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p></li><li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p></li><li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p><blockquote><p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p></blockquote></li></ul><p><strong>如何实现 Redis CAS 操作？</strong></p><p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p><p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26" target="_blank" rel="noopener">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p><h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p><ul><li>1、Redis Sentinel</li><li>2、Redis Cluster</li><li>3、Twemproxy</li><li>4、Codis</li><li>5、客户端分片</li></ul><p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">《Redis 实战（四）集群机制》</a> 这篇文章。</p><p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p><blockquote><p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p><p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></blockquote><p><strong>选择</strong></p><p>目前一般在选型上来说：</p><ul><li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p></li><li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p><p><strong>Redis 集群如何扩容？</strong></p></li></ul><blockquote><p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p></blockquote><ul><li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li><li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li></ul><h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p><p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p><ul><li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li><li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li><li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><p><strong>好处</strong></p><p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p><p>更多详细，可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md" target="_blank" rel="noopener">《Redis 主从架构》</a> 。</p><h2 id="数据与数据库双写一致"><a href="#数据与数据库双写一致" class="headerlink" title="数据与数据库双写一致"></a>数据与数据库双写一致</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通用的读操作</p><ul><li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li><li>最后将数据返回给请求</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>写操作</strong>可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li><p>设置<strong>键的过期时间</strong>，可以保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p></li><li><p>更新操作的细分</p></li></ol><p>执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><blockquote><p>注：这里的缓存操作一般是删除操作。</p></blockquote><p>对比：</p><ul><li>先删除缓存，再更新数据库<ul><li>在高并发下表现不如意，在原子性被破坏时表现优异</li></ul></li><li>先更新数据库，再删除缓存(<code>Cache Aside Pattern</code>设计模式)<ul><li>在高并发下表现优异，在原子性被破坏时表现不如意</li></ul></li></ul><h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">《Redis 哨兵集群实现高可用》</a> 。</p><h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">《Redis 集群教程》</a> 完整版</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md" target="_blank" rel="noopener">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li></ul><p><strong>说说 Redis 哈希槽的概念？</strong></p><p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p><p><strong>Redis Cluster 的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p><p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p><ul><li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li></ul><p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p><p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><p><strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p><p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p><strong>Redis 集群如何选择数据库？</strong></p><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p><blockquote><p>重点问题，仔细理解。</p></blockquote><ul><li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li><li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li><li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li></ul><h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote><p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 集群都有哪些方案？」</a> 是同类问题。</p></blockquote><p>关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html" target="_blank" rel="noopener">《Redis 分区》</a> 文章。</p><ul><li>Redis 分区是什么？</li><li>分区的优势？</li><li>分区的不足？</li><li>分区类型？</li></ul><p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p><ul><li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li><li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li></ul><p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p><p>Redis 分区方案，主要分成两种类型：</p><ul><li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul><li>案例：Redis Cluster 和客户端分区。</li></ul></li><li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul><li>案例：Twemproxy 和 Codis 。</li></ul></li></ul><p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p><p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p><p>如下是网络上的一个大答案：</p><blockquote><p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p></blockquote><ul><li>和飞哥沟通了下，这个操作不是很合理。</li><li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li></ul><h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA" target="_blank" rel="noopener">《Redis 几个重要的健康指标》</a></p><ul><li>存活情况</li><li>连接数</li><li>阻塞客户端数量</li><li>使用内存峰值</li><li>内存碎片率</li><li>缓存命中率</li><li>OPS</li><li>持久化</li><li>失效KEY</li><li>慢日志</li></ul><p><strong>如何提高 Redis 命中率？</strong></p><p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html" target="_blank" rel="noopener">《如何提高缓存命中率（Redis）》</a> 。</p><h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865" target="_blank" rel="noopener">《Redis 的内存优化》</a></p><ul><li><p>redisObject 对象</p></li><li><p>缩减键值对象</p></li><li><p>共享对象池</p></li><li><p>字符串优化</p></li><li><p>编码优化</p></li><li><p>控制 key 的数量</p><p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p></li></ul><p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p><p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p><p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p><p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><ul><li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li><li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li></ul><h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p><ul><li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li><li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li><li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li></ul><p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong></p><p><strong>3、尽量避免在压力很大的主库上增加从库。</strong></p><p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong></p><ul><li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li></ul><p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase Notes</title>
      <link href="/2019/11/24/DataBase-Notes/"/>
      <url>/2019/11/24/DataBase-Notes/</url>
      
        <content type="html"><![CDATA[<p> 引言：</p><blockquote><p>针对面试的mysql数据库总结</p></blockquote><a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p><strong>客观存在并可相互区别的事物</strong>称之为实体。可以看成是Java类</p><p>例子：(课程关系表)就是一个实体。</p><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p><strong>实体所具有的某一特性</strong>称之为属性。可以看成是Java类的成员变量。属性在数据库中又称为字段（或者是列）</p><p>例子：(课程名)，(课程号)、(学时)就是属性名。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>除含有属性名所在的行之外的其他行称之为元组。</strong></p><p><strong>下面的每一行数据都称之为元组</strong><br>(C401001 数据结构 70)<br>(C401002 操作系统 80)<br>(C402001 计算机原理 60)</p><h3 id="码-Key"><a href="#码-Key" class="headerlink" title="码(Key)"></a>码(Key)</h3><p><strong>码也被称作是关键字。它可以唯一标识一个实体</strong>。</p><p>候选码和主码：</p><ul><li>候选码：如果一组属性集能唯一地标识一个关系中的元组而又不含有多余的属性，则称该属性集为该关系的候选码 。（<strong>候选码可能不止有一个</strong>）</li><li>主码：用户选定的那个候选键称为主键</li></ul><p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p><p>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</p><p>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码</p><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系名和其属性集合的组合称之为关系模式</strong>。</p><p>关系模式例子：课程关系表(课程号,课程名,学时)</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>关系模型要求元组的每一个分量都是原子性的，也就是说，它必须属于某种元素类型，如Integer、String等等，不能是列，集合，记录，数组！</p><p><strong>域就代表着该元组中每个分量的类型</strong>，例如：课程号:string,课程名:string,学时:int</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2019/11/24/DataBase-Notes/1566261820297.png" alt="1566261820297"></p><p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p><p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p><p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么使用索引？"><a href="#为什么使用索引？" class="headerlink" title="为什么使用索引？"></a>为什么使用索引？</h3><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p><p><strong>磁盘文件存储</strong></p><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><h3 id="什么样的信息能够称为索引？"><a href="#什么样的信息能够称为索引？" class="headerlink" title="什么样的信息能够称为索引？"></a>什么样的信息能够称为索引？</h3><p>主键，唯一键，普通键，有一定区分性</p><p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p><blockquote><p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p></blockquote><p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p><blockquote><p>唯一键不是主键，但主键有不可重复性</p><p>一张表可以有多个唯一键，但只能有一个主键</p></blockquote><p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p><h3 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h3><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p><p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p><p><img src="/2019/11/24/DataBase-Notes/1566261830802.png" alt="1566261830802"></p><p>特性：</p><p><img src="/2019/11/24/DataBase-Notes/1566261842897.png" alt="1566261842897"></p><p><img src="/2019/11/24/DataBase-Notes/1566261850318.png" alt="1566261850318"></p><p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p><p>B+树：</p><p><img src="/2019/11/24/DataBase-Notes/1566261860507.png" alt="1566261860507"></p><p>结论：B+树更适合，原因：</p><ul><li><p><strong>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</strong></p></li><li><p><strong>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</strong></p></li><li><p><strong>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</strong></p></li></ul><p><strong>Hash索引了解一下：</strong></p><p>缺点：</p><ul><li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li><li>无法运用索引值来排序</li><li>不能利用部分索引键查询</li><li>不能避免表扫描，哈希值可能重复，需要全表扫描</li><li>大量hash值相等时，效率很底。</li></ul><p>密集索引和稀疏索引</p><p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列（属性）的数据。</p><blockquote><p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p></blockquote><p>稀疏索引：叶子节点仅保存了键位信息（索引键位）及其主键。</p><p>InnoDB的索引</p><p><img src="/2019/11/24/DataBase-Notes/1566261871063.png" alt="1566261871063"></p><h3 id="如何定位并优化sql？"><a href="#如何定位并优化sql？" class="headerlink" title="如何定位并优化sql？"></a>如何定位并优化sql？</h3><ul><li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p><p><img src="/2019/11/24/DataBase-Notes/1566262283010.png" alt="1566262283010"></p></li><li><p>使用explain等工具分析sql</p><p><img src="/2019/11/24/DataBase-Notes/1566262067821.png" alt="1566262067821"></p><ul><li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li><li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li></ul><p><img src="/2019/11/24/DataBase-Notes/1566261930304.png" alt="1566261930304"></p><ul><li>字段：extra，如图</li></ul><p><img src="/2019/11/24/DataBase-Notes/1566261963108.png" alt="1566261963108"></p></li><li><p>修改sql或者尽量让sql走索引</p><ul><li>改用索引查</li></ul><p><img src="/2019/11/24/DataBase-Notes/1566262116465.png" alt="1566262116465"></p><ul><li>添加索引</li></ul><p><img src="/2019/11/24/DataBase-Notes/1566262137053.png" alt="1566262137053"></p></li><li><p>使用fore_index()测试那个索引更好</p></li></ul><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p><img src="/2019/11/24/DataBase-Notes/1566262151740.png" alt="1566262151740"></p><p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p><p>索引建立的越多越好吗？</p><p><img src="/2019/11/24/DataBase-Notes/1566262159079.png" alt="1566262159079"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>首先需要了解：</p><ul><li>对于<code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li><li><strong>MyISAM</strong>在执行查询语句<code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（<code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li></ul><p>其次需要了解：</p><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><ul><li>也就是说，<strong>InnoDB的行锁是基于索引的</strong>！</li></ul><p>Myisam：表级锁，不支持行级锁</p><p>InnoDB：默认行级锁，支持表级锁，</p><blockquote><p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p></blockquote><p>无论表锁还是行锁，默认都分为共享锁和排他锁</p><p><img src="/2019/11/24/DataBase-Notes/1566262385992.png" alt="1566262385992"></p><h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>MyISAM</p><ul><li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li><li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li><li>适合没有事务的</li></ul><p>InnoDB</p><ul><li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li><li>支持事务的系统</li></ul><p>数据库锁分类：</p><ul><li>按粒度划分：表级锁，行级锁，页级锁</li><li>按级别划分：共享锁，排他锁</li><li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li><li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li><li><strong>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</strong></li></ul><h3 id="乐观锁和悲观锁："><a href="#乐观锁和悲观锁：" class="headerlink" title="乐观锁和悲观锁："></a>乐观锁和悲观锁：</h3><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul><li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li><li>实现方式：使用数据库中的锁机制</li></ul></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<ul><li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li><li>实现方式：使用version版本或者时间戳</li></ul></li></ul><h2 id="事务隔离与锁"><a href="#事务隔离与锁" class="headerlink" title="事务隔离与锁"></a>事务隔离与锁</h2><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><p>不同的隔离级别对锁的使用是不同的，<strong>锁的应用最终导致不同事务的隔离级别</strong></p><p>ACID：原子性，一致性，隔离性，持久性</p><p>事务的隔离性以及各级别下的并发问题</p><p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p><p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事务读取另一个事务未提交数据</p><p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p><p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p><p><img src="/2019/11/24/DataBase-Notes/1566263834174.png" alt="1566263834174"></p><h3 id="InnoDB引擎的隔离与锁"><a href="#InnoDB引擎的隔离与锁" class="headerlink" title="InnoDB引擎的隔离与锁"></a>InnoDB引擎的隔离与锁</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种<strong>具体方式</strong>，用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别。</p><blockquote><p>而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p></blockquote><blockquote><p>InnoDB<strong>基于行锁</strong>实现了MVCC多版本并发控制，MVCC在隔离级别下的<code>Read committed</code>和<code>Repeatable read</code>下工作。MVCC能够实现<strong>读写不阻塞</strong>！</p></blockquote><h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><ul><li>通过一定机制生成一个数据请求<strong>时间点的一致性数据快照（Snapshot)</strong>，并用这个快照来提供一定级别（<strong>语句级或事务级</strong>）的<strong>一致性读取</strong>。从用户的角度来看，好像是<strong>数据库可以提供同一数据的多个版本</strong>。</li><li>版本号<ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。<ul><li>版本号用来和查询到的每行记录的版本号进行比较。</li></ul></li></ul></li><li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：<ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul></li></ul><h4 id="Read-committed实现"><a href="#Read-committed实现" class="headerlink" title="Read committed实现"></a><code>Read committed</code>实现</h4><p>原理：快照读机制，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><p><code>Read committed</code><strong>避免脏读</strong>的做法其实很简单：</p><ul><li><strong>在读取的时候生成一个版本号，直到事务其他commit被修改了之后，才会有新的版本号</strong>，读取时会对比版本号</li></ul><p>过程：</p><ul><li>事务A读取了记录(生成版本号)</li><li>事务B修改了记录(此时加了写锁)</li><li>事务A再读取的时候，<strong>是依据最新的版本号来读取的</strong>(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据。</li></ul><h4 id="Repeatable-read实现"><a href="#Repeatable-read实现" class="headerlink" title="Repeatable read实现"></a><code>Repeatable read</code>实现</h4><p><code>Read committed</code>会出现不可重复读：<strong>一个事务可以看到其他事务所做的修改</strong>。</p><p>例如，<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样（危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了）</strong></p><blockquote><p><code>Read committed</code>是<strong>语句级别</strong>（执行语句）的快照！<strong>每次读取的都是当前最新的数据行版本</strong>！</p></blockquote><blockquote><p><code>Repeatable read</code>避免不可重复读是<strong>事务级别</strong>的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。</p></blockquote><p>总结：事务开启时使用系统版本作为事务版本号，事务开启时数据行更新后使用最新数据行版本号，<strong>读提交实现</strong>使用数据行版本号的比对，确保每次commit被修改了之后，才会有新的版本号，通过版本号实现隔离；<strong>重复读实现</strong>对比的是快照中的事务版本号，即在 <strong>tempdb</strong> 中存储原始行的副本，和为该行添加事务版本号，通过版本号实现隔离。</p><h3 id="InnoDB在可重复度隔离级别下是如何避免幻读？"><a href="#InnoDB在可重复度隔离级别下是如何避免幻读？" class="headerlink" title="InnoDB在可重复度隔离级别下是如何避免幻读？"></a>InnoDB在可重复度隔离级别下是如何避免幻读？</h3><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><p>表象：快照度（非阻塞读）——伪MVCC</p><p>内在：next-key锁（行锁+gap锁）</p><p><img src="/2019/11/24/DataBase-Notes/1566264130165.png" alt="1566264130165"></p><p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p><p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p><p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p><ol><li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li><li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li></ol><p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p><p><img src="/2019/11/24/DataBase-Notes/1566265001814.png" alt="1566265001814"></p><p>再次修改为（11，32，45）时会发生：</p><p><img src="/2019/11/24/DataBase-Notes/1566264973315.png" alt="1566264973315"></p><ol start="3"><li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li></ol><p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p><p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>next-key锁（record锁+gap锁）</p><ul><li><p>record锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</p></li><li><p>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</p></li><li><p>next-key锁：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10],(10, 11],(11, 13],(13, 20],(20, +∞)</span><br></pre></td></tr></table></figure></li></ul><p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p><p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p><ul><li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li><li>如果where条件部分命中或者未命中，就会加上gap锁</li></ul><p>gap锁会出现在非唯一索引或者不走索引的当前读中</p><p>非唯一索引：</p><p><img src="/2019/11/24/DataBase-Notes/1566268250911.png" alt="1566268250911"></p><p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p><p>不走索引</p><p><img src="/2019/11/24/DataBase-Notes/1566268427287.png" alt="1566268427287"></p><p>会对所有gap上锁，类似表锁，也能防止幻读。</p><p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><strong>在我们书写SQL语句的时候，其实书写的顺序、策略会影响到SQL的性能，虽然实现的功能是一样的，但是它们的性能会有些许差别。</strong></p><p>因此，下面就讲解在书写SQL的时候，怎么写比较好。</p><hr><h3 id="选择最有效率的表名顺序"><a href="#选择最有效率的表名顺序" class="headerlink" title="选择最有效率的表名顺序"></a>选择最有效率的表名顺序</h3><p>数据库的解析器按照<strong>从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p><p>在FROM子句中包含多个表的情况下：</p><ul><li><strong>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</strong></li><li><strong>也就是说：选择记录条数最少的表放在最后</strong></li></ul><p>如果有3个以上的表连接查询：</p><ul><li><strong>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推</strong>。</li><li><strong>也就是说：被其他表所引用的表放在最后</strong></li></ul><p>例如：查询员工的编号，姓名，工资，工资等级，部门名</p><p><strong>emp表被引用得最多，记录数也是最多，因此放在form字句的最后面</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname</span><br><span class="line"><span class="keyword">from</span> salgrade,dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal)</span><br></pre></td></tr></table></figure><hr><h3 id="WHERE子句中的连接顺序"><a href="#WHERE子句中的连接顺序" class="headerlink" title="WHERE子句中的连接顺序"></a>WHERE子句中的连接顺序</h3><p>数据库采用自<strong>右而左的顺序解析WHERE子句</strong>,根据这个原理,<strong>表之间的连接必须写在其他WHERE条件之左</strong>,那些<strong>可以过滤掉最大数量记录的条件必须写在WHERE子句的之右</strong>。</p><p><strong>emp.sal可以过滤多条记录，写在WHERE字句的最右边</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,dept.dname</span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal &gt; <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="SELECT子句中避免使用-号"><a href="#SELECT子句中避免使用-号" class="headerlink" title="SELECT子句中避免使用*号"></a>SELECT子句中避免使用*号</h3><p>我们当时学习的时候，星号是可以获取表中全部的字段数据的。</p><ul><li><strong>但是它要通过查询数据字典完成的，这意味着将耗费更多的时间</strong></li><li>使用*号写出来的SQL语句也不够直观。</li></ul><hr><h3 id="用TRUNCATE替代DELETE"><a href="#用TRUNCATE替代DELETE" class="headerlink" title="用TRUNCATE替代DELETE"></a>用TRUNCATE替代DELETE</h3><p>这里仅仅是：<strong>删除表的全部记录，除了表结构才这样做</strong>。</p><p><strong>DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快</strong></p><hr><h3 id="多使用内部函数提高SQL效率"><a href="#多使用内部函数提高SQL效率" class="headerlink" title="多使用内部函数提高SQL效率"></a>多使用内部函数提高SQL效率</h3><p><strong>例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。</strong></p><hr><h3 id="使用表或列的别名"><a href="#使用表或列的别名" class="headerlink" title="使用表或列的别名"></a>使用表或列的别名</h3><p><strong>如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了。。。</strong></p><hr><h3 id="多使用commit"><a href="#多使用commit" class="headerlink" title="多使用commit"></a>多使用commit</h3><p>comiit会释放回滚点…</p><hr><h3 id="善用索引"><a href="#善用索引" class="headerlink" title="善用索引"></a>善用索引</h3><p>索引就是为了提高我们的查询数据的，当表的记录量非常大的时候，我们就可以使用索引了。</p><hr><h3 id="SQL写大写"><a href="#SQL写大写" class="headerlink" title="SQL写大写"></a>SQL写大写</h3><p>我们在编写SQL 的时候，官方推荐的是使用大写来写关键字，<strong>因为Oracle服务器总是先将小写字母转成大写后，才执行</strong></p><hr><h3 id="避免在索引列上使用NOT"><a href="#避免在索引列上使用NOT" class="headerlink" title="避免在索引列上使用NOT"></a>避免在索引列上使用NOT</h3><p>因为Oracle服务器遇到NOT后，他就会停止目前的工作，转而执行全表扫描</p><h4 id="避免在索引列上使用计算"><a href="#避免在索引列上使用计算" class="headerlink" title="避免在索引列上使用计算"></a>避免在索引列上使用计算</h4><p>WHERE子句中，<strong>如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢</strong></p><h4 id="用-gt-替代-gt"><a href="#用-gt-替代-gt" class="headerlink" title="用 &gt;= 替代 &gt;"></a>用 <code>&gt;=</code> 替代 <code>&gt;</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">低效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt; <span class="number">3</span>   </span><br><span class="line">首先定位到DEPTNO=<span class="number">3</span>的记录并且扫描到第一个DEPT大于<span class="number">3</span>的记录</span><br><span class="line">高效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;= <span class="number">4</span>  </span><br><span class="line">直接跳到第一个DEPT等于<span class="number">4</span>的记录</span><br></pre></td></tr></table></figure><h4 id="用IN替代OR"><a href="#用IN替代OR" class="headerlink" title="用IN替代OR"></a>用IN替代OR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal = <span class="number">1500</span> <span class="keyword">or</span> sal = <span class="number">3000</span> <span class="keyword">or</span> sal = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span> (<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">800</span>);</span><br></pre></td></tr></table></figure><h4 id="总是使用索引的第一个列"><a href="#总是使用索引的第一个列" class="headerlink" title="总是使用索引的第一个列"></a>总是使用索引的第一个列</h4><p>如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> emp_sal_job_idex</span><br><span class="line"><span class="keyword">on</span> emp(sal,job);</span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp  </span><br><span class="line"><span class="keyword">where</span> job != <span class="string">'SALES'</span>;    </span><br><span class="line"></span><br><span class="line">上边就不使用索引了。</span><br></pre></td></tr></table></figure><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul><li>1）范式优化： 比如消除冗余（节省空间。。）</li><li>2）反范式优化：比如适当加冗余等（减少join）</li><li>3）拆分表： 垂直拆分和水平拆分</li></ul><h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><p>money</p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。<br>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y</p></blockquote><p>总结一下：</p><ul><li>首先要明确的是：范式一到三是越来越严格的。<strong>满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</strong></li><li>第一范式：<strong>字段是最小的的单元不可再分</strong><ul><li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li></ul></li><li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul><li><strong>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的</strong></li><li>学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</li></ul></li><li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul><li><strong>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖</strong></li><li>比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种基于数据表的一种<strong>虚表</strong></p><ul><li>（1）视图是一种虚表</li><li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li><li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li><li>（4）视图向用户提供基表数据的另一种表现形式</li><li>（5）视图没有存储真正的数据，真正的数据还是存储在基表中</li><li>（6）程序员虽然操作的是视图，但最终视图还会转成操作基表</li><li>（7）一个基表可以有0个或多个视图</li></ul><p>有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段…</p><p>那么把全部的字段都都显示给他们看，这是不合理的。</p><p>我们应该做到：<strong>他们想看到什么样的数据，我们就给他们什么样的数据…一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来…</strong></p><p><strong>视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便</strong>…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h4 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h4><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img"></p><h4 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h4><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img"></p><h4 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h4><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img"></p><h4 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h4><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img"></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="MySQL表设计要注意什么？"><a href="#MySQL表设计要注意什么？" class="headerlink" title="MySQL表设计要注意什么？"></a>MySQL表设计要注意什么？</h3><h4 id="主键是用自增还是UUID"><a href="#主键是用自增还是UUID" class="headerlink" title="主键是用自增还是UUID?"></a>主键是用自增还是UUID?</h4><p>肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h4 id="主键为什么不推荐有业务含义"><a href="#主键为什么不推荐有业务含义" class="headerlink" title="主键为什么不推荐有业务含义?"></a>主键为什么不推荐有业务含义?</h4><p>有如下两个原因</p><ul><li>因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</li><li>带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</li></ul><h4 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型?"></a>时间字段用什么类型?</h4><p>(1)<code>varchar</code>，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为<code>2013111</code>的数据，请问这是代表2013年1月11日，还是2013年11月1日？<br>其次，做时间比较运算，你需要用<code>STR_TO_DATE</code>等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p><p>(2)<code>timestamp</code>，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用<code>timestamp</code>类型存储的。<br>但是它有一个优势，<code>timestamp</code>类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TIME_ZONE</span> = <span class="string">"america/new_york"</span>;</span><br></pre></td></tr></table></figure><p>你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p><p>(3)<code>datetime</code>，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p><p>(4)<code>bigint</code>，也是8个字节，自己维护一个时间戳，表示范围比<code>timestamp</code>大多了，就是要自己维护，不大方便。</p><h4 id="为什么不直接存储图片、音频、视频等大容量内容"><a href="#为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="为什么不直接存储图片、音频、视频等大容量内容?"></a>为什么不直接存储图片、音频、视频等大容量内容?</h4><p>我们在实际应用中，都是用<code>HDFS</code>来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是<code>text</code>和<code>blob</code>类型。但是，我们在生产中，基本不用这两个类型！<br>主要原因有如下两点</p><ul><li>(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢</li><li>(2)<code>binlog</code>内容太多。因为你数据内容比较大，就会造成<code>binlog</code>内容比较多。大家也知道，主从同步是靠<code>binlog</code>进行同步，<code>binlog</code>太大了，就会导致主从同步效率问题！</li></ul><p>因此，不推荐使用<code>text</code>和<code>blob</code>类型！</p><h4 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL?"></a>字段为什么要定义为NOT NULL?</h4><p>(1)索引性能不好</p><blockquote><p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。                                                                              </p></blockquote><p>(2)查询会出现一些不可预料的结果<br>这里举一个例子，大家就懂了。假设，表结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>表数据是这样的</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">孤独烟</td></tr><tr><td align="center">3</td><td align="center">null</td></tr><tr><td align="center">5</td><td align="center">肥朝</td></tr><tr><td align="center">7</td><td align="center">null</td></tr></tbody></table><p>你执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> table_2;</span><br></pre></td></tr></table></figure><p>你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。<br>记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.</p><h3 id="索引的特点"><a href="#索引的特点" class="headerlink" title="索引的特点"></a>索引的特点</h3><ul><li><strong>是一种快速查询表中内容的机制，</strong></li><li><strong>运用在表中某个些字段上，但存储时，独立于表之外</strong></li></ul><p>索引的特点</p><ul><li>索引一旦建立, <strong>DB管理系统会对其进行自动维护</strong>, 而且由DB管理系统决定何时使用索引</li><li>用户不用在查询语句中指定使用哪个索引</li><li><strong>在定义primary key或unique约束后系统自动在相应的列上创建索引</strong></li><li>用户也能按自己的需求，对指定单个字段或多个字段，添加索引</li></ul><table><thead><tr><th align="center">什么时候【要】创建索引</th><th align="center">什么时候【不要】创建索引</th></tr></thead><tbody><tr><td align="center">表经常进行 SELECT 操作</td><td align="center">表经常进行 INSERT/UPDATE/DELETE 操作</td></tr><tr><td align="center">表很大(记录超多)，记录内容分布范围很广</td><td align="center">表很小(记录超少)</td></tr><tr><td align="center">列名经常在 WHERE 子句或连接条件中出现</td><td align="center">列名不经常作为连接条件或出现在 WHERE 子句中</td></tr></tbody></table><p><strong>索引优缺点：</strong></p><ul><li>索引加快数据库的检索速度</li><li>索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，<strong>因为大部分数据更新需要同时更新索引</strong>)</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li><li>索引需要占物理和数据空间</li></ul><p>索引分类：</p><ul><li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li><li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li><li><strong>聚集索引</strong>(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li><li><strong>二级索引</strong>(Non-clustered)：二级索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="一个-SQL-执行的很慢？"><a href="#一个-SQL-执行的很慢？" class="headerlink" title="一个 SQL 执行的很慢？"></a>一个 SQL 执行的很慢？</h3><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log （<strong>重做日志</strong>）写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><h3 id="MySQL-基础架构分析"><a href="#MySQL-基础架构分析" class="headerlink" title="MySQL 基础架构分析"></a>MySQL 基础架构分析</h3><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><p><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p><p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p><h3 id="SQL语句执行过程分析"><a href="#SQL语句执行过程分析" class="headerlink" title="SQL语句执行过程分析"></a>SQL语句执行过程分析</h3><p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p><p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog（归档日志）—》redo log commit</p><h3 id="常用的存储引擎"><a href="#常用的存储引擎" class="headerlink" title="常用的存储引擎"></a>常用的存储引擎</h3><ul><li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><table><thead><tr><th align="center"></th><th align="center">Innodb</th><th align="center">MyIASM</th></tr></thead><tbody><tr><td align="center">事务</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">哈希索引</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">全文索引</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">存储容量</td><td align="center">64TB</td><td align="center">无上限</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Networks Notes</title>
      <link href="/2019/11/22/Computer-Networks-Notes/"/>
      <url>/2019/11/22/Computer-Networks-Notes/</url>
      
        <content type="html"><![CDATA[<p>引言</p><blockquote><ol><li>记录慕课网《剑指offer》课程中计算机网络部分面试知识</li><li>面试问题记录，涉及的较少</li></ol></blockquote><a id="more"></a><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122201138746.png" alt></p><p>OSI</p><ul><li><p>物理层：两台物理机器之间传输比特流，定义物理设备的标准，网卡</p></li><li><p>数据链路层：在传输比特流的过程会产生各种错误，数据链路层应运而生，该层定义了如何格式化数据以进行传输以及控制对物理介质的访问，还提供错误检测和纠正。该层将比特数据组成帧，交换机工作在该层，对帧解码，根据帧中的数据将信息发送到正确的接收方。</p></li></ul><blockquote><p>随着网络节点的增加，点对点间的通信是需要经过多个节点的，如何找到目标节点，如何选择最佳路径是首要需求，此时产生网络层</p></blockquote><ul><li>网络层：其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。发送方综合考虑发送优先权、网络拥塞、服务质量、可选路由的花费决定从网络中一个节点A到另一个网络中B的最佳路径，网络层处理并智能指导数据传送，路由器连接网络各端，所以路由器属于网络层。此层的数据称为数据包。本层关注TCP/IP协议中的IP协议。</li></ul><blockquote><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，可能需要很长时间，网络在通信过程会中断多次，此时为了保证传输文件的准确性，需要对发出去的数据进行切分，切为数据段。当发生数据段络丢失，失序等情况时，传输层应运而生。</p></blockquote><ul><li>传输层：解决主机间的数据传输，和传输质量问题。该层传输协议进行流量控制或是基于接收方可接受数据的快慢程度规定适当的发送速率。同时分割数据包以适应在网络上传输（以太网无法接受大于1500字节的数据包），分割数据为数据片，同时在数据片上给定序号，以便接受时可按序排组。需要关注TCP和UDP协议。</li></ul><blockquote><p>为了不用用户级不要每次调用TCP打包数据，IP协议去寻找路由，现在需要自动收发包，自动寻址的功能，会话层应运而生</p></blockquote><ul><li>会话层：作用是建立和管理应用程序之间的通信。至此可以保证用用程序能够自动收发包和寻址。</li></ul><blockquote><p>考虑各应用程序的环境不同，如window和Linux之间的差异，需要表示层来消除</p></blockquote><ul><li>表示层：解决不同系统之间的通信语法的问题，该层数据将按照网络能够理解的方式进行格式化。此时完成数据转化成相应的字节。</li></ul><blockquote><p>此时发送方知道发送的数据是什么，转换成字节数据有多长，但接收方并不知道，为了发送方和接收方能够理解传输字节的含义，应用层网络协议诞生</p></blockquote><ul><li>应用层：应用层网络协议规定消息发送方和接收方必须使用一个固定长度的一个消息头，消息头必须是固定组成，记录各种信息以方便接收方解析。该层旨在让你能够更方便的从网络中接受数据，没有该层也可以在两台主机间传递，但是我们能了解的就是一堆0101编码的字节数组。需要关注TCP/IP协议中的HTTP协议。</li></ul><p>这是一个框架来协调和组织各层所提供的服务，但是该模型仅是概念模型，来协调进程间通信标准的制定。实际的实现是TCP/IP协议。</p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p> TCP/IP 是 Internet上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。 </p><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122201724700.png" alt="image-20191122201724700"></p><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><h3 id="传输控制协议-TCP-简介"><a href="#传输控制协议-TCP-简介" class="headerlink" title="传输控制协议 TCP 简介"></a>传输控制协议 TCP 简介</h3><ul><li>面向连接的、可靠的基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的 TCP 层</li><li>数据包都是由序号，对方收到则发送 ACK 确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><p>IP协议是无连接的协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求每条线可以同时满足许多不同计算机之间的通信需要。通过IP协议，消息或者其他数据会被分割为较小的包，并通过因特网在计算机之间传送，IP负责将每个包路由至他的目的地，但是IP协议未作任何事来确认数据包是否安全到达，所以他是不可靠的，需要他的上层协议来控制。传输控制协议TCP是传输层的协议。（简介）</p><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122204017097.png" alt="image-20191122204017097"></p><ul><li><strong>源端口、目的端口</strong> ：各2个字节，TCP/UDP都是不包含IP地址信息的，两者头部都会有端口号，这是在传输层范畴的知识。两个进程在计算机内部进行通信可以有：管道、内存共享、信号量和消息队列等方法。其中最唯一要求是唯一的表示对方进程，在本地进程中可以使用PID，但是在网络中的不同主机中使用便失效了，解决方式就是在传输层中使用协议端口号，已知在网络层中IP可以唯一标识一个主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样可以利用IP地址+协议+端口号这样的唯一标识去表示网络中的一个进程，这种方式也成为套接字。这样，虽然通信的重点是应用进程，但是我们只要把要传送的报文交到目的主机的某一个合适端口中，剩下的工作就由TCP来完成了。</li><li><strong>seq序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>ack确认号</strong> ：表示期望收到对方下一个报文的第一个字节的序号。例如B收到A发送的报文seq序号是301，全部数据是200字节，B正确收到从A发送的序号到500（301+200-1）的数据，所以B期望收到的A的下一个数据序号是501，于是，B在发送给A的确认报文中，会把ack确认号置为501。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li>连接标志（TCP Flags）：表示控制功能，下面是常见的连接标志。<ul><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=a1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li></ul></li><li><strong>窗口</strong> ：滑动窗口大小，告知发送端接收端的缓存大小（还有多少空间可以接收数据，因为接收方的数据缓存空间是有限的），以此控制发送端发送数据速率，从而达到流量控制。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>当应用程序希望通过TCP和另一个应用程序通信时，会发送一个通信请求，必须有一个确切地址，在双方握手后TCP将在两个程序间建立一个全双工的通信，将占据两个计算机的通信线路，直到双方关闭为止。（三次握手）</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261217747.png" alt="1566261217747"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><img src="/2019/11/22/Computer-Networks-Notes/1566261228418-1574427053238.png" alt="1566261228418"></p><h3 id="为什么要三次连接"><a href="#为什么要三次连接" class="headerlink" title="为什么要三次连接"></a>为什么要三次连接</h3><p>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><h3 id="关于建连接时SYN超时"><a href="#关于建连接时SYN超时" class="headerlink" title="关于建连接时SYN超时"></a>关于建连接时SYN超时</h3><p>试想一下，如果server端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的TCP会重发 SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p><h3 id="关于SYN-Flood攻击"><a href="#关于SYN-Flood攻击" class="headerlink" title="关于SYN Flood攻击"></a>关于SYN Flood攻击</h3><p>一些恶意的人就为此制造了SYN Flood攻击，给服务器发了一个SYN后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫 <strong>tcp_syncookies</strong> 的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p><p>请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择。</p><ul><li>第一个是：tcp_synack_retries 可以用他来减少重试次数；</li><li>第二个是：tcp_max_syn_backlog，可以增大SYN连接数；</li><li>第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了 ；</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍然未收到响应则中断连接</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>即断开连接时需要客户端和服务端总共发送4各数据包来确认断开连接。</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261278901.png" alt="1566261278901"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>TCP连接是全双工的，服务端可以发送数据到客户端，客户端也可以发送数据到服务端，发送方和接收方都需要两次挥手才能关闭 。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><img src="/2019/11/22/Computer-Networks-Notes/1566261373431.png" alt="1566261373431"></p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><h3 id="UPD-的特点"><a href="#UPD-的特点" class="headerlink" title="UPD 的特点"></a>UPD 的特点</h3><ul><li>面向非连接的</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有 8 个字节，额外开销较小</li><li>吞吐量只受限于数据生成率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或则合并</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h2 id="TCP-的滑动窗口"><a href="#TCP-的滑动窗口" class="headerlink" title="TCP 的滑动窗口"></a>TCP 的滑动窗口</h2><p>首先明确：</p><p>TCP滑动窗口分为接受窗口，发送窗口。</p><p>滑动窗口协议是<strong>传输层进行流控</strong>的一种措施，<strong>接收方通过通告发送方自己的窗口大小</strong>，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：</p><ul><li>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</li><li>二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理</li></ul><p><strong>重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。</strong></p><p>发送端窗口的第一个字节序号一定是ACK中期望收到的下一个字节序号，比如下图：</p><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122205849513.png" alt="image-20191122205849513"></p><p>上图52 53 54 55 字节都是可以新发送的字节序。</p><p>接受端窗口的第一个字节序之前一定是已经完全接收的，后面窗口里面的数据都是希望接受的，窗口后面的数据都是不希望接受的。</p><p>TCP的滑动窗口分为接收窗口和发送窗口 不分析这两种窗口就讨论是不妥当的。 TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><h2 id="TCP粘包、拆包"><a href="#TCP粘包、拆包" class="headerlink" title="TCP粘包、拆包"></a>TCP粘包、拆包</h2><p>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</p><blockquote><p>UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p></blockquote><h3 id="什么是粘包、拆包？"><a href="#什么是粘包、拆包？" class="headerlink" title="什么是粘包、拆包？"></a>什么是粘包、拆包？</h3><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p><p><img src="/2019/11/22/Computer-Networks-Notes/640.png" alt="img"></p><p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="/2019/11/22/Computer-Networks-Notes/640-1589464020800.png" alt="img"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/j5D4MI5U9vX67Ziaria9ibcMMNVR5Gn2zUFlfF8iaLm80FnZzIicCyzckmPOVXM0CDWb7iafyVo2sre3ygo2fk0REkQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img">)<img src="/2019/11/22/Computer-Networks-Notes/640-1589464034149.png" alt="img"></p><h3 id="为什么会发生-TCP-粘包、拆包？"><a href="#为什么会发生-TCP-粘包、拆包？" class="headerlink" title="为什么会发生 TCP 粘包、拆包？"></a>为什么会发生 TCP 粘包、拆包？</h3><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><h3 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h3><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>主要特点如下：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</li><li>无连接：无连接的含义是<strong>限制每次连接只处理一个请求</strong>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP 协议是无状态协议。<strong>无状态，是指协议对于事务处理没有记忆能力</strong>。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持 B/S 及 C/S 模式。</li></ul><p>请求结构：</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261538473.png" alt="1566261538473"></p><p>响应结构：</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261644094.png" alt="1566261644094"></p><p>总结：http协议定义了web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端，http协议采用了请求响应模型，客户端向服务器发送一个请求报文，包含请求方法，url，协议版本，请求头部，请求数据；服务器以一个状态行作为响应，响应内容包括，协议版本，错误或成功信息，服务器信息，响应头部和响应数据。</p><ul><li>连接：客户端与web服务器的http端口建立一个TCP套接字连接</li><li>发送请求：即通过套接字客户端向web服务端发送一个文本的请求报文</li><li>响应：服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取</li><li>释放连接：keep-live长连接会保存一段时间，该时间内请求还会响应</li><li>客户端解析：首先解析状态行，查看表明请求是否成功的状态代码，解析响应头，响应头告知以下若干数据为数据信息，客户端按照格式解析数据，在浏览器窗口显示。</li></ul><p>URL输入后的流程？？？</p><ol><li>DNS解析：浏览器会根据url逐层查询DNS服务器缓存，解析url中的域名所对应的IP地址（DNS缓存从近到远为浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存），此时找到IP地址</li><li>TCP连接：找到IP地址后会根据IP地址和对应端口与服务器建立TCP连接（三次握手）</li><li>发送HTTP请求：浏览器会发起读取文件的http请求，</li><li>服务器处理请求并返回HTTP报文：服务器对浏览器请求响应，并把对应的带有http文本的http响应报文发送给浏览器</li><li>浏览器解析渲染页面：浏览器收到报文，解析渲染到浏览器</li><li>释放连接</li></ol><p>状态码</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261699701.png" alt="1566261699701"></p><h3 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h3><p>从三个层面来解答：</p><ul><li>Http 报文层面：GET 将请求信息放在 URL中，POST 方法报文中</li><li>数据库层面：GET 符合幂等性和安全性，POST 不符合</li><li>其他层面：GET 可以被缓存、被存储（书签），而 POST 不行</li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p><strong>Cookie 简介：</strong></p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把 Cookie 回发给服务端</li><li>服务器接收到后，会解析 Cookie 生成与客户端相对的内容</li></ul><p><strong>Cookiet 的设置以及发送过程：</strong></p><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122210015905.png" alt="image-20191122210015905"></p><p><strong>Session 简介：</strong></p><ul><li>服务端的机制，在服务端保存的信息</li><li>解析客户端请求并操作 Session id ，按需保存状态信息</li></ul><p><strong>Session 的实现方式：</strong></p><ul><li>使用 Cookie 来实现</li><li>使用 URL 回写来实现，每次在 URL 添加 Session id 信息</li></ul><p><strong>区别</strong>：</p><ul><li>Cookie 数据存放在客户端的浏览器上，Session 数据存放在服务器上</li><li>Session 相对于 Cookie 更安全</li><li>若考虑减轻服务器负担，应当使用 Cookie</li></ul><h3 id="HTTP-和-HTTPs-的区别"><a href="#HTTP-和-HTTPs-的区别" class="headerlink" title="HTTP 和 HTTPs 的区别"></a>HTTP 和 HTTPs 的区别</h3><p><img src="/2019/11/22/Computer-Networks-Notes/image-20191122210051958.png" alt="image-20191122210051958"></p><h4 id="SSL-Security-Sockets-Layer-安全套接层"><a href="#SSL-Security-Sockets-Layer-安全套接层" class="headerlink" title="SSL (Security Sockets Layer) 安全套接层"></a>SSL (Security Sockets Layer) 安全套接层</h4><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的 API，SSL 3.0 更名为 TLS</li><li>采用身份验证和数据加密来保证网络的通信的安全和数据的完整性</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTPS 需要到 CA 申请证书，HTTP 不需要</li><li>HTTPS 密文传输，HTTP 明文传输</li><li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li><li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，较 HTTP 安全</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>唯一标识一个进程：本地中使用PID；</p><p>网络中进程：IP地址+协议+端口号来唯一标识一个网络中的一个进程；</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261798658.png" alt="1566261798658"></p><p>socket通信流程</p><p><img src="/2019/11/22/Computer-Networks-Notes/1566261805698.png" alt="1566261805698"></p><ul><li><input disabled type="checkbox"> Socket通信编程</li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="OSI与TCP-IP的协议"><a href="#OSI与TCP-IP的协议" class="headerlink" title="OSI与TCP/IP的协议"></a>OSI与TCP/IP的协议</h3><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/NwMQ9mez*i97f2u6JhqrOh14XAag318f8TuAngEDQ8w!/b/dL8AAAAAAAAA&bo=eQJYAXkCWAEDKQw!&rf=viewer_4" alt="五层体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.xn--comoracle-xj3h/" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/" target="_blank" rel="noopener">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h3 id="TCP、UDP-协议的区别"><a href="#TCP、UDP-协议的区别" class="headerlink" title="TCP、UDP 协议的区别"></a>TCP、UDP 协议的区别</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/8Mtws13i04*MNhxm7c6NUQukdKULAlH2ajFaBni3uZc!/b/dDQBAAAAAAAA&bo=YQPbAGED2wADGTw!&rf=viewer_4" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><h4 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h3 id="URL-到网页显示"><a href="#URL-到网页显示" class="headerlink" title="URL 到网页显示"></a>URL 到网页显示</h3><p>图解（图片来源：《图解HTTP》）：</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/krh8m5lpufZU6OX9enXcVdQrVltJTku3irYOENXzFxM!/b/dFMBAAAAAAAA&bo=1AI.AtQCPgIDKQw!&rf=viewer_4" alt="状态码"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="各种协议与HTTP协议"><a href="#各种协议与HTTP协议" class="headerlink" title="各种协议与HTTP协议"></a>各种协议与HTTP协议</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/08ikSdkksqhIeEzyW6wrL6*jbSfpvdT2Kr.BKbEOhO4!/b/dDMBAAAAAAAA&bo=SQOpBEkDqQQDSWw!&rf=viewer_4" alt="各种协议与HTTP协议之间的关系"></p><h3 id="HTTP长连接、短连接"><a href="#HTTP长连接、短连接" class="headerlink" title="HTTP长连接、短连接"></a>HTTP长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p><h3 id="HTTP状态保存机制"><a href="#HTTP状态保存机制" class="headerlink" title="HTTP状态保存机制"></a>HTTP状态保存机制</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><h3 id="Cookie、Session的解析"><a href="#Cookie、Session的解析" class="headerlink" title="Cookie、Session的解析"></a>Cookie、Session的解析</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h4 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span>: text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span>: yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span>: tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sample_page.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.example.org</span><br><span class="line"><span class="attribute">Cookie</span>: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="HTTP-1-0与HTTP-1-1"><a href="#HTTP-1-0与HTTP-1-1" class="headerlink" title="HTTP 1.0与HTTP 1.1"></a>HTTP 1.0与HTTP 1.1</h3><blockquote><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A</a>? 的一些内容。</p></blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/mkJaDOUBzk87ThnK15P3txuYPndh*ZE.fSG4NT7DD0c!/b/dL4AAAAAAAAA&bo=kALdAJAC3QADCSw!&rf=viewer_4" alt="img"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/zJyJco59whskn9W9AoddItbQ6kJgG.hSY470evBfB2A!/b/dL8AAAAAAAAA&bo=wAILAcACCwEDGTw!&rf=viewer_4" alt="img"></p><h3 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h3><ol><li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ol><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure><h4 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h4><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h3 id="HTTP请求的-7-个步骤"><a href="#HTTP请求的-7-个步骤" class="headerlink" title="HTTP请求的 7 个步骤"></a>HTTP请求的 7 个步骤</h3><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sword For Java</title>
      <link href="/2019/08/26/Sword-For-java/"/>
      <url>/2019/08/26/Sword-For-java/</url>
      
        <content type="html"><![CDATA[<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>OSI制定的是概念框架：7层协议。</p><a id="more"></a><p>物理层：两台物理机器之间传输比特流，定义物理设备的标准，网卡</p><p>数据链路层：在传输比特流的过程会产生各种错误，数据链路层应运而生，该层定义了如何格式化数据以进行传输以及控制对物理介质的访问，还提供错误检测和纠正。该层将比特数据组成帧，交换机工作在该层，对帧解码，根据帧中的数据将信息发送到正确的接收方。</p><blockquote><p>随着网络节点的增加，点对点间的通信是需要经过多个节点的，如何找到目标节点，如何选择最佳路径是首要需求，此时产生网络层</p></blockquote><p>网络层：其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。发送方综合考虑发送优先权、网络拥塞、服务质量、可选路由的花费决定从网络中一个节点A到另一个网络中B的最佳路径，网络层处理并智能指导数据传送，路由器连接网络各端，所以路由器属于网络层。此层的数据称为数据包。本层关注TCP/IP协议中的IP协议。</p><blockquote><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，可能需要很长时间，网络在通信过程会中断多次，此时为了保证传输文件的准确性，需要对发出去的数据进行切分，切为数据段。当发生数据段络丢失，失序等情况时，传输层应运而生。</p></blockquote><p>传输层：解决主机间的数据传输，和传输质量问题。该层传输协议进行流量控制或是基于接收方可接受数据的快慢程度规定适当的发送速率。同时分割数据包以适应在网络上传输（以太网无法接受大于1500字节的数据包），分割数据为数据片，同时在数据片上给定序号，以便接受时可按序排组。需要关注TCP和UDP协议。</p><blockquote><p>为了不用用户级不要每次调用TCP打包数据，IP协议去寻找路由，现在需要自动收发包，自动寻址的功能，会话层应运而生</p></blockquote><p>会话层：作用是建立和管理应用程序之间的通信。至此可以保证用用程序能够自动收发包和寻址。</p><blockquote><p>考虑各应用程序的环境不同，如window和Linux之间的差异，需要表示层来消除</p></blockquote><p>表示层：解决不同系统之间的通信语法的问题，该层数据将按照网络能够理解的方式进行格式化。此时完成数据转化成相应的字节。</p><blockquote><p>此时发送方知道发送的数据是什么，转换成字节数据有多长，但接收方并不知道，为了发送方和接收方能够理解传输字节的含义，应用层网络协议诞生</p></blockquote><p>应用层：应用层网络协议规定消息发送方和接收方必须使用一个固定长度的一个消息头，消息头必须是固定组成，记录各种信息以方便接收方解析。该层旨在让你能够更方便的从网络中接受数据，没有该层也可以在两台主机间传递，但是我们能了解的就是一堆0101编码的字节数组。需要关注TCP/IP协议中的HTTP协议。</p><p>这是一个框架来协调和组织各层所提供的服务，但是该模型仅是概念模型，来协调进程间通信标准的制定。实际的实现是TCP/IP协议。</p><h3 id="为什么有了MAC层还要走IP层"><a href="#为什么有了MAC层还要走IP层" class="headerlink" title="为什么有了MAC层还要走IP层"></a>为什么有了MAC层还要走IP层</h3><p><code>mac地址就好像个人的身份证号，人的身份证号和人户口 所在的城市，出生的日期有关，但是和人所在的位置没有关系</code>，人是会移动的，知道一个人的身份证号，并不能找到它这个人，mac地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的mac，并不能 在网络中将数据发送给它，除非它和发送方的在同一个网 络内。所以要实现机器之间的通信，还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于 城市名+道路号+门牌号的概念。通过ip层的寻址，我们能知道按何种路径在全世界任意两台Internet上的的机器间传输数据</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>IP协议是无连接的协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求每条线可以同时满足许多不同计算机之间的通信需要。通过IP协议，消息或者其他数据会被分割为较小的包，并通过因特网在计算机之间传送，IP负责将每个包路由至他的目的地，但是IP协议未作任何事来确认数据包是否安全到达，所以他是不可靠的，需要他的上层协议来控制。传输控制协议TCP是传输层的协议。（简介）</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261200266.png" alt="1566261200266"></p><p>TCP报文头：</p><p>源端口和目的端口各2个字节，TCP/UDP都是不包含IP地址信息的，两者头部都会有端口号，这是在传输层范畴的知识。两个进程在计算机内部进行通信可以有：管道、内存共享、信号量和消息队列等方法。其中最唯一要求是唯一的表示对方进程，在本地进程中可以使用PID，但是在网络中的不同主机中使用便失效了，解决方式就是在传输层中使用协议端口号，已知在网络层中IP可以唯一标识一个主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样可以利用IP地址+协议+端口号这样的唯一标识去表示网络中的一个进程，这种方式也成为套接字。这样，虽然通信的重点是应用进程，但是我们只要把要传送的报文交到目的主机的某一个合适端口中，剩下的工作就由TCP来完成了。</p><p>sequence number（seq序号）4字节，tcp连接中传送的字节流中的每个字节都有序号，例如一段报文的序号字段值是107，携带的数据字节数是100，那么下一个报文段的序号就是107+100，即从207开始。</p><p>ACK number（ack序号）4字节，表示期望收到对方下一个报文的第一个字节的序号。例如B收到A发送的报文seq序号是301，全部数据是200字节，B正确收到从A发送的序号到500（301+200-1）的数据，所以B期望收到的A的下一个数据序号是501，于是，B在发送给A的确认报文中，会把ack确认号置为501。</p><p>TCP Flags</p><ul><li>ACK：确认序号标志，1有效，0表示报文中不含确认信息，忽略确认号字段</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接，1时表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul><p>Window窗口：滑动窗口大小，告知发送端接收端的缓存大小（还有多少空间可以接收数据），以此控制发送端发送数据速率，从而达到流量控制</p><p>通信过程：</p><p>当应用程序希望通过TCP和另一个应用程序通信时，会发送一个通信请求，必须有一个确切地址，在双方握手后TCP将在两个程序间建立一个全双工的通信，将占据两个计算机的通信线路，直到双方关闭为止。（三次握手）</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261217747.png" alt="1566261217747"></p><p>第一次A发送seq=x，B响应时，ack=x+1表示期望下一个从A发来的报文字节从x+1开始，同时B也发送一个自己的缓存初始化序列号seq=y，这里第二次握手完成。A收到确认后，还要向B给出一个确认：小ack=y+1，表示期望从B接受到的报文字节从y+1开始，同时，自己的报文序号从seq=x+1开始（B告知的），此时TCP连接建立，其中第三个报文可以携带数据，前两个不可以。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261228418.png" alt="1566261228418"></p><p>为什么要三次连接？</p><p>为了初始化Sequence Number 的初始值，通信双方要互相通知初始化的Sequence Number，也就是x和y，这是是作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输发生错误，即TCP会用这个数值来拼接数据。所以需要第三次握手：告知服务端，客户端已经知道了你的Sequence Number 了。</p><p>第一次握手的隐患！SYN的超时问题！</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261239169.png" alt="1566261239169"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261247780.png" alt="1566261247780"></p><p>连接后客户端故障怎么办？</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261257369.png" alt="1566261257369"></p><p>TCP四次挥手？</p><p>即断开连接时需要客户端和服务端总共发送4各数据包来确认断开连接。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261278901.png" alt="1566261278901"></p><p>客户端开始发送连接释放报文，并且停止发送数据，FIN=1，seq=u（已传送的最后一个字节的序号）；服务器收到后发出确认报文，ACK=1，小ack=u+1（表示期望从客户端收到的下一个报文从字节u+1开始），seq=v（表示自己的序列号）；此时服务端进入关闭等待状态，TCP通知高层进程客户端要释放联系了，这是出于半关闭状态：即客户端已经不发送数据了，服务端发送数据客户端还是会接受的。此时客户端进入等待关闭状态2，等待服务器的第3次挥手请求。等到服务器发送完数据后，服务器便发送连接释放报文，FIN=1，ACK=1，ack=u+1（表示客户端发送的下一个报文字节号从哪开始），seq=w（表示自己的序列号）；最后，客户端发送确认报文，ACK=1，ack=w+1，seq=u+1（自己的序号），此时客户端进入等待状态，还没完全关闭（2MSL），服务端已经完全关闭，完成4次挥手。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261354806.png" alt="1566261354806"></p><p>为什么客户端要等待2MSL再关闭？</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261362533.png" alt="1566261362533"></p><p>为什么需要四次挥手？</p><p>因为全双工，发送方和接收方都需要FIN报文和ACK报文，即发送方和接收方各只需两次挥手，因为有一方是被动的，所以看上去是4次挥手。？？？？？？？？？？？</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261373431.png" alt="1566261373431"></p><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p>不支持像TCP滑动窗口、错误重传等机制。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261476354.png" alt="1566261476354"></p><p>吞吐量不受拥塞控制。面向报文，添加首部后直接向下交付给IP层</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261484934.png" alt="1566261484934"></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>RTT：发送一个数据包到接收到对应ACK，所花费的时间</p><p>RTO：TCP在发送一个数据报后会启用数据重传计时器，收到ACK时他就失效，未收到ACK而且计时器时间也到了，那就要重传。</p><p>为了实现数据的批量传送，同时解决可靠性和包乱序的问题，所以TCP需要知道网络实际的处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261500714.png" alt="1566261500714"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261526343.png" alt="1566261526343"></p><p>特点：客户端像服务端请求数据的时候只需传送请求方法（get/post等）和路径。http1.1开始默认使用长连接，即服务器需要等待一段时间才断开连接。无状态协议，指协议对事物处理无记忆能力。</p><p>请求结构：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261538473.png" alt="1566261538473"></p><p>响应结构：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261644094.png" alt="1566261644094"></p><p>总结：http协议定义了web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端，http协议采用了请求响应模型，客户端向服务器发送一个请求报文，包含请求方法，url，协议版本，请求头部，请求数据；服务器以一个状态行作为响应，响应内容包括，协议版本，错误或成功信息，服务器信息，响应头部和响应数据。</p><ul><li>连接：客户端与web服务器的http端口建立一个TCP套接字连接</li><li>发送请求：即通过套接字客户端向web服务端发送一个文本的请求报文</li><li>响应：服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取</li><li>释放连接：keep-live长连接会保存一段时间，该时间内请求还会响应</li><li>客户端解析：首先解析状态行，查看表明请求是否成功的状态代码，解析响应头，响应头告知以下若干数据为数据信息，客户端按照格式解析数据，在浏览器窗口显示。</li></ul><p>URL输入后的流程？？？</p><ol><li>DNS解析：浏览器会根据url逐层查询DNS服务器缓存，解析url中的域名所对应的IP地址（DNS缓存从近到远为浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存），此时找到IP地址</li><li>TCP连接：找到IP地址后会根据IP地址和对应端口与服务器建立TCP连接（三次握手）</li><li>发送HTTP请求：浏览器会发起读取文件的http请求，</li><li>服务器处理请求并返回HTTP报文：服务器对浏览器请求响应，并把对应的带有http文本的http响应报文发送给浏览器</li><li>浏览器解析渲染页面：浏览器收到报文，解析渲染到浏览器</li><li>释放连接</li></ol><p>状态码</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261699701.png" alt="1566261699701"></p><p>GET和POST请求区别</p><ol><li>Http报文层：get将请求信息放在url中，请求信息和url以问号？隔开，请求信息的格式为键值对；post请求将请求信息放在报文体中，想获得请求信息必须解析报文，因此安全性较高。而且get请求会有长度限制，post无限制。</li><li>数据库层面：get符合幂等性和安全性，多次访问数据库的结果是一样的，不改变数据库的值；post都不符合。</li><li>其他层面：get请求能够被缓存，保存在浏览器的浏览记录中；post不具备。通常绝大部分的get请求都被cdn缓存了，大大减少了服务器的压力，而post请求必须要服务器来处理。</li></ol><p>cookie和session的区别</p><p>因为Http是无状态的，每次我们访问有登陆需求的业务时都要输入账号密码，使用cookie和session避免了这种情况。</p><p>cookie：客户端机制。由服务器发送给客户端的特殊信息，以文本的形式存放在客户端，客户端每次向服务器发送请求的时候都会带上这些特殊信息；当客户使用浏览器访问一个支持cookie的网站时，用户会提供一个包括用户名在内的个人信息并且提交至服务器，紧接着服务器向客户端回传相应的超文本时也会发回这些个人信息，这些是放在http响应头中，当用户端接受来自服务器的响应后，浏览器会将这些信息存放在统一位置，自此客户端再向服务器发送请求的时候，会把相应的cookie再次发送至服务器中，这次cookie将会存放在http请求头中，有了cookie后，服务端再次接受请求后，会解析存在于请求头中的cookie得到客户端特有的信息，从而动态生成与该客户端相应的内容。</p><p>cookie的设置和发送过程：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261750519.png" alt="1566261750519"></p><p>session：服务器端机制。当程序需要为某个客户端请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识，称为sessionId，如果包含，则说明以前已为该客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到就生成一个）。不包含就创建一个session和与此相关的sessionId。这个sessionId将会回发给客户端进行保存。</p><p>实现方式：</p><p>使用cookie实现，服务器给每个session分配一个唯一的JSESSIONID，并通过cookie发送给客户端，待客户端发送新的请求时，将在cookie头中携带这个JSESSIONID，这样服务器能够找到客户端对应的session。</p><p>使用URL重写实现，是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID参数，这样客户端点击任何链接都会将JSESSIONID带回服务器。如果直接在浏览器输入服务器资源url，是请求不到session的，tomcat对session的实现是同时使用cookie和url重写。</p><p>区别：</p><p>cookie数据存放在客户的浏览器上，session数据放在服务器上</p><p>session相对于本地存放的cookie更安全</p><p>session会一定时间内保存在服务器上，当缓存增多时会影响服务器性能，应当使用cookie</p><p>HTTP和HTTPS</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261761422.png" alt="1566261761422"></p><p>简单说就是安全版的http协议。</p><p>SSL：</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议。</li><li>是操作系统对外的API，后更名为TLS</li><li>采用身份验证和数字加密保证安全性</li></ul><p>加密的方式：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261769541.png" alt="1566261769541"></p><p>数字签名：就是在信息后面加上一段内容，这些内容证明信息没有被修改过。</p><p>HTTPS流程：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261778815.png" alt="1566261778815"></p><p>区别：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261789814.png" alt="1566261789814"></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>唯一标识一个进程：本地中使用PID；</p><p>网络中进程：IP地址+协议+端口号来唯一标识一个网络中的一个进程；</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261798658.png" alt="1566261798658"></p><p>socket通信流程</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261805698.png" alt="1566261805698"></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261813252.png" alt="1566261813252"></p><h3 id="题：如何设计一个数据库"><a href="#题：如何设计一个数据库" class="headerlink" title="题：如何设计一个数据库"></a>题：如何设计一个数据库</h3><p>开始设计</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261820297.png" alt="1566261820297"></p><p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p><p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p><p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><p>为什么使用索引？</p><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p><p>什么样的信息能够称为索引？</p><p>主键，唯一键，普通键，有一定区分性</p><p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p><blockquote><p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p></blockquote><p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p><blockquote><p>唯一键不是主键，但主键有不可重复性</p><p>一张表可以有多个唯一键，但只能有一个主键</p></blockquote><p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p><p>磁盘文件存储</p><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>索引的数据结构？</p><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p><p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261830802.png" alt="1566261830802"></p><p>特性：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261842897.png" alt="1566261842897"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261850318.png" alt="1566261850318"></p><p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p><p>B+树：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261860507.png" alt="1566261860507"></p><p>结论：B+树更适合，原因：</p><p>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</p><p>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</p><p>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</p><p>Hash索引了解一下：</p><p>缺点：</p><ul><li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li><li>无法运用索引值来排序</li><li>不能利用部分索引键查询</li><li>不能避免表扫描，哈希值可能重复，需要全表扫描</li><li>大量hash值相等时，效率很底。</li></ul><p>密集索引和稀疏索引</p><p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列的数据。</p><blockquote><p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p></blockquote><p>稀疏索引：叶子节点仅保存了键位信息及其主键。</p><p>InnoDB的索引</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261871063.png" alt="1566261871063"></p><p>如何定位并优化慢查询sql？</p><ul><li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262283010.png" alt="1566262283010"></p></li><li><p>使用explain等工具分析sql</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262067821.png" alt="1566262067821"></p><ul><li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li><li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261930304.png" alt="1566261930304"></p><ul><li>字段：extra，如图</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566261963108.png" alt="1566261963108"></p></li><li><p>修改sql或者尽量让sql走索引</p><ul><li>改用索引查</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262116465.png" alt="1566262116465"></p><ul><li>添加索引</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262137053.png" alt="1566262137053"></p></li><li><p>使用fore_index()测试那个索引更好</p></li></ul><p>联合索引的最左匹配原则的成因？</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262151740.png" alt="1566262151740"></p><p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p><p>索引建立的越多越好吗？</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262159079.png" alt="1566262159079"></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>Myisam：表级锁，不支持行级锁</p><p>InnoDB：默认行级锁，支持表级锁，</p><blockquote><p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p></blockquote><p>无论表锁还是行锁，默认都分为共享锁和排他锁</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566262385992.png" alt="1566262385992"></p><p>场景分析：</p><p>MyISAM</p><ul><li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li><li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li><li>适合没有事务的</li></ul><p>InnoDB</p><ul><li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li><li>支持事务的系统</li></ul><p>数据库锁分类：</p><ul><li>按粒度划分：表级锁，行级锁，页级锁</li><li>按级别划分：共享锁，排他锁</li><li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li><li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li><li>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</li></ul><p>数据库事务的特性</p><p>ACID：原子性，一致性，隔离性，持久性</p><p>事务的隔离性以及各级别下的并发问题</p><p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p><p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事物读取另一个事务未提交数据</p><p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p><p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566263834174.png" alt="1566263834174"></p><p>InnoDB在可重复度隔离级别下是如何避免幻读？</p><p>表象：快照度（非阻塞读）——伪MVCC</p><p>内在：next-key锁（行锁+gap锁）</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566264130165.png" alt="1566264130165"></p><p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p><p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p><p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p><ol><li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li><li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li></ol><p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566265001814.png" alt="1566265001814"></p><p>再次修改为（11，32，45）时会发生：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566264973315.png" alt="1566264973315"></p><ol start="3"><li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li></ol><p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p><p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p><p>next-key锁（行锁+gap锁）</p><ul><li>行锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</li><li>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</li></ul><p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p><p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p><ul><li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li><li>如果where条件部分命中或者未命中，就会加上gap锁</li></ul><p>gap锁会出现在非唯一索引或者不走索引的当前读中</p><p>非唯一索引：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566268250911.png" alt="1566268250911"></p><p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p><p>不走索引</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566268427287.png" alt="1566268427287"></p><p>会对所有gap上锁，类似表锁，也能防止幻读。</p><p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="linux体系结构"><a href="#linux体系结构" class="headerlink" title="linux体系结构"></a>linux体系结构</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528183180.png" alt="1566528183180"></p><p>在Linux系统启动时候首先会启动内核，内核程序直接管理硬件，包括CPU、内存空间、硬盘接口、网络接口等。所有的计算机操作都要通过内核传递给硬件设备。用户态及上层应用程序的活动空间、应用程序的执行必须依托于内核提供的资源，包括cpu资源、存储资源、IO资源等，为了使上层应用能够访问这些资源，内核必须为这些上层应用提供访问的接口，即系统调用；可以将其视为一种不能再简化的操作，一个操作系统上的功能可以看作是系统调用的组合结果。公用函数库是对系统调用的组合。</p><p>shell：是一个特殊的应用程序，本质是一个命令解释器。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>查找文件</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528347788.png" alt="1566528347788"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528549046.png" alt="1566528549046"></p><p>文本检索、</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528593466.png" alt="1566528593466"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528850938.png" alt="1566528850938"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528627788.png" alt="1566528627788"></p><p>文件内容的统计</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528687004.png" alt="1566528687004"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528703425.png" alt="1566528703425"></p><p>替换文本内容</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528735871.png" alt="1566528735871"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566528789476.png" alt="1566528789476"></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Mysql数据库也有缓存，但是是针对查询内容，一般只有表中的数据没有变动的时候，缓存才有作用，这并不能减轻业务系统对数据库的I/O压力，因此缓存数据库应运而生。</p><p>缓存数据库：实现对热点数据的高速缓存，提高响应速度，缓解后端数据库的压力。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566269898991.png" alt="1566269898991"></p><blockquote><p>熔断：存储层挂了，直接访问缓存层。</p><p>穿透：未在缓存中换取数据，直接访问存储层</p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566270011709.png" alt="1566270011709"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566270041007.png" alt="1566270041007"></p><p>为什么Redis这么快？</p><ul><li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li><li>数据结构简单，操作也就简单；</li><li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li><li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li><li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li></ul><blockquote><p>FD：一个打开文件通过唯一的描述符进行引用。</p></blockquote><p>传统的IO阻塞模型，当进行读写操作时，不可读或者不可写时，整个redis就不会对其它操作进行响应，导致整个服务不可用。</p><p>IO多路复用调用，这其中最重要的函数调用就是select系统调用，select能够同时监控多个文件描述符的可读可写情况，当文件描述符可读可写时就会返回响应的参数，即将监听文件读写情况的任务交给select，程序就可以继续做别的而不被堵塞</p><p>基于react设计模式来实现文件事件处理器，文件事件处理器使用IO多路复用模块同时监听多个FD，当发生文件读写函数（read、write、close等）事件时，文件事件处理器就会回调FD绑定的事件处理器，虽然文件事件处理器是在单线程上，但是通过IO多路复用，实现同时对多个FD读写的监控，提高了网络通信模型的性能。</p><p>同时也有其他的IO多路复用函数：</p><ul><li>evport：Linux</li><li>kqueue：MAC OS</li><li>select：都兼容，作为保底函数，O(n)</li></ul><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>String类型：最基本的，二进制安全（即可以包含任何数据），常用的key-value键值对，最大可存储512M，底层由简单动态字符串实现。</p><blockquote><p>案例：记录一个用户每天访问这个网站的次数，只需要拼接用户id和代表当前时间的字符串作为key，每次用户访问时对这个页面时，对这个字符执行incr命令即可，就可以统计用户当天访问站点的次数。</p></blockquote><p>Hash：String元素组成的，适合存储对象</p><p>List：按照String插入元素顺序排序，类似于栈的，使用可以用于最新消息，排行榜</p><p>Set：String类组成的无序集合，通过hash表实现，不允许重复，使用于共同关注，共同喜好值之类的交并集操作</p><p>Sorted Set：通过分数(double类型的)来为集合中的成员进行从小到大的排序，不重复</p><p>例题：从海量key中查询某一固定前缀的Key？</p><ol><li>数据规模大小</li><li>误区：用keys pattern扫描出符合条件的key列表，问题在于当redis正在执行服务时会发生什么？当key的数量过大时会发生内存消耗过大而卡顿</li><li>正确：使用SCAN cursor指令，每次只会返回少量元素；基于游标的迭代器，基于上一次的游标延续之前的迭代过程</li></ol><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566517280989.png" alt="1566517280989"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566517363631.png" alt="1566517363631"></p><p>如何通过Redis实现分布式锁？</p><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p><ul><li>互斥性：任意时刻，只能有一个客户端获取锁；</li><li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li><li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li><li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566518008463.png" alt="1566518008463"></p><p>SETNX的原子操作和保持不变，可以用来实现分布式锁。在执行一段程序时，可以先尝试对某个key设值，如果设值成功则表示当时没有别的线程在执行该段代码或者说占用该独占资源。这里需要解决的就是key值的时间问题，因为SETNX设置完该值就存在了。</p><p>解决key值得时效问题：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566518578527.png" alt="1566518578527"></p><p>缺点的原子性在于：如果一个线程只执行到setnx语句后就挂了，那么设置的key值将会一直存在，其他线程就无法访问后面的资源。两个原子操作（setnx和expire）组合成一个逻辑，就变得不是原子操作了。</p><p>正确操作：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566518903284.png" alt="1566518903284"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566518969999.png" alt="1566518969999"></p><p>如果有大量key同时过期得注意事项?</p><ol><li>集中过期时处理key会很耗时，出现卡顿现象</li><li>解决：在设置key过期时间时，加上随机值</li></ol><p>如何使用Redis做异步队列？</p><p>使用List作为队列，RPUSH生产消息，LPOP消费消息。</p><ul><li>缺点：在于没有等待队列中有值（消息）时就直接消费，</li><li>处理：可以通过应用层引入Sleep机制去调用LPOP重试。</li></ul><p>加上无消息时阻塞方式</p><ul><li>缺点：生产得消息只能供一个消费者使用，用完就没了</li><li>改进：使用主题订阅者模式</li></ul><p>pub/sub主题订阅者模式</p><ul><li>发送者pub发送消息，订阅者sub接收消息</li><li>订阅者可以订阅任意数量得频道</li><li>缺点：消息得发布是无状态的，无法保证可达，对发布者来说消息是即发即失的，如果消息发送时一个订阅者下线了，重新上线时，消息是不会重新收到的，要解决这个问题需要使用专业的消息队列，例如kafuka等。</li></ul><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>RDB（快照）持久化：即保存某个时间点的全量数据快照；</p><ul><li>创建方式：save，使用主线程执行快照，该方法会阻塞redis的服务器进程（阻塞客户端请求操作），直到快照文件被创建完毕（很少用）</li><li>bgsave，会fork出一个子进程来创建rdb文件，不会阻塞服务器进程，父进程通过轮询接受子进程完成的信号</li><li>其他自动化出发RDB持久化</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566520939557.png" alt="1566520939557"></p><p>BGSAVE底层实现方式：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566521057383.png" alt="1566521057383"></p><ol><li>查询子进程是否有冲突</li><li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li></ol><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566521457362.png" alt="1566521457362"></p><p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p><p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566522571316.png" alt="1566522571316"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566522633940.png" alt="1566522633940"></p><p>使用日志重写解决aof文件不断增大的问题</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524281028.png" alt="1566524281028"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524319355.png" alt="1566524319355"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524383680.png" alt="1566524383680"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524408719.png" alt="1566524408719"></p><p>子进程在做aof重写时，会通过管道从父进程读取增量数据，并缓存下来；在以rdb格式做全量持久时，也会从管道读取数据，同时不会造成管道阻塞，也就是aof文件前半段是rdb格式的全量数据，后半段是redis命令格式的增量数据。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524467090.png" alt="1566524467090"></p><p>redis实例重启时会使用bgsave持久化文件重新构建内容，再使用aof重放近期的操作指令，使用两者结合恢复重启之前的状态。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566524719291.png" alt="1566524719291"></p><p>如果同时需要执行大量命令，就需要等待上一条命令应答完成，这中间会有大量来回交互的时间和IO磁盘操作，为了提升效率，使用Pipeline可允许客户端一次发送多条命令，而不需要上一条命令的结果，客户端首先将命令写入缓存中，再一次性发送给redis，这样pipeline可以将多次io往返是的时间缩减为一次。（注：这里的命令指无相关性的命令）</p><h3 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h3><p>主从同步原理</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566525604430.png" alt="1566525604430"></p><ul><li>一个M：写；</li><li>若干个S：读；定期的数据备份也是在其中选择一个实例完成。</li></ul><p>这里不需要M，S的实时一致性，而是保持一种弱一致性，即一段时间后的最终一致性</p><p>同步操作：主节点做一次BGSAVE，并同时将后续修改操作记录在内存的缓存中，待完成后将RDB文件全量同步到从节点，从节点接收后，就将RDB镜像加载到内存中，加载完成后，再通知主节点将期间的修改操作记录即增量操作同步到从节点进行重放，就完成了同步过程。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566526103267.png" alt="1566526103267"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566526205097.png" alt="1566526205097"></p><p>Redis哨兵</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566526286410.png" alt="1566526286410"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566526378478.png" alt="1566526378478"></p><h3 id="Redis的集群管理"><a href="#Redis的集群管理" class="headerlink" title="Redis的集群管理"></a>Redis的集群管理</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566526471318.png" alt="1566526471318"></p><p>这样就实现了数据分片，通过数据分片，实现单节点服务器的压力。Redis集群才用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其它节点连接，使用Gossip协议传播信息和发现新的节点。redis节点的目的是将不同的key分散放在不同的节点，通常是获取key的hash值，但是节点动态增减时会有问题。</p><p>Redis采用的是一致性哈希算法。使用哈希环，先在环上确定节点位置，存储数据时同样计算key哈希值在环上位置，顺时针寻找离key最近的节点存储数据。</p><blockquote><p>一致性哈希在节点个数过少时也有个数据倾斜的问题，解决方式是引入虚拟节点，一个节点计算多个哈希值放在环中。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566270540934.png" alt="1566270540934"></p><h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566270931694.png" alt="1566270931694"></p><p>编译生成字节码，字节码保存在.class文件中，.class文件在各种JVM中运行。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566270966871.png" alt="1566270966871"></p><p>为什么JVM不直接将源码解析成机器码去执行？</p><p>因为每次执行都需要各种检查（java语法句法的检查），都要重新编译一次，在程序整体的性能就很受影响。所以引入中间字节码。</p><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566530314661.png" alt="1566530314661"></p><p>Class.forName()函数返回与给定的字符串名称相关的类或者接口的class对象。（返回一个给定类或者接口的一个 Class 对象）</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566271359683.png" alt="1566271359683"></p><p>一句话：反射就是将Java中的各种成分映射成一个个对象（下面代码中的Class，Method），然后获取。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566538204663.png" alt="1566538204663"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566271649284.png" alt="1566271649284"></p><ol><li>Clas.forName(类全路径)的方式获取类对象：rc</li><li>创建这个实例：r</li><li>获取throwHello这个方法getHello，使用Method这个对象，getDeclareMethod()能返回共有或者私有的方法，不能获取继承的方法</li><li>调用这个方法，invoke(对象实例，参数)</li><li>使用getMethod()可以调用公有方法，还能获取继承和接口实现的方法</li></ol><p><strong>Java类从编译到执行的过程</strong></p><p>由上面的反射发现：之所以能获取类的属性或者方法并对其调用，必须要获取class对象，要获取该类的class对象，必须要获取该类的字节码文件对象。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566539503027.png" alt="1566539503027"></p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566539550619.png" alt="1566539550619"></p><ul><li>抽象类</li><li>提供类加载方式的接口</li><li>loadClass()：通过给定一个类名去加载这个类，返回代表这类的class的实例，发现其中有很多Classloader类</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566539925530.png" alt="1566539925530"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566539976907.png" alt="1566539976907"></p><p>AppClassLoader会去java.class.path路径中去找编译好的class文件：ReflectSample.calss、Robot.class，执行时就会加载这两个文件。</p><h3 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h3><p>不同的ClassLoader加载类的方式和路径各不相同，为了明确分工，加载类的时候，各类ClassLoader按照自己管理的区域各司其职，需要一个机制管理，这就是双亲委派机制。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566540879924.png" alt="1566540879924"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566541051079.png" alt="1566541051079"></p><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566541089646.png" alt="1566541089646"></p><p>隐示加载方法不需要使用newInstance()方法获取实例，并且支持带参数的构造器（可以使用构造函数传入参数）生成对象实例</p><p>显示加载的方式获取类对象后，需要使用newInstance()方法获取对象实例，不支持传入参数，需要通过反射，调用构造器的newInstance()方法，才能使用参数？？？？？？</p><p>都能在运行时对任意一个类，知道该类的所有属性和方法，队友任意一个对象，能调用他的任意方法和属性。</p><p><strong>Java类的装载过程：</strong></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566541766165.png" alt="1566541766165"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566541877658.png" alt="1566541877658"></p><p>SpringIOC资源加载器在获取要读取的资源时，即读取spring Bean的配置文件时，如果是以classpath的方式加载，就需要使用classloader方式加载，这样做是和SpringIOC的延时加载有关，目的是为了加快初始化速度，不执行加载中链接、初始化步骤，加快加载速度，把这些工作留到实际使用时再去做。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566542351974.png" alt="1566542351974"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566542443473.png" alt="1566542443473"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566542526507.png" alt="1566542526507"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566542550343.png" alt="1566542550343"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566542572034.png" alt="1566542572034"></p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>标准：没有被其他对象引用；</p><h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566280952080.png" alt="1566280952080"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566280970515.png" alt="1566280970515"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281027327.png" alt="1566281027327"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281116146.png" alt="1566281116146"></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281167400.png" alt="1566281167400"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281260890.png" alt="1566281260890"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281297740.png" alt="1566281297740"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281358412.png" alt="1566281358412"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281417461.png" alt="1566281417461"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281459812.png" alt="1566281459812"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281495964.png" alt="1566281495964"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281533807.png" alt="1566281533807"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281682294.png" alt="1566281682294"></p><p>新生代：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566281754772.png" alt="1566281754772"></p><p>每次使用一块Eden和一块survivor，进行垃圾回收时，将这两个中存活的对象一次性复制到另一个survivor。复制一次，对象年龄加 1 ，当年龄达到15（默认的）岁时，就会进入老年代。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282162342.png" alt="1566282162342"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282206402.png" alt="1566282206402"></p><p>老年代：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282262255.png" alt="1566282262255"></p><p>当发生老年代的GC时，通常也会伴随着年轻代的GC，对整个堆进行垃圾回收，Full GC。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282462012.png" alt="1566282462012"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282604274.png" alt="1566282604274"></p><blockquote><p>调用了System.gc()只是告诉虚拟机要回收，但究竟什么时候回收由虚拟机说了算。</p></blockquote><p>永久代时jdk7及以下才有的，8使用元空间代替了，一个原因就是降低Full GC的频率，减小GC的负担。</p><p>GC发生时：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282779359.png" alt="1566282779359"></p><p>GC安全点，GC开始前，让程序“停在某个地方”</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566282872797.png" alt="1566282872797"></p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283101929.png" alt="1566283101929"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283143252.png" alt="1566283143252"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283216314.png" alt="1566283216314"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283265976.png" alt="1566283265976"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283314476.png" alt="1566283314476"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283430988.png" alt="1566283430988"></p><p>CMS使GC线程和用户线程并发</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283521787.png" alt="1566283521787"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566283567047.png" alt="1566283567047"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566284005512.png" alt="1566284005512"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566284156542.png" alt="1566284156542"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566284237462.png" alt="1566284237462"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566284288209.png" alt="1566284288209"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566284328030.png" alt="1566284328030"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>串行→批处理（程序）→进程→线程</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566346496101.png" alt="1566346496101"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566634603893.png" alt="1566634603893"></p><p>进程拥有一个完整的虚拟内存地址空间，当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。线程只有相关堆栈寄存器、程序计数器和线程控制表TCB组成，寄存器可用来存储局部标量，但不能存储其他线程的相关变量。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566634628484.png" alt="1566634628484"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566346516168.png" alt="1566346516168"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566634813194.png" alt="1566634813194"></p><ul><li>每一个JVM实例唯一对应一个堆，每个线程有唯一私有的栈。</li><li>一个程序是一个可执行文件，一个进程是一个执行中程序的实例。</li></ul><h3 id="Java线程中start和run的区别？"><a href="#Java线程中start和run的区别？" class="headerlink" title="Java线程中start和run的区别？"></a>Java线程中start和run的区别？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    syso.(<span class="string">"current Thread is :"</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            attack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    syso.(<span class="string">"current main thread is :"</span> + Thread.currentThread().getName());</span><br><span class="line">    t.run();<span class="comment">//两个打印执行结果都是main线程</span></span><br><span class="line">    t.start();<span class="comment">//结果为：主线程main；和另一个线程Thread-0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start</code>方法源码调用的是一个native的方法<code>start0</code>，<code>start0</code>方法调用的是JVM的<code>JVM_StarThread</code>方法。该层源码中的关键语句是：<code>native_thread = new JavaThread(&amp;thread_entry, sz)</code></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739211692.png" alt="1566739211692"></p><p>即start方法会调用JVM_StartThread方法去创建已给新的线程，并通过Thread#run()方法去调用方法；</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739228427.png" alt="1566739228427"></p><h3 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a>Thread和Runnable</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739241431.png" alt="1566739241431"></p><p>如何给run()方法传参</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739254477.png" alt="1566739254477"></p><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><p>主线程等待方法；</p><p>使用Thread类的join()方法阻塞当前线程以等待子线程处理；</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739268790.png" alt="1566739268790"></p><p>通过Callable接口实现：通过Future Or 线程池获取</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739287783.png" alt="1566739287783"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739300563.png" alt="1566739300563"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739313007.png" alt="1566739313007"></p><h3 id="Sleep和Wait方法"><a href="#Sleep和Wait方法" class="headerlink" title="Sleep和Wait方法"></a>Sleep和Wait方法</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739324885.png" alt="1566739324885"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739335235.png" alt="1566739335235"></p><blockquote><p>wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p><p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p><p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p><p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。  </p></blockquote><p>锁池</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739344235.png" alt="1566739344235"></p><p>等待池</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739353388.png" alt="1566739353388"></p><h3 id="notify和notifyAll"><a href="#notify和notifyAll" class="headerlink" title="notify和notifyAll"></a>notify和notifyAll</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739364448.png" alt="1566739364448"></p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566739786416.png" alt="1566739786416"></p><p>当前线程A的暗示调度器让出CPU给线程B，但是调度器可以选择忽视或者执行。</p><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>stop()方法，已抛弃，问题包括突然停止不好清理线程，会释放锁，造成数据不一致等。</p><p>当前方法：interrupt()方法，通知线程应该中断，</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566740196347.png" alt="1566740196347"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566740234431.png" alt="1566740234431"></p><p><a href="https://www.bilibili.com/video/av62633602?p=74" target="_blank" rel="noopener">详细解释</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566740538242.png" alt="1566740538242"></p><h3 id="同步和互斥的区别："><a href="#同步和互斥的区别：" class="headerlink" title="同步和互斥的区别："></a>同步和互斥的区别：</h3><p>各个线程可以访问进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括</p><p>1、间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步</p><p>所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>2、直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系</p><p>所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上(大多数情况)，通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><h3 id="进程间的通信方式："><a href="#进程间的通信方式：" class="headerlink" title="进程间的通信方式："></a>进程间的通信方式：</h3><p>1.管道(pipe)及有名管道(named pipe)：</p><blockquote><p>管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p></blockquote><p>2.信号(signal)：</p><blockquote><p>信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></blockquote><p>3.消息队列(message queue)：</p><blockquote><p>消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p></blockquote><p>4.共享内存(shared memory)：</p><blockquote><p>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p></blockquote><p>5.信号量(semaphore)：</p><blockquote><p>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p></blockquote><p>6.套接字(socket)；</p><blockquote><p>这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p></blockquote><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>使用全局变量</p><blockquote><p>主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile（易变的）</p></blockquote><p>使用消息实现通信</p><blockquote><p>在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。<br>1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;<br>2)添加消息函数声明afx_msg int OnTSendmsg();<br>3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)<br>4)添加OnTSM()的实现函数；<br>5)在线程函数中添加PostMessage消息Post函数</p></blockquote><p>使用事件CEvent类实现线程间通信</p><blockquote><p>Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。<br>1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；<br>2)threadStart.SetEvent();使其处于通信状态；<br>3)调用WaitForSingleObject()来监视CEvent对象</p></blockquote><h3 id="线程间的同步方式有四种"><a href="#线程间的同步方式有四种" class="headerlink" title="线程间的同步方式有四种"></a>线程间的同步方式有四种</h3><p>临界区</p><blockquote><p>临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。<br>PS:关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）</p></blockquote><p>互斥量</p><blockquote><p>互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。<br>PS:1、互斥量由于也有线程所有权的概念，故也只能进行线程间的资源互斥访问，不能由于线程同步；<br>2、由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了”遗弃”问题</p></blockquote><p>信号量</p><blockquote><p>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作<br>PS:事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信</p></blockquote><p>事件</p><blockquote><p>事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。<br>PS:事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题</p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566740782536.png" alt="1566740782536"></p><p>这时要引入互斥锁，目的是互斥访问，特性如下：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566740966586.png" alt="1566740966586"></p><p>关键字synchronized可以满足上述特性。根据获取的锁的分类：获取对象锁和获取类锁！！！</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566741172390.png" alt="1566741172390"></p><p>2表示使用synchronized修饰的方法（method）<a href="https://www.bilibili.com/video/av62633602?p=77" target="_blank" rel="noopener">代码解释</a></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566741606620.png" alt="1566741606620"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566741663767.png" alt="1566741663767"></p><h3 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h3><p>两个要点：</p><ul><li>Java对象头</li><li>Monitor</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566741979672.png" alt="1566741979672"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566742014520.png" alt="1566742014520"></p><blockquote><p>轻量级锁和偏向锁是1.6后对锁的优化。</p></blockquote><p>Monitor相当于Java对象天生自带的一把看不见的锁（或称监视器锁，一种同步机制或同步对象）</p><p>重量级锁指针指向的就是Monitor对象的起始地址（每个对象都有一个Monitor对象与之关联）；Monitor对象中的关键属性如下：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566742496980.png" alt="1566742496980"></p><p>Monitor对象存在于每个Java对象的对象头中，</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566742578548.png" alt="1566742578548"></p><p>查看编译后的指令，monitorenter进入同步块，monitorexit表示退出，两者配对表示monitor锁。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566742741353.png" alt="1566742741353"></p><p>锁的重入：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566742914574.png" alt="1566742914574"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566743138977.png" alt="1566743138977"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566743185944.png" alt="1566743185944"></p><h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><ul><li>自旋锁</li><li>线程A想要获取线程B占有的资源，就让线程A执行时等一会但是不放弃CPU的时间</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566743670713.png" alt="1566743670713"></p><ul><li>自适应自旋锁</li><li>应该是自旋等待时间的变化</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566743820035.png" alt="1566743820035"></p><ul><li>锁消除</li><li>编译时对运行上下文进行扫描，去除不可能存在竞争的锁</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744166712.png" alt="1566744166712"></p><ul><li>锁粗化</li><li>通过扩大锁的范围，避免反复加锁和解锁</li></ul><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744269477.png" alt="1566744269477"></p><p>synchronized锁的四种状态</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744363854.png" alt="1566744363854"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744495783.png" alt="1566744495783"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744516440.png" alt="1566744516440"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744545011.png" alt="1566744545011"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744573288.png" alt="1566744573288"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744597530.png" alt="1566744597530"></p><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744650852.png" alt="1566744650852"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744677379.png" alt="1566744677379"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566774525373.png" alt="1566774525373"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566774615642.png" alt="1566774615642"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566774835528.png" alt="1566774835528"></p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744755180.png" alt="1566744755180"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744772543.png" alt="1566744772543"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744787208.png" alt="1566744787208"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744807706.png" alt="1566744807706"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744833721.png" alt="1566744833721"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744849777.png" alt="1566744849777"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744873786.png" alt="1566744873786"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744897082.png" alt="1566744897082"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744927952.png" alt="1566744927952"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566744957721.png" alt="1566744957721"></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566745004318.png" alt="1566745004318"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566775040568.png" alt="1566775040568"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566775257695.png" alt="1566775257695"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566775322604.png" alt="1566775322604"></p><h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><p>在web开发中，服务器要接受并处理请求，所以会为一个请求分配一个线程来处理，如果并发的请求比较多，则耗费在线程创建和回收大量时间，使用线程池来重复利用线程</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566775915639.png" alt="1566775915639"></p><blockquote><p>3中会保证顺序执行各个任务，在任意给定线程不会有多个线程执行；8是Java8加入的</p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566776250404.png" alt="1566776250404"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566776478492.png" alt="1566776478492"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566776441213.png" alt="1566776441213"></p><blockquote><p>是一个根据一组执行策略调度，调用、执行和控制的异步任务的框架，目的是提供一种将任务提交和任务融合运行分离开的机制。</p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566776736541.png" alt="1566776736541"></p><p>线程池设计</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566776835646.png" alt="1566776835646"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777028608.png" alt="1566777028608"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777063200.png" alt="1566777063200"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777089962.png" alt="1566777089962"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777290218.png" alt="1566777290218"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777307025.png" alt="1566777307025"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777325088.png" alt="1566777325088"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777405991.png" alt="1566777405991"></p><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566286012980.png" alt="1566286012980"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566286247944.png" alt="1566286247944"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566286283521.png" alt="1566286283521"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566286308847.png" alt="1566286308847"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566286637054.png" alt="1566286637054"></p><p>finally是先于return执行的。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566287202869.png" alt="1566287202869"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566287412849.png" alt="1566287412849"></p><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566287490549.png" alt="1566287490549"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566287502906.png" alt="1566287502906"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566288132427.png" alt="1566288132427"></p><h3 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h3><p><img src="/2019/08/26/Sword-For-java/1568710462272.png" alt="1568710462272"></p><h3 id="Map家族"><a href="#Map家族" class="headerlink" title="Map家族"></a>Map家族</h3><p><img src="/2019/08/26/Sword-For-java/1568706469430.png" alt="1568706469430"></p><h3 id="选用"><a href="#选用" class="headerlink" title="选用"></a>选用</h3><p>主要根据集合的特点来选用，比如我们<strong>需要根据键值获取到元素值时</strong>就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap。</p><p>当我们<strong>只需要存放元素值时</strong>，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>的底层是HashMap实现的，是将元素以键的形式存入HashMap的Key中，而他的值Value是一个final类型的PRESENT对象</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>实现了排序；底层也是HashMap实现</p><p>第一种是基于元素对象自身实现comparable接口的<strong>自然排序</strong></p><blockquote><p>即让一个元素对象A实现Comparable接口，就要重写<code>equals()；compareTo()自然排序；hashCode()；</code>三个方法，为了能够让对象A在加入TreeSet后能正确排序，其中equals和compareTo()的方法就要按相同的规则比较两个对象是否相等。一旦equals()方法重写，就要重写hashCode()，即在使用equals方法比较两个对象相同时，也要保证两个对象的hashCode值也相等。</p><p>其主要的方法就是compareTo()方法。</p></blockquote><p>另一种是基于不与单元元素绑定的Comparator接口的排序，即<strong>客户化排序</strong></p><blockquote><p>首先对象A还是实现Comparable接口，但不需要在A中改变compareTo()方法，只需要在外部类AComparator实现Comparator<A>，实现其中的compare()方法（该方法中设计一个比较方式即可）。此时A类即实现了Comparable接口，在外部又实现了Comparator，在存入Set集合中时，会优先以compare()方法中的比较规则为准。TreeSet集合中也是如此。</A></p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566288990431.png" alt="1566288990431"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Key-Value的形式存储数据，其中的key是不可重复的，使用Set来保存的，有去重功能，value是通过Collection。</p><p><img src="/2019/08/26/Sword-For-java/1567167431023.png" alt="1567167431023"></p><p><img src="/2019/08/26/Sword-For-java/1567167408933.png" alt="1567167408933"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566289552062.png" alt="1566289552062"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566289709492.png" alt="1566289709492"></p><p>混合高低位计算hash值，使之分布散列均匀。用位与操作替代取模。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566290019896.png" alt="1566290019896"></p><p><img src="/2019/08/26/Sword-For-java/1567171193672.png" alt="1567171193672"></p><p>1.8之前会发生扩容死锁问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">// 这行也是重点</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 重点这三行</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/26/Sword-For-java/1567176014673.png" alt="1567176014673"></p><blockquote><p>此时有两个线程T1、T2同时插入a4，则T1、T2同时进行扩容操作，它们各自新建了一个Entry数组newTable。</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567175751529.png" alt="1567175751529"></p><blockquote><p>T2线程执行到transfer方法的Entry&lt;K,V&gt; next = e.next;时被挂起，T1线程执行transfer方法后Entry数组如下图：</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567175785376.png" alt="1567175785376"></p><blockquote><p>在T1线程没返回新建Entry数组之前，T2线程恢复，因为在T2挂起时，变量e指向的是a1，变量next指向的是a2，所以在T2恢复执行完transfer之后，Entry数组如下图：</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567175825876.png" alt="1567175825876"></p><blockquote><p>可以看到在T2执行完transfer方法后，a1元素和a2元素形成了循环引用，此时无论将T1的Entry数组还是T2的Entry数组返回作为扩容后的新数组，都会存在这个环形链表，当调用get方法获取该位置的元素时就会发生死循环</p></blockquote><p>1.8之后就解决了这个问题，因为没有再使用指针引用的方式去传值，而是重新计算在新数组上的hash序列号，移动值到新HashMap上。</p><p>没解决的问题就是<strong>多线程安全问题</strong>：</p><p>如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位置还没有其他的数据。所以这两个线程都会进入插值处的代码中。假设一种情况：</p><ul><li>线程A通过if判断，该位置没有哈希冲突，进入了if语句，还没有进行数据插入，这时候 CPU 就把资源让给了线程B，线程A停在了if语句里面，</li><li>线程B判断该位置没有哈希冲突（线程A的数据还没插入），也进入了if语句，线程B执行完后，轮到线程A执 行，现在线程A直接在该位置插入而不用再判断。</li><li>这时候，你会发现线程A把线程B插入的数据给覆盖了，发生了线程不安全情况。</li></ul><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>哈希表（HashTable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。也就是说，它通过把关键码映射到表中一个位置来访问记录，以加快查找速度。</p><ul><li>特点一：线程安全；</li><li>特点二：K/V都不允许为null；</li></ul><blockquote><p>使用<strong>哈希函数</strong>将被查找的键转化为数组的索引。</p></blockquote><p>处理冲突的方法很多，有<strong>拉链法</strong>和<strong>线性探索法</strong>。</p><p><img src="/2019/08/26/Sword-For-java/1567177495680.png" alt="1567177495680"></p><p><img src="/2019/08/26/Sword-For-java/1567177516502.png" alt="1567177516502"></p><blockquote><p>注：线程安全，使用synchronized关键字修饰关键方法</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>锁细粒度化：将数组拆分成子数组，16位为一段，加上一把锁。</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566290353254.png" alt="1566290353254"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p>更细化：<strong>Node + CAS + Synchronized</strong></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566290416620.png" alt="1566290416620"></p><p>sync只锁定当前链表或者红黑树的首结点，将锁细粒化到表中每个元素，只要hash不冲突就不会发生并发。不允许插入null键，对数组元素的更新是使用CAS，需要不断地的失败重试。</p><p>容量控制参数：</p><p><img src="/2019/08/26/Sword-For-java/1567214818968.png" alt="1567214818968"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566290826092.png" alt="1566290826092"></p><p>（2）图示：</p><p><img src="/2019/08/26/Sword-For-java/1568773675821.png" alt="1568773675821"></p><p>（4）表示发生哈希碰撞，则会锁住链表或二叉树头节点即数组元素；</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566290892669.png" alt="1566290892669"></p><blockquote><p>只要哈希不冲突就不会出现并发获得锁的情况！</p><ol><li>首先用CAS无锁操作插入头节点，如果插入失败，则表示有别的线程已经插入头节点了，需要循环重试；</li><li>如果头节点已经存在，就尝试获取头节点的synchronized锁，再进行操作</li></ol></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291042885.png" alt="1566291042885"></p><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566777522291.png" alt="1566777522291"></p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291118596.png" alt="1566291118596"></p><blockquote><p>P91集20秒处</p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291155664.png" alt="1566291155664"></p><blockquote><p>executor：线程执行器，一个任务执行和调度的框架；tools下还有和executor相关的executors类，用来创建executorServices等对象；</p><p>locks：Java5后增加协调共享对象的访问方法，显示锁，方便对线程之间的共享资源做更细粒度的锁控制，一个lock可以创建多个Condition，用于将线程的等待和唤醒对象化，基于AQS实现，底层是调用Locksupport.unpark/park()实现线程的阻塞和唤醒。另一个是可重入读写锁，读读可共存，读写不可同时；</p><p>atomic：原子操作类，一个操作是不可中断的（即使是多线程环境中）。4中原子更新方式：原子更新基本类型、原子更新数组、原子更新引用、原子更新字段。atomic使用的是CAS的更新方式，当某个线程在执行atomic方法时，不会被其他线程打断，别的线程就会像自旋锁一样一直等到该方法执行完成，才由JVM从等待队列中选择一个线程来执行，是非阻塞的。在多线程中的累加操作时可以使用atomic变量来实现；</p></blockquote><p>tools下的并发工具类：主要用于线程的同步</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291262574.png" alt="1566291262574"></p><p>闭锁：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291338890.png" alt="1566291338890"></p><p>TA主线程，事件T123，引入CountDownLatch后，主线程就陷入等待，并有一个计数器cnt（事件的个数），每一个事件执行countDown()方法后就减一，直到所有子线程（事件）执行完毕，cnt为0时，主线程重新进入执行状态。</p><blockquote><p>注：这里的子线程在执行完countDown()方法会可以继续执行</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567217338361.png" alt="1567217338361"></p><p>栅栏：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291397783.png" alt="1566291397783"></p><p>线程T123每调用一次await()方法时，其中的计数器都会减一，只要计数器不为0，该线程都会阻塞，其中TA线程（当前线程）会和T123一起，在计数器为0时同时执行。</p><blockquote><p>这里的子线程到达栅栏处便会等待，不可继续执行。</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567217754584.png" alt="1567217754584"></p><p>信号量：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291447240.png" alt="1566291447240"></p><blockquote><p>通过acquire去获取一个许可，没有就等待；拥有资源的线程执行完后会release释放资源</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567217900626.png" alt="1567217900626"></p><p>交换器：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291480921.png" alt="1566291480921"></p><blockquote><p>提供一个同步点，在这个同步点，两个线程会彼此交换数据。一个线程先到同步点会被阻塞，直到李刚一个线程也到该同步点。只能用于两个线程。</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567218127016.png" alt="1567218127016"></p><p>会发现男孩女孩说的话被交换了：</p><p><img src="/2019/08/26/Sword-For-java/1567218139507.png" alt="1567218139507"></p><h3 id="JUC：BlockingQueue阻塞队列"><a href="#JUC：BlockingQueue阻塞队列" class="headerlink" title="JUC：BlockingQueue阻塞队列"></a>JUC：BlockingQueue阻塞队列</h3><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291534420.png" alt="1566291534420"></p><blockquote><p>如果队列满了，入队操作将阻塞，如果队列空了，出队操作将阻塞</p><p>方法：boolean add()：队尾添加元素方法，满了报异常；offer()队尾添加怨怒，满了返回false，或者添加等待时间；put()队尾添加元素，满了就阻塞一直等待到可添加；</p><p>E take()：头部取出元素，为空就一直等待队列中有元素；poll()头部取元素，为空可设置等待时间，或返回false；</p></blockquote><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291576395.png" alt="1566291576395"></p><p>以下七个实现，均线程安全：</p><p><img src="/2019/08/26/Sword-For-java/Sword-For-java%5C1566291602923.png" alt="1566291602923"></p><blockquote><p>有边界是指容量有限，初始化时要指定大小；1，2先进先出；3按照优先级（元素具备可比性）</p></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="/2019/08/26/Sword-For-java/1567219162671.png" alt="1567219162671"></p><p>基于流模型实现的，标志着其交互方式是基于同步阻塞方式，在读取输入流或写入输出流时，在读写操作完成前，线程会一直阻塞住，这之间的调用是可靠的线性操作；程序发送请求到内核，由内核进行通信，在内核准备好之前，该程序是被挂起的，所以在两个阶段程序都是挂起状态；</p><p>类比于C/S模式：一个连接一个线程；即客户端有连接请求时，服务端就要启动一个线程来处理，待操作系统返回结果，如果这个连接不做任何事，则会造成不必要的线程开销，可以通过线程池机制来改善。BIO的特点就是在IO执行的两个阶段都被阻塞住。</p><h4 id="NIO-Java4引入"><a href="#NIO-Java4引入" class="headerlink" title="NIO-Java4引入"></a>NIO-Java4引入</h4><p>构建多路复用、同步非阻塞的IO操作；提供了channel、select、buffer等新的抽象可以构建多路复用、同步非阻塞的IO操作，提供更接近操作系统底层的数据操作方式。</p><p><img src="/2019/08/26/Sword-For-java/1567219610645.png" alt="1567219610645"></p><p>特点是：在程序发起第一次请求时，线程并没有被阻塞，会反复检查数据有没有准备好，将原来大块阻塞不能用的时间分为小块的阻塞时间，有点类似于轮询，会有机会去执行。</p><p>类比C/S模式为：一个请求一个线程，客户端发送的请求会被注册到多路复用器上，多路复用器轮询到连接有IO请求时，才会启动一个线程处理；特点就是程序会询问内核数据有没有准备好，该阶段是非阻塞的，在后一阶段是阻塞的（数据拷贝）</p><p><img src="/2019/08/26/Sword-For-java/1567219995578.png" alt="1567219995578"></p><p>基本所有的IO在NIO中都从Channel开始，有点像流，数据可以从Channel读到Buffer中（反过来亦可）；</p><p>Channel有如下：</p><p><img src="/2019/08/26/Sword-For-java/1567223433011.png" alt="1567223433011"></p><p>FileChannel的两个方法：</p><p><img src="/2019/08/26/Sword-For-java/1567223087988.png" alt="1567223087988"></p><p>常用于：高效的网络文件的数据传输，和大文件拷贝，避免了将文件从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，避免了两次用户态和内核态的切换。</p><p>Buffers有如下：</p><p><img src="/2019/08/26/Sword-For-java/1567223415859.png" alt="1567223415859"></p><p>Selector：</p><p><img src="/2019/08/26/Sword-For-java/1567223507533.png" alt="1567223507533"></p><p>Selector允许单线程处理多个Channel，如果你的应用打开了多个连接（通道），每个连接的流量都很低，就可以使用selector。图示为一个单线程使用一个selector来处理3个channel的情形；使用selector得向selector注册channel，然后调用它的selector方法，这方法会一直阻塞直到某个注册的channel有事件就绪，一旦这个方法返回，线程就可以返回处理这些事件了，事件可以是有新的连接进来或者buffer里有数据可以读取等等。</p><p>selector源码：</p><p><img src="/2019/08/26/Sword-For-java/1567224057240.png" alt="1567224057240"></p><p>Selector组件是由SelectorProvider创建的，底层根据不同操作系统的IO多路复用来实现，会返回PollSelectorProvider（others）、EPollSelectorProvider（Linux）等</p><p><img src="/2019/08/26/Sword-For-java/1567224328096.png" alt="1567224328096"></p><p>单线程可以处理多个网络IO，IO多路复用调用系统级别的select/poll/epoll模型，由系统监控IO状态，select轮询可以监控多个IO请求，当有一个准备好时，就可以返回。</p><p><img src="/2019/08/26/Sword-For-java/1567224757594.png" alt="1567224757594"></p><blockquote><p>select连接是有限的，因为是基于数组的</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567224860983.png" alt="1567224860983"></p><blockquote><p>FD：文件唯一标识符</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567224929810.png" alt="1567224929810"></p><h4 id="AIO：异步非阻塞IO"><a href="#AIO：异步非阻塞IO" class="headerlink" title="AIO：异步非阻塞IO"></a>AIO：异步非阻塞IO</h4><p><img src="/2019/08/26/Sword-For-java/1567224985271.png" alt="1567224985271"></p><p>应用操作直接返回，而不会阻塞在那里，当后台完成，操作系统就会通知响应线程进行后续操作。AIO属于异步模型，用户线程可以同时处理别的事务。</p><p><img src="/2019/08/26/Sword-For-java/1567225187685.png" alt="1567225187685"></p><blockquote><p>基于回调：实现接口，调用时把回调函数传给对应的API即可</p><p>返回Future：处理完一个事，通过isDone()方法查看是否已经准备好数据</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2019/08/26/Sword-For-java/1567226204994.png" alt="1567226204994"></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>家族图谱</p><p>第一阶段Spring Core、Spring Security、Spring Data，实现将单体应用开发服务好。不仅仅提供的便捷的数据库访问，web 中SpringMVC等必要功能。使用IOC、AOP实现应用低耦合、可扩展。</p><p><img src="/2019/08/26/Sword-For-java/1567131737917.png" alt="1567131737917"></p><blockquote><p>利用工厂模式（DI）和代理模式（AOP）来解耦应用组件，然后实现了web应用的框架（SpringMVC）;</p></blockquote><p>第二阶段推出的SpringBoot不仅仅提高了开发效率，而且将程序由可用变为好用。</p><p><img src="/2019/08/26/Sword-For-java/1567132198944.png" alt="1567132198944"></p><p>第三阶段的Spring Cloud，推动了微服务架构的落地</p><p><img src="/2019/08/26/Sword-For-java/1567132290549.png" alt="1567132290549"></p><p>第四阶段：Spring Cloud DataFlow</p><p>DataFlow将实时消息的处理任务和临时运行的任务都作为组件处理，定义这样组件的交互。</p><p><img src="/2019/08/26/Sword-For-java/1567132348627.png" alt="1567132348627"></p><h3 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h3><p><img src="/2019/08/26/Sword-For-java/1567132527700.png" alt="1567132527700"></p><p>IOC是一种思想，使我们从繁琐的对象交互中解脱出来，进而专注于对象本身，更进一步了解面向对对象。</p><p>一般的设计思路：</p><p><img src="/2019/08/26/Sword-For-java/1567132665135.png" alt="1567132665135"></p><blockquote><p>先设计轮子，根据轮子设计底盘，根据底盘设计箱体…</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567132802864.png" alt="1567132802864"></p><blockquote><p>这里每个类的构造函数都直接调用了底层代码的构造函数，这样底层需求变动时会影响整个上层的代码，是不可取的。</p></blockquote><p>依赖注入的是思路</p><p><img src="/2019/08/26/Sword-For-java/1567133056969.png" alt="1567133056969"></p><p><img src="/2019/08/26/Sword-For-java/1567133089064.png" alt="1567133089064"></p><p><img src="/2019/08/26/Sword-For-java/1567133141092.png" alt="1567133141092"></p><ul><li>set：实现特定属性的public set()方法，让IOC容器注入所依赖类型的对象</li><li>接口：实现特定接口，让IOC容器注入所依赖类型的对象</li><li>构造函数：实现特定参数的构造函数，实现在创建对象时让IOC容器注入所依赖类型的对象</li><li>注解：通过Java的注解机制，让IOC容器注入所依赖类型的对象</li></ul><h4 id="依赖倒置原则、IOC、DI、IOC容器的关系"><a href="#依赖倒置原则、IOC、DI、IOC容器的关系" class="headerlink" title="依赖倒置原则、IOC、DI、IOC容器的关系"></a>依赖倒置原则、IOC、DI、IOC容器的关系</h4><p><strong>什么是依赖倒置原则？</strong>假设我们设计行李箱：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计箱体，最后根据箱体设计好整个箱子。这里就出现了一个“依赖”关系：箱子依赖箱体，箱体依赖底盘，底盘依赖轮子。</p><p><img src="/2019/08/26/Sword-For-java/1567133889794.png" alt="1567133889794"></p><p>上面的依赖关系是该原则所反对的，该原则的思想为高层模块不应该依赖与底层模块，两者都应该依赖于其抽象。</p><blockquote><p>依赖倒置原则思想的指导才有了IOC的思路，有了IOC的思路则需要DI方法的支撑。Spring框架基于IOC才提出了容器的概念，容器管理着Bean的生命周期，控制着Bean的依赖注入。</p></blockquote><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。这几种概念的关系大概如下：</p><p><img src="https://pic1.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt="img"></p><p>那什么是<strong>控制反转容器(IoC Container)</strong>呢？对行李箱类进行初始化的那段代码发生的地方，就是控制反转容器。</p><p><img src="/2019/08/26/Sword-For-java/1567134047279.png" alt="1567134047279"></p><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<strong>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化行李箱都要亲手去写那一大段初始化的代码</strong>。这是引入IoC Container的第一个好处。</p><p><strong>IOC的优势：</strong></p><p><img src="/2019/08/26/Sword-For-java/1567134582679.png" alt="1567134582679"></p><p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p><p><img src="/2019/08/26/Sword-For-java/1567134623398.png" alt="1567134623398"></p><p>我们就像是工厂的客户。我们只需要向工厂请求一个Luggage实例，然后它就给我们按照Config创建了一个Luggage实例。我们完全不用管这个Luggage实例是怎么一步一步被创建出来。</p><h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>实际Spring IOC容器是怎么实现对象的创建和依赖的：</p><p><img src="/2019/08/26/Sword-For-java/1567135465808.png" alt="1567135465808"></p><p>1、Spring启动时读取应用程序提供的Bean配置信息，并在容器生成一份相应的Bean配置注册表</p><p>2、根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</p><blockquote><p>这里利用的是Java语言的反射功能实例化bean、并建立Bean之间的依赖关系</p></blockquote><p>3、将这些准备就绪的Bean放到Map缓存池中，为上层提供就绪的运行环境，等待应用程序执行调用</p><p><img src="/2019/08/26/Sword-For-java/1567135556369.png" alt="1567135556369"></p><p><img src="/2019/08/26/Sword-For-java/1567135577177.png" alt="1567135577177"></p><blockquote><p>Spring 作者设计这两个核心接口用以表示容器</p></blockquote><p>相关接口：</p><p><img src="/2019/08/26/Sword-For-java/1567134859951.png" alt="1567134859951"></p><blockquote><p>Spring容器在启动时会将xml或者注解里的Bean的定义解析为Spring内部的BeanDefinition</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567134968136.png" alt="1567134968136"></p><blockquote><p>Spring 将Bean的定义解析为BeanDefinition后会通过BeanDefinitionRegistry 以BeanName为key，BeanDefinition为value存储到BeanDefinitionMap （这是个ConcurrentHashMap类型的map结构）中。</p></blockquote><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><h5 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h5><p><img src="/2019/08/26/Sword-For-java/1567135018588.png" alt="1567135018588"></p><blockquote><p>包含Bean的各种定义，以便在接收客户端请求时可以实例化Bean，并在实例化对象时建立Bean 之间的依赖关系，这将使Bean从Bean客户端中解放出来。</p></blockquote><p>BeanFactory源码：</p><p><img src="/2019/08/26/Sword-For-java/1567137963853.png" alt="1567137963853"></p><blockquote><p>各种getBean()方法，可以看到可以从Spring中按类型 / 按名称获取Bean</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567138042701.png" alt="1567138042701"></p><blockquote><p>判断是否为单例方法，SpringIOC中，默认Bean都是以单例存在的</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567138130281.png" alt="1567138130281"></p><blockquote><p>与上面相反，判断为多例的</p></blockquote><h5 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h5><p><img src="/2019/08/26/Sword-For-java/1567138269117.png" alt="1567138269117"></p><p><img src="/2019/08/26/Sword-For-java/1567138332244.png" alt="1567138332244"></p><blockquote><p>3表示可以管理message，4表示可以发布实事件给监听器，实现监听</p><p>可以看出这不单单是个工厂，是整个应用上下文，代表整个大容器的所有功能</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567138744314.png" alt="1567138744314"></p><blockquote><p>SpringBoot的自带启动类的run()方法，深入进去其最终会执行createApplicationContext()方法，会发现其会用Class.forName加载AnnotationConfigServleWebServerApplicationContext类。</p></blockquote><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="Bean装载案例："><a href="#Bean装载案例：" class="headerlink" title="Bean装载案例："></a>Bean装载案例：</h5><p>Person Bean：</p><p><img src="/2019/08/26/Sword-For-java/1567139561022.png" alt="1567139561022"></p><blockquote><p>扫描装配Bean，使用注解@Component（指定要扫描的类进入IOC容器中）@Value()是赋值</p></blockquote><p>启动类：</p><p><img src="/2019/08/26/Sword-For-java/1567139336948.png" alt="1567139336948"></p><blockquote><p>@SpringBootApplication注解包含了启动扫描的功能。</p></blockquote><h5 id="Bean依赖注入案例："><a href="#Bean依赖注入案例：" class="headerlink" title="Bean依赖注入案例："></a>Bean依赖注入案例：</h5><p><img src="/2019/08/26/Sword-For-java/1567139966763.png" alt="1567139966763"></p><blockquote><p>装载Dog 类进入IOC容器</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567139981229.png" alt="1567139981229"></p><blockquote><p>注入Pet（Pet是个接口），@Autowired会根据属性类型找到对应的Bean进行注入（最基本是用getBean()方法根据类型注入），这里的Dog类是Pet的一种实现，所以会根据类型查找到Dog，由SpringIOC容器将Dog的实例注入Person中。</p><p>当有多个Pet的实现时（例如还有Cat、Bird类），需要在要注入的类上加上@Primary注解。</p></blockquote><h4 id="getBean-解析"><a href="#getBean-解析" class="headerlink" title="getBean()解析"></a>getBean()解析</h4><p>会调用doGetBean()放法；</p><p><img src="/2019/08/26/Sword-For-java/1567141357464.png" alt="1567141357464"></p><p><img src="/2019/08/26/Sword-For-java/1567141421420.png" alt="1567141421420"></p><blockquote><p>1、先获取Bean名称beanName；2、获取一个（共享的）实例；3、试着从缓存或者实例工厂中获取实例；</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567141491889.png" alt="1567141491889"></p><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p><img src="/2019/08/26/Sword-For-java/1567141574312.png" alt="1567141574312"></p><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p><img src="/2019/08/26/Sword-For-java/1567141612844.png" alt="1567141612844"></p><blockquote><p>1、实例化Bean对象以及设置属性</p><p>2、 对 Aware 接口的实现，目的是在Bean中设置对IOC容器的感知</p><p>3、Bean的前置初始化方法，对Spring容器完成实例化的Bean添加自定义的处理逻辑</p><p>4、…   5、…</p><p>6、Bena的后置初始化方法，Bean实例初始化后的自定义工作，3、6和AOP相关</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567141729918.png" alt="1567141729918"></p><h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p><img src="/2019/08/26/Sword-For-java/1567142579843.png" alt="1567142579843"></p><p>分类与合并（织入）</p><p><img src="/2019/08/26/Sword-For-java/1567142610000.png" alt="1567142610000"></p><blockquote><p>Spring 采用的方式不需要特殊的Java编译器，但性能开销多一些</p></blockquote><p><img src="/2019/08/26/Sword-For-java/1567143238161.png" alt="1567143238161"></p><p><img src="/2019/08/26/Sword-For-java/1567143257267.png" alt="1567143257267"></p><p><img src="/2019/08/26/Sword-For-java/1567143313889.png" alt="1567143313889"></p><p><img src="/2019/08/26/Sword-For-java/1567143353134.png" alt="1567143353134"></p><p><img src="/2019/08/26/Sword-For-java/1567144837023.png" alt="1567144837023"></p>]]></content>
      
      
      <categories>
          
          <category> 面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
