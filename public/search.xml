<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ShareBike Project</title>
      <link href="/2019/11/25/ShareBike-Project/"/>
      <url>/2019/11/25/ShareBike-Project/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SecKill Project</title>
      <link href="/2019/11/25/SecKill-Project/"/>
      <url>/2019/11/25/SecKill-Project/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Project Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Algorithm</title>
      <link href="/2019/11/25/Java-Algorithm/"/>
      <url>/2019/11/25/Java-Algorithm/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Top100</title>
      <link href="/2019/11/25/LeetCode-Top100/"/>
      <url>/2019/11/25/LeetCode-Top100/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/11/25/Redis/"/>
      <url>/2019/11/25/Redis/</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>针对面试中redis问答形式的总结</p><ul><li><input disabled type="checkbox"> 数据库与redis数据一致性问题</li></ul></blockquote><a id="more"></a><h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p><p><strong>1、速度快</strong></p><p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p><blockquote><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p></blockquote><p><strong>2、支持丰富数据类型</strong></p><p>支持 String ，List，Set，Sorted Set，Hash 。</p><blockquote><ul><li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li><li>用他的 Set 可以做高性能的 tag 系统等等。</li></ul></blockquote><p><strong>3、持久化存储</strong></p><p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p><h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul><li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</li></ul><p><strong>TODO网络 IO 模型</strong></p><ul><li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li><li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li></ul><p>TODO 有点看不懂，找亚普表弟确认中。</p><h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/2019/11/25/Redis/image-20191125110950740.png" alt="image-20191125110950740"></p><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="/2019/11/25/Redis/image-20191125111306113.png" alt="image-20191125111306113"></p><ul><li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li></ul><p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。</p><h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul><li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li><li>数据结构简单，操作也就简单；全程使用 hash 结构，读取速度快；</li><li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li><li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li><li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li></ul><h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p><ul><li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li></ul><h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p><ul><li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ul><p><strong>RDB又存在哪些劣势呢？</strong></p><ul><li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>AOF的优势有哪些呢？</strong></p><ul><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul><p><strong>AOF的劣势有哪些呢？</strong></p><ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul><p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p><p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure><p><strong>AOF持久化配置</strong></p><p>在Redis的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p></li><li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p><ul><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p><blockquote><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p></blockquote></li></ul></li></ul><p>在 Redis4.0 版本开始，当使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034" target="_blank" rel="noopener">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。</p><h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul><li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行 Debug Reload</li><li>执行 Shutdown 且没有开启 AOF 持久化</li></ul><p><strong>重要知识：</strong></p><ul><li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li><li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li><li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><p>BGSAVE底层实现方式：</p><p><img src="/2019/11/25/Redis/1566521057383.png" alt="1566521057383"></p><ol><li>查询子进程是否有冲突</li><li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li></ol><p><img src="/2019/11/25/Redis/1566521457362.png" alt="1566521457362"></p><p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p><p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p><h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><p>Redis 提供了 3 种数据过期策略：</p><ul><li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li><li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「数据“淘汰”策略」</a> 。</li></ul><p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html" target="_blank" rel="noopener">《关于 Redis 数据过期策略》</a> 文章。</p><h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p><p>Redis 提供了 6 种数据淘汰策略：</p><ol><li>volatile-lru</li><li>volatile-ttl</li><li>volatile-random</li><li>allkeys-lru</li><li>allkeys-random</li><li>no-enviction</li></ol><p><img src="/2019/11/25/Redis/image-20191125135302360.png" alt="image-20191125135302360"></p><p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">《Redis实战（二） 内存淘汰机制》</a> 。</p><p><strong>Redis LRU 算法</strong></p><p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p><ul><li><p>具体的可以看看 <a href="http://ifeve.com/lru-cache/" target="_blank" rel="noopener">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p><p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p></li></ul><blockquote><p>这个问题的目的是，如何保证热点数据不要被淘汰。</p></blockquote><p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p><p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p><p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p><h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p><p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><ul><li>数据缓存</li><li>会话缓存</li><li>时效性数据</li><li>访问频率</li><li>计数器</li><li>社交列表</li><li>记录用户判定信息</li><li>交集、并集和差集</li><li>热门列表与排行榜</li><li>最新动态</li><li>消息队列</li><li>分布式锁</li></ul><p>详细的介绍，可以看看如下文章：</p><ul><li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li><li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li><li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li><li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li></ul><p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p><p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p><p>具体的代码实现，可以看看 <a href="https://www.jianshu.com/p/e3abbfc59d77" target="_blank" rel="noopener">《一道 Redis 面试题》</a> 。</p><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p><ul><li><p>Redisson</p><blockquote><p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p></blockquote></li><li><p>Jedis</p><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p><p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><p>Lettuce</p><blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p></blockquote></li></ul><p>Spring Boot 2.x 内置使用 Lettuce 。</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p><ul><li>互斥性：任意时刻，只能有一个客户端获取锁；</li><li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li><li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li><li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li></ul><p><strong>方案一：set 指令</strong></p><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><ul><li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li><li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li></ul><p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span> [EX <span class="keyword">seconds</span>] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p><img src="/2019/11/25/Redis/%E5%89%91%E6%8C%87Java%5C1566518903284.png" alt="1566518903284"></p><ul><li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li><li>具体的实现，可以参考 <a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/" target="_blank" rel="noopener">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li></ul><p><strong>方案二：redlock</strong></p><p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p><p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">《Redlock：Redis分布式锁最牛逼的实现》</a></li><li><a href="https://www.jianshu.com/p/f302aa345ca8" target="_blank" rel="noopener">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li></ul><p><strong>对比 Zookeeper 分布式锁</strong></p><ul><li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li><li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li></ul><p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p><h2 id="Redis并发竞争key"><a href="#Redis并发竞争key" class="headerlink" title="Redis并发竞争key"></a>Redis并发竞争key</h2><p>即：多个系统同时对一个 key 进行操作</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><ul><li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li><li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li><li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li><li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li></ul><p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p><p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p><h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p><p><strong>Redis 如何做大量数据插入？</strong></p><p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p><p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">《Redis 大量数据插入》</a> 文章。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p><ul><li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p></li><li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p></li><li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p></li><li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p></li><li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p><blockquote><p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p></blockquote></li></ul><p><strong>如何实现 Redis CAS 操作？</strong></p><p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p><p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26" target="_blank" rel="noopener">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p><h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p><ul><li>1、Redis Sentinel</li><li>2、Redis Cluster</li><li>3、Twemproxy</li><li>4、Codis</li><li>5、客户端分片</li></ul><p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">《Redis 实战（四）集群机制》</a> 这篇文章。</p><p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p><blockquote><p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p><p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></blockquote><p><strong>选择</strong></p><p>目前一般在选型上来说：</p><ul><li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p></li><li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p><p><strong>Redis 集群如何扩容？</strong></p></li></ul><blockquote><p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p></blockquote><ul><li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li><li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li></ul><h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p><p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p><ul><li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li><li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li><li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><p><strong>好处</strong></p><p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p><p>更多详细，可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md" target="_blank" rel="noopener">《Redis 主从架构》</a> 。</p><h2 id="数据与数据库双写一致"><a href="#数据与数据库双写一致" class="headerlink" title="数据与数据库双写一致"></a>数据与数据库双写一致</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>通用的读操作</p><ul><li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li><li>最后将数据返回给请求</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>写操作</strong>可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li><p>设置<strong>键的过期时间</strong>，可以保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p></li><li><p>更新操作的细分</p></li></ol><p>执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><blockquote><p>注：这里的缓存操作一般是删除操作。</p></blockquote><p>对比：</p><ul><li>先删除缓存，再更新数据库<ul><li>在高并发下表现不如意，在原子性被破坏时表现优异</li></ul></li><li>先更新数据库，再删除缓存(<code>Cache Aside Pattern</code>设计模式)<ul><li>在高并发下表现优异，在原子性被破坏时表现不如意</li></ul></li></ul><h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">《Redis 哨兵集群实现高可用》</a> 。</p><h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">《Redis 集群教程》</a> 完整版</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md" target="_blank" rel="noopener">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li></ul><p><strong>说说 Redis 哈希槽的概念？</strong></p><p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p><p><strong>Redis Cluster 的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p><p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p><ul><li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li></ul><p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p><p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><p><strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p><p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p><strong>Redis 集群如何选择数据库？</strong></p><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p><blockquote><p>重点问题，仔细理解。</p></blockquote><ul><li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li><li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li><li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li></ul><h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote><p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 集群都有哪些方案？」</a> 是同类问题。</p></blockquote><p>关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html" target="_blank" rel="noopener">《Redis 分区》</a> 文章。</p><ul><li>Redis 分区是什么？</li><li>分区的优势？</li><li>分区的不足？</li><li>分区类型？</li></ul><p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p><ul><li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li><li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li></ul><p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p><p>Redis 分区方案，主要分成两种类型：</p><ul><li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul><li>案例：Redis Cluster 和客户端分区。</li></ul></li><li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul><li>案例：Twemproxy 和 Codis 。</li></ul></li></ul><p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p><p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p><p>如下是网络上的一个大答案：</p><blockquote><p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p></blockquote><ul><li>和飞哥沟通了下，这个操作不是很合理。</li><li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li></ul><h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA" target="_blank" rel="noopener">《Redis 几个重要的健康指标》</a></p><ul><li>存活情况</li><li>连接数</li><li>阻塞客户端数量</li><li>使用内存峰值</li><li>内存碎片率</li><li>缓存命中率</li><li>OPS</li><li>持久化</li><li>失效KEY</li><li>慢日志</li></ul><p><strong>如何提高 Redis 命中率？</strong></p><p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html" target="_blank" rel="noopener">《如何提高缓存命中率（Redis）》</a> 。</p><h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865" target="_blank" rel="noopener">《Redis 的内存优化》</a></p><ul><li><p>redisObject 对象</p></li><li><p>缩减键值对象</p></li><li><p>共享对象池</p></li><li><p>字符串优化</p></li><li><p>编码优化</p></li><li><p>控制 key 的数量</p><p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p></li></ul><p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p><p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p><p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p><p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><ul><li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li><li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li></ul><h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p><ul><li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li><li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li><li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li></ul><p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong></p><p><strong>3、尽量避免在压力很大的主库上增加从库。</strong></p><p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong></p><ul><li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li></ul><p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase</title>
      <link href="/2019/11/24/DataBase/"/>
      <url>/2019/11/24/DataBase/</url>
      
        <content type="html"><![CDATA[<p> 引言：</p><blockquote><p>针对面试的mysql数据库总结</p></blockquote><a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p><strong>客观存在并可相互区别的事物</strong>称之为实体。可以看成是Java类</p><p>例子：(课程关系表)就是一个实体。</p><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p><strong>实体所具有的某一特性</strong>称之为属性。可以看成是Java类的成员变量。属性在数据库中又称为字段（或者是列）</p><p>例子：(课程名)，(课程号)、(学时)就是属性名。</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>除含有属性名所在的行之外的其他行称之为元组。</strong></p><p><strong>下面的每一行数据都称之为元组</strong><br>(C401001 数据结构 70)<br>(C401002 操作系统 80)<br>(C402001 计算机原理 60)</p><h3 id="码-Key"><a href="#码-Key" class="headerlink" title="码(Key)"></a>码(Key)</h3><p><strong>码也被称作是关键字。它可以唯一标识一个实体</strong>。</p><p>候选码和主码：</p><ul><li>候选码：如果一组属性集能唯一地标识一个关系中的元组而又不含有多余的属性，则称该属性集为该关系的候选码 。（<strong>候选码可能不止有一个</strong>）</li><li>主码：用户选定的那个候选键称为主键</li></ul><p>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）</p><p>它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}</p><p>如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码</p><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p><strong>关系名和其属性集合的组合称之为关系模式</strong>。</p><p>关系模式例子：课程关系表(课程号,课程名,学时)</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>关系模型要求元组的每一个分量都是原子性的，也就是说，它必须属于某种元素类型，如Integer、String等等，不能是列，集合，记录，数组！</p><p><strong>域就代表着该元组中每个分量的类型</strong>，例如：课程号:string,课程名:string,学时:int</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2019/11/24/DataBase/1566261820297.png" alt="1566261820297"></p><p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p><p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p><p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><h3 id="为什么使用索引？"><a href="#为什么使用索引？" class="headerlink" title="为什么使用索引？"></a>为什么使用索引？</h3><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p><p><strong>磁盘文件存储</strong></p><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><h3 id="什么样的信息能够称为索引？"><a href="#什么样的信息能够称为索引？" class="headerlink" title="什么样的信息能够称为索引？"></a>什么样的信息能够称为索引？</h3><p>主键，唯一键，普通键，有一定区分性</p><p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p><blockquote><p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p></blockquote><p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p><blockquote><p>唯一键不是主键，但主键有不可重复性</p><p>一张表可以有多个唯一键，但只能有一个主键</p></blockquote><p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p><h3 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h3><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p><p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p><p><img src="/2019/11/24/DataBase/1566261830802.png" alt="1566261830802"></p><p>特性：</p><p><img src="/2019/11/24/DataBase/1566261842897.png" alt="1566261842897"></p><p><img src="/2019/11/24/DataBase/1566261850318.png" alt="1566261850318"></p><p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p><p>B+树：</p><p><img src="/2019/11/24/DataBase/1566261860507.png" alt="1566261860507"></p><p>结论：B+树更适合，原因：</p><ul><li><p><strong>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</strong></p></li><li><p><strong>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</strong></p></li><li><p><strong>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</strong></p></li></ul><p><strong>Hash索引了解一下：</strong></p><p>缺点：</p><ul><li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li><li>无法运用索引值来排序</li><li>不能利用部分索引键查询</li><li>不能避免表扫描，哈希值可能重复，需要全表扫描</li><li>大量hash值相等时，效率很底。</li></ul><p>密集索引和稀疏索引</p><p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列（属性）的数据。</p><blockquote><p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p></blockquote><p>稀疏索引：叶子节点仅保存了键位信息（索引键位）及其主键。</p><p>InnoDB的索引</p><p><img src="/2019/11/24/DataBase/1566261871063.png" alt="1566261871063"></p><h3 id="如何定位并优化sql？"><a href="#如何定位并优化sql？" class="headerlink" title="如何定位并优化sql？"></a>如何定位并优化sql？</h3><ul><li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p><p><img src="/2019/11/24/DataBase/1566262283010.png" alt="1566262283010"></p></li><li><p>使用explain等工具分析sql</p><p><img src="/2019/11/24/DataBase/1566262067821.png" alt="1566262067821"></p><ul><li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li><li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li></ul><p><img src="/2019/11/24/DataBase/1566261930304.png" alt="1566261930304"></p><ul><li>字段：extra，如图</li></ul><p><img src="/2019/11/24/DataBase/1566261963108.png" alt="1566261963108"></p></li><li><p>修改sql或者尽量让sql走索引</p><ul><li>改用索引查</li></ul><p><img src="/2019/11/24/DataBase/1566262116465.png" alt="1566262116465"></p><ul><li>添加索引</li></ul><p><img src="/2019/11/24/DataBase/1566262137053.png" alt="1566262137053"></p></li><li><p>使用fore_index()测试那个索引更好</p></li></ul><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p><img src="/2019/11/24/DataBase/1566262151740.png" alt="1566262151740"></p><p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p><p>索引建立的越多越好吗？</p><p><img src="/2019/11/24/DataBase/1566262159079.png" alt="1566262159079"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>首先需要了解：</p><ul><li>对于<code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li><li><strong>MyISAM</strong>在执行查询语句<code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（<code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li></ul><p>其次需要了解：</p><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><ul><li>也就是说，<strong>InnoDB的行锁是基于索引的</strong>！</li></ul><p>Myisam：表级锁，不支持行级锁</p><p>InnoDB：默认行级锁，支持表级锁，</p><blockquote><p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p></blockquote><p>无论表锁还是行锁，默认都分为共享锁和排他锁</p><p><img src="/2019/11/24/DataBase/1566262385992.png" alt="1566262385992"></p><h3 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h3><p>MyISAM</p><ul><li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li><li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li><li>适合没有事务的</li></ul><p>InnoDB</p><ul><li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li><li>支持事务的系统</li></ul><p>数据库锁分类：</p><ul><li>按粒度划分：表级锁，行级锁，页级锁</li><li>按级别划分：共享锁，排他锁</li><li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li><li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li><li><strong>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</strong></li></ul><h3 id="乐观锁和悲观锁："><a href="#乐观锁和悲观锁：" class="headerlink" title="乐观锁和悲观锁："></a>乐观锁和悲观锁：</h3><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul><li><strong>在查询完数据的时候就把事务锁起来，直到提交事务</strong></li><li>实现方式：使用数据库中的锁机制</li></ul></li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<ul><li><strong>在修改数据的时候把事务锁起来，通过version的方式来进行锁定</strong></li><li>实现方式：使用version版本或者时间戳</li></ul></li></ul><h2 id="事务隔离与锁"><a href="#事务隔离与锁" class="headerlink" title="事务隔离与锁"></a>事务隔离与锁</h2><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><p>不同的隔离级别对锁的使用是不同的，<strong>锁的应用最终导致不同事务的隔离级别</strong></p><p>ACID：原子性，一致性，隔离性，持久性</p><p>事务的隔离性以及各级别下的并发问题</p><p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p><p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事务读取另一个事务未提交数据</p><p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p><p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p><p><img src="/2019/11/24/DataBase/1566263834174.png" alt="1566263834174"></p><h3 id="InnoDB引擎的隔离与锁"><a href="#InnoDB引擎的隔离与锁" class="headerlink" title="InnoDB引擎的隔离与锁"></a>InnoDB引擎的隔离与锁</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种<strong>具体方式</strong>，用于实现<strong>提交读</strong>和<strong>可重复读</strong>这两种隔离级别。</p><blockquote><p>而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p></blockquote><blockquote><p>InnoDB<strong>基于行锁</strong>实现了MVCC多版本并发控制，MVCC在隔离级别下的<code>Read committed</code>和<code>Repeatable read</code>下工作。MVCC能够实现<strong>读写不阻塞</strong>！</p></blockquote><h3 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h3><ul><li>通过一定机制生成一个数据请求<strong>时间点的一致性数据快照（Snapshot)</strong>，并用这个快照来提供一定级别（<strong>语句级或事务级</strong>）的<strong>一致性读取</strong>。从用户的角度来看，好像是<strong>数据库可以提供同一数据的多个版本</strong>。</li><li>版本号<ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。<ul><li>版本号用来和查询到的每行记录的版本号进行比较。</li></ul></li></ul></li><li>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：<ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul></li></ul><h4 id="Read-committed实现"><a href="#Read-committed实现" class="headerlink" title="Read committed实现"></a><code>Read committed</code>实现</h4><p>原理：快照读机制，使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><p><code>Read committed</code><strong>避免脏读</strong>的做法其实很简单：</p><ul><li><strong>在读取的时候生成一个版本号，直到事务其他commit被修改了之后，才会有新的版本号</strong>，读取时会对比版本号</li></ul><p>过程：</p><ul><li>事务A读取了记录(生成版本号)</li><li>事务B修改了记录(此时加了写锁)</li><li>事务A再读取的时候，<strong>是依据最新的版本号来读取的</strong>(当事务B执行commit了之后，会生成一个新的版本号)，如果事务B还没有commit，那事务A读取的还是之前版本号的数据。</li></ul><h4 id="Repeatable-read实现"><a href="#Repeatable-read实现" class="headerlink" title="Repeatable read实现"></a><code>Repeatable read</code>实现</h4><p><code>Read committed</code>会出现不可重复读：<strong>一个事务可以看到其他事务所做的修改</strong>。</p><p>例如，<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样（危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了）</strong></p><blockquote><p><code>Read committed</code>是<strong>语句级别</strong>（执行语句）的快照！<strong>每次读取的都是当前最新的数据行版本</strong>！</p></blockquote><blockquote><p><code>Repeatable read</code>避免不可重复读是<strong>事务级别</strong>的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。</p></blockquote><p>总结：事务开启时使用系统版本作为事务版本号，事务开启时数据行更新后使用最新数据行版本号，<strong>读提交实现</strong>使用数据行版本号的比对，确保每次commit被修改了之后，才会有新的版本号，通过版本号实现隔离；<strong>重复读实现</strong>对比的是快照中的事务版本号，即在 <strong>tempdb</strong> 中存储原始行的副本，和为该行添加事务版本号，通过版本号实现隔离。</p><h3 id="InnoDB在可重复度隔离级别下是如何避免幻读？"><a href="#InnoDB在可重复度隔离级别下是如何避免幻读？" class="headerlink" title="InnoDB在可重复度隔离级别下是如何避免幻读？"></a>InnoDB在可重复度隔离级别下是如何避免幻读？</h3><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><p>表象：快照度（非阻塞读）——伪MVCC</p><p>内在：next-key锁（行锁+gap锁）</p><p><img src="/2019/11/24/DataBase/1566264130165.png" alt="1566264130165"></p><p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p><p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p><p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p><ol><li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li><li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li></ol><p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p><p><img src="/2019/11/24/DataBase/1566265001814.png" alt="1566265001814"></p><p>再次修改为（11，32，45）时会发生：</p><p><img src="/2019/11/24/DataBase/1566264973315.png" alt="1566264973315"></p><ol start="3"><li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li></ol><p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p><p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>next-key锁（record锁+gap锁）</p><ul><li><p>record锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</p></li><li><p>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</p></li><li><p>next-key锁：Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10],(10, 11],(11, 13],(13, 20],(20, +∞)</span><br></pre></td></tr></table></figure></li></ul><p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p><p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p><ul><li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li><li>如果where条件部分命中或者未命中，就会加上gap锁</li></ul><p>gap锁会出现在非唯一索引或者不走索引的当前读中</p><p>非唯一索引：</p><p><img src="/2019/11/24/DataBase/1566268250911.png" alt="1566268250911"></p><p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p><p>不走索引</p><p><img src="/2019/11/24/DataBase/1566268427287.png" alt="1566268427287"></p><p>会对所有gap上锁，类似表锁，也能防止幻读。</p><p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p><strong>在我们书写SQL语句的时候，其实书写的顺序、策略会影响到SQL的性能，虽然实现的功能是一样的，但是它们的性能会有些许差别。</strong></p><p>因此，下面就讲解在书写SQL的时候，怎么写比较好。</p><hr><h3 id="选择最有效率的表名顺序"><a href="#选择最有效率的表名顺序" class="headerlink" title="选择最有效率的表名顺序"></a>选择最有效率的表名顺序</h3><p>数据库的解析器按照<strong>从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理</strong></p><p>在FROM子句中包含多个表的情况下：</p><ul><li><strong>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</strong></li><li><strong>也就是说：选择记录条数最少的表放在最后</strong></li></ul><p>如果有3个以上的表连接查询：</p><ul><li><strong>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推</strong>。</li><li><strong>也就是说：被其他表所引用的表放在最后</strong></li></ul><p>例如：查询员工的编号，姓名，工资，工资等级，部门名</p><p><strong>emp表被引用得最多，记录数也是最多，因此放在form字句的最后面</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,salgrade.grade,dept.dname</span><br><span class="line"><span class="keyword">from</span> salgrade,dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal <span class="keyword">between</span> salgrade.losal <span class="keyword">and</span> salgrade.hisal)</span><br></pre></td></tr></table></figure><hr><h3 id="WHERE子句中的连接顺序"><a href="#WHERE子句中的连接顺序" class="headerlink" title="WHERE子句中的连接顺序"></a>WHERE子句中的连接顺序</h3><p>数据库采用自<strong>右而左的顺序解析WHERE子句</strong>,根据这个原理,<strong>表之间的连接必须写在其他WHERE条件之左</strong>,那些<strong>可以过滤掉最大数量记录的条件必须写在WHERE子句的之右</strong>。</p><p><strong>emp.sal可以过滤多条记录，写在WHERE字句的最右边</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.empno,emp.ename,emp.sal,dept.dname</span><br><span class="line"><span class="keyword">from</span> dept,emp</span><br><span class="line"><span class="keyword">where</span> (emp.deptno = dept.deptno) <span class="keyword">and</span> (emp.sal &gt; <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="SELECT子句中避免使用-号"><a href="#SELECT子句中避免使用-号" class="headerlink" title="SELECT子句中避免使用*号"></a>SELECT子句中避免使用*号</h3><p>我们当时学习的时候，星号是可以获取表中全部的字段数据的。</p><ul><li><strong>但是它要通过查询数据字典完成的，这意味着将耗费更多的时间</strong></li><li>使用*号写出来的SQL语句也不够直观。</li></ul><hr><h3 id="用TRUNCATE替代DELETE"><a href="#用TRUNCATE替代DELETE" class="headerlink" title="用TRUNCATE替代DELETE"></a>用TRUNCATE替代DELETE</h3><p>这里仅仅是：<strong>删除表的全部记录，除了表结构才这样做</strong>。</p><p><strong>DELETE是一条一条记录的删除，而Truncate是将整个表删除，保留表结构，这样比DELETE快</strong></p><hr><h3 id="多使用内部函数提高SQL效率"><a href="#多使用内部函数提高SQL效率" class="headerlink" title="多使用内部函数提高SQL效率"></a>多使用内部函数提高SQL效率</h3><p><strong>例如使用mysql的concat()函数会比使用||来进行拼接快，因为concat()函数已经被mysql优化过了。</strong></p><hr><h3 id="使用表或列的别名"><a href="#使用表或列的别名" class="headerlink" title="使用表或列的别名"></a>使用表或列的别名</h3><p><strong>如果表或列的名称太长了，使用一些简短的别名也能稍微提高一些SQL的性能。毕竟要扫描的字符长度就变少了。。。</strong></p><hr><h3 id="多使用commit"><a href="#多使用commit" class="headerlink" title="多使用commit"></a>多使用commit</h3><p>comiit会释放回滚点…</p><hr><h3 id="善用索引"><a href="#善用索引" class="headerlink" title="善用索引"></a>善用索引</h3><p>索引就是为了提高我们的查询数据的，当表的记录量非常大的时候，我们就可以使用索引了。</p><hr><h3 id="SQL写大写"><a href="#SQL写大写" class="headerlink" title="SQL写大写"></a>SQL写大写</h3><p>我们在编写SQL 的时候，官方推荐的是使用大写来写关键字，<strong>因为Oracle服务器总是先将小写字母转成大写后，才执行</strong></p><hr><h3 id="避免在索引列上使用NOT"><a href="#避免在索引列上使用NOT" class="headerlink" title="避免在索引列上使用NOT"></a>避免在索引列上使用NOT</h3><p>因为Oracle服务器遇到NOT后，他就会停止目前的工作，转而执行全表扫描</p><h4 id="避免在索引列上使用计算"><a href="#避免在索引列上使用计算" class="headerlink" title="避免在索引列上使用计算"></a>避免在索引列上使用计算</h4><p>WHERE子句中，<strong>如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢</strong></p><h4 id="用-gt-替代-gt"><a href="#用-gt-替代-gt" class="headerlink" title="用 &gt;= 替代 &gt;"></a>用 <code>&gt;=</code> 替代 <code>&gt;</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">低效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt; <span class="number">3</span>   </span><br><span class="line">首先定位到DEPTNO=<span class="number">3</span>的记录并且扫描到第一个DEPT大于<span class="number">3</span>的记录</span><br><span class="line">高效：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> DEPTNO &gt;= <span class="number">4</span>  </span><br><span class="line">直接跳到第一个DEPT等于<span class="number">4</span>的记录</span><br></pre></td></tr></table></figure><h4 id="用IN替代OR"><a href="#用IN替代OR" class="headerlink" title="用IN替代OR"></a>用IN替代OR</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal = <span class="number">1500</span> <span class="keyword">or</span> sal = <span class="number">3000</span> <span class="keyword">or</span> sal = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal <span class="keyword">in</span> (<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">800</span>);</span><br></pre></td></tr></table></figure><h4 id="总是使用索引的第一个列"><a href="#总是使用索引的第一个列" class="headerlink" title="总是使用索引的第一个列"></a>总是使用索引的第一个列</h4><p>如果索引是建立在多个列上，只有在它的第一个列被WHERE子句引用时，优化器才会选择使用该索引。 当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> emp_sal_job_idex</span><br><span class="line"><span class="keyword">on</span> emp(sal,job);</span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> emp  </span><br><span class="line"><span class="keyword">where</span> job != <span class="string">'SALES'</span>;    </span><br><span class="line"></span><br><span class="line">上边就不使用索引了。</span><br></pre></td></tr></table></figure><h3 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h3><ul><li>1）范式优化： 比如消除冗余（节省空间。。）</li><li>2）反范式优化：比如适当加冗余等（减少join）</li><li>3）拆分表： 垂直拆分和水平拆分</li></ul><h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><p>money</p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><blockquote><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。<br>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y</p></blockquote><p>总结一下：</p><ul><li>首先要明确的是：范式一到三是越来越严格的。<strong>满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</strong></li><li>第一范式：<strong>字段是最小的的单元不可再分</strong><ul><li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li></ul></li><li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul><li><strong>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的</strong></li><li>学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</li></ul></li><li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul><li><strong>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖</strong></li><li>比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种基于数据表的一种<strong>虚表</strong></p><ul><li>（1）视图是一种虚表</li><li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li><li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li><li>（4）视图向用户提供基表数据的另一种表现形式</li><li>（5）视图没有存储真正的数据，真正的数据还是存储在基表中</li><li>（6）程序员虽然操作的是视图，但最终视图还会转成操作基表</li><li>（7）一个基表可以有0个或多个视图</li></ul><p>有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段…</p><p>那么把全部的字段都都显示给他们看，这是不合理的。</p><p>我们应该做到：<strong>他们想看到什么样的数据，我们就给他们什么样的数据…一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来…</strong></p><p><strong>视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便</strong>…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h4 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h4><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" alt="img"></p><h4 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h4><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" alt="img"></p><h4 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h4><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" alt="img"></p><h4 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h4><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" alt="img"></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="MySQL表设计要注意什么？"><a href="#MySQL表设计要注意什么？" class="headerlink" title="MySQL表设计要注意什么？"></a>MySQL表设计要注意什么？</h3><h4 id="主键是用自增还是UUID"><a href="#主键是用自增还是UUID" class="headerlink" title="主键是用自增还是UUID?"></a>主键是用自增还是UUID?</h4><p>肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！。</p><h4 id="主键为什么不推荐有业务含义"><a href="#主键为什么不推荐有业务含义" class="headerlink" title="主键为什么不推荐有业务含义?"></a>主键为什么不推荐有业务含义?</h4><p>有如下两个原因</p><ul><li>因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</li><li>带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</li></ul><h4 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型?"></a>时间字段用什么类型?</h4><p>(1)<code>varchar</code>，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为<code>2013111</code>的数据，请问这是代表2013年1月11日，还是2013年11月1日？<br>其次，做时间比较运算，你需要用<code>STR_TO_DATE</code>等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p><p>(2)<code>timestamp</code>，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用<code>timestamp</code>类型存储的。<br>但是它有一个优势，<code>timestamp</code>类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TIME_ZONE</span> = <span class="string">"america/new_york"</span>;</span><br></pre></td></tr></table></figure><p>你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p><p>(3)<code>datetime</code>，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p><p>(4)<code>bigint</code>，也是8个字节，自己维护一个时间戳，表示范围比<code>timestamp</code>大多了，就是要自己维护，不大方便。</p><h4 id="为什么不直接存储图片、音频、视频等大容量内容"><a href="#为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="为什么不直接存储图片、音频、视频等大容量内容?"></a>为什么不直接存储图片、音频、视频等大容量内容?</h4><p>我们在实际应用中，都是用<code>HDFS</code>来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是<code>text</code>和<code>blob</code>类型。但是，我们在生产中，基本不用这两个类型！<br>主要原因有如下两点</p><ul><li>(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢</li><li>(2)<code>binlog</code>内容太多。因为你数据内容比较大，就会造成<code>binlog</code>内容比较多。大家也知道，主从同步是靠<code>binlog</code>进行同步，<code>binlog</code>太大了，就会导致主从同步效率问题！</li></ul><p>因此，不推荐使用<code>text</code>和<code>blob</code>类型！</p><h4 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL?"></a>字段为什么要定义为NOT NULL?</h4><p>(1)索引性能不好</p><blockquote><p>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。                                                                              </p></blockquote><p>(2)查询会出现一些不可预料的结果<br>这里举一个例子，大家就懂了。假设，表结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>表数据是这样的</p><table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">孤独烟</td></tr><tr><td align="center">3</td><td align="center">null</td></tr><tr><td align="center">5</td><td align="center">肥朝</td></tr><tr><td align="center">7</td><td align="center">null</td></tr></tbody></table><p>你执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> table_2;</span><br></pre></td></tr></table></figure><p>你会发现结果为2，但是实际上是有四条数据的！类似的查询问题，其实有很多，不一一列举。<br>记住，因为null列的存在，会出现很多出人意料的结果，从而浪费开发时间去排查Bug.</p><h3 id="索引的特点"><a href="#索引的特点" class="headerlink" title="索引的特点"></a>索引的特点</h3><ul><li><strong>是一种快速查询表中内容的机制，</strong></li><li><strong>运用在表中某个些字段上，但存储时，独立于表之外</strong></li></ul><p>索引的特点</p><ul><li>索引一旦建立, <strong>DB管理系统会对其进行自动维护</strong>, 而且由DB管理系统决定何时使用索引</li><li>用户不用在查询语句中指定使用哪个索引</li><li><strong>在定义primary key或unique约束后系统自动在相应的列上创建索引</strong></li><li>用户也能按自己的需求，对指定单个字段或多个字段，添加索引</li></ul><table><thead><tr><th align="center">什么时候【要】创建索引</th><th align="center">什么时候【不要】创建索引</th></tr></thead><tbody><tr><td align="center">表经常进行 SELECT 操作</td><td align="center">表经常进行 INSERT/UPDATE/DELETE 操作</td></tr><tr><td align="center">表很大(记录超多)，记录内容分布范围很广</td><td align="center">表很小(记录超少)</td></tr><tr><td align="center">列名经常在 WHERE 子句或连接条件中出现</td><td align="center">列名不经常作为连接条件或出现在 WHERE 子句中</td></tr></tbody></table><p><strong>索引优缺点：</strong></p><ul><li>索引加快数据库的检索速度</li><li>索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，但是它们也会导致数据库系统更新数据的性能下降，<strong>因为大部分数据更新需要同时更新索引</strong>)</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li><li>索引需要占物理和数据空间</li></ul><p>索引分类：</p><ul><li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li><li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空</li><li><strong>聚集索引</strong>(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个</li><li><strong>二级索引</strong>(Non-clustered)：二级索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。</li></ul><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a>SQL 约束有哪几种？</h3><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="一个-SQL-执行的很慢？"><a href="#一个-SQL-执行的很慢？" class="headerlink" title="一个 SQL 执行的很慢？"></a>一个 SQL 执行的很慢？</h3><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log （<strong>重做日志</strong>）写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><h3 id="MySQL-基础架构分析"><a href="#MySQL-基础架构分析" class="headerlink" title="MySQL 基础架构分析"></a>MySQL 基础架构分析</h3><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><p><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p><p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></p><h3 id="SQL语句执行过程分析"><a href="#SQL语句执行过程分析" class="headerlink" title="SQL语句执行过程分析"></a>SQL语句执行过程分析</h3><p>对于查询等过程如下：权限校验—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</p><p>对于更新等语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log prepare—》binlog（归档日志）—》redo log commit</p><h3 id="常用的存储引擎"><a href="#常用的存储引擎" class="headerlink" title="常用的存储引擎"></a>常用的存储引擎</h3><ul><li><strong>Innodb引擎</strong>，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><table><thead><tr><th align="center"></th><th align="center">Innodb</th><th align="center">MyIASM</th></tr></thead><tbody><tr><td align="center">事务</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">哈希索引</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">全文索引</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">存储容量</td><td align="center">64TB</td><td align="center">无上限</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ComputerNetworks</title>
      <link href="/2019/11/22/ComputerNetworks/"/>
      <url>/2019/11/22/ComputerNetworks/</url>
      
        <content type="html"><![CDATA[<p>引言</p><blockquote><ol><li>记录慕课网《剑指offer》课程中计算机网络部分面试知识</li><li>面试问题记录，涉及的较少</li></ol></blockquote><a id="more"></a><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p> <img src="/2019/11/22/ComputerNetworks/image-20191122201138746.png" alt="image-20191122201138746"> </p><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><ul><li><p>物理层：两台物理机器之间传输比特流，定义物理设备的标准，网卡</p></li><li><p>数据链路层：在传输比特流的过程会产生各种错误，数据链路层应运而生，该层定义了如何格式化数据以进行传输以及控制对物理介质的访问，还提供错误检测和纠正。该层将比特数据组成帧，交换机工作在该层，对帧解码，根据帧中的数据将信息发送到正确的接收方。</p></li></ul><blockquote><p>随着网络节点的增加，点对点间的通信是需要经过多个节点的，如何找到目标节点，如何选择最佳路径是首要需求，此时产生网络层</p></blockquote><ul><li>网络层：其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。发送方综合考虑发送优先权、网络拥塞、服务质量、可选路由的花费决定从网络中一个节点A到另一个网络中B的最佳路径，网络层处理并智能指导数据传送，路由器连接网络各端，所以路由器属于网络层。此层的数据称为数据包。本层关注TCP/IP协议中的IP协议。</li></ul><blockquote><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，可能需要很长时间，网络在通信过程会中断多次，此时为了保证传输文件的准确性，需要对发出去的数据进行切分，切为数据段。当发生数据段络丢失，失序等情况时，传输层应运而生。</p></blockquote><ul><li>传输层：解决主机间的数据传输，和传输质量问题。该层传输协议进行流量控制或是基于接收方可接受数据的快慢程度规定适当的发送速率。同时分割数据包以适应在网络上传输（以太网无法接受大于1500字节的数据包），分割数据为数据片，同时在数据片上给定序号，以便接受时可按序排组。需要关注TCP和UDP协议。</li></ul><blockquote><p>为了不用用户级不要每次调用TCP打包数据，IP协议去寻找路由，现在需要自动收发包，自动寻址的功能，会话层应运而生</p></blockquote><ul><li>会话层：作用是建立和管理应用程序之间的通信。至此可以保证用用程序能够自动收发包和寻址。</li></ul><blockquote><p>考虑各应用程序的环境不同，如window和Linux之间的差异，需要表示层来消除</p></blockquote><ul><li>表示层：解决不同系统之间的通信语法的问题，该层数据将按照网络能够理解的方式进行格式化。此时完成数据转化成相应的字节。</li></ul><blockquote><p>此时发送方知道发送的数据是什么，转换成字节数据有多长，但接收方并不知道，为了发送方和接收方能够理解传输字节的含义，应用层网络协议诞生</p></blockquote><ul><li>应用层：应用层网络协议规定消息发送方和接收方必须使用一个固定长度的一个消息头，消息头必须是固定组成，记录各种信息以方便接收方解析。该层旨在让你能够更方便的从网络中接受数据，没有该层也可以在两台主机间传递，但是我们能了解的就是一堆0101编码的字节数组。需要关注TCP/IP协议中的HTTP协议。</li></ul><p>这是一个框架来协调和组织各层所提供的服务，但是该模型仅是概念模型，来协调进程间通信标准的制定。实际的实现是TCP/IP协议。</p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p> TCP/IP 是 Internet上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。 </p><p><img src="/2019/11/22/ComputerNetworks/image-20191122201724700.png" alt="image-20191122201724700"></p><h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><h3 id="传输控制协议-TCP-简介"><a href="#传输控制协议-TCP-简介" class="headerlink" title="传输控制协议 TCP 简介"></a>传输控制协议 TCP 简介</h3><ul><li>面向连接的、可靠的基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的 TCP 层</li><li>数据包都是由序号，对方收到则发送 ACK 确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><p>IP协议是无连接的协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求每条线可以同时满足许多不同计算机之间的通信需要。通过IP协议，消息或者其他数据会被分割为较小的包，并通过因特网在计算机之间传送，IP负责将每个包路由至他的目的地，但是IP协议未作任何事来确认数据包是否安全到达，所以他是不可靠的，需要他的上层协议来控制。传输控制协议TCP是传输层的协议。（简介）</p><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="/2019/11/22/ComputerNetworks/image-20191122204017097.png" alt="image-20191122204017097"></p><ul><li><strong>源端口、目的端口</strong> ：各2个字节，TCP/UDP都是不包含IP地址信息的，两者头部都会有端口号，这是在传输层范畴的知识。两个进程在计算机内部进行通信可以有：管道、内存共享、信号量和消息队列等方法。其中最唯一要求是唯一的表示对方进程，在本地进程中可以使用PID，但是在网络中的不同主机中使用便失效了，解决方式就是在传输层中使用协议端口号，已知在网络层中IP可以唯一标识一个主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样可以利用IP地址+协议+端口号这样的唯一标识去表示网络中的一个进程，这种方式也成为套接字。这样，虽然通信的重点是应用进程，但是我们只要把要传送的报文交到目的主机的某一个合适端口中，剩下的工作就由TCP来完成了。</li><li><strong>seq序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>ack确认号</strong> ：表示期望收到对方下一个报文的第一个字节的序号。例如B收到A发送的报文seq序号是301，全部数据是200字节，B正确收到从A发送的序号到500（301+200-1）的数据，所以B期望收到的A的下一个数据序号是501，于是，B在发送给A的确认报文中，会把ack确认号置为501。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li>连接标志（TCP Flags）：表示控制功能，下面是常见的连接标志。<ul><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=a1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li></ul></li><li><strong>窗口</strong> ：滑动窗口大小，告知发送端接收端的缓存大小（还有多少空间可以接收数据，因为接收方的数据缓存空间是有限的），以此控制发送端发送数据速率，从而达到流量控制。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>当应用程序希望通过TCP和另一个应用程序通信时，会发送一个通信请求，必须有一个确切地址，在双方握手后TCP将在两个程序间建立一个全双工的通信，将占据两个计算机的通信线路，直到双方关闭为止。（三次握手）</p><p><img src="/2019/11/22/ComputerNetworks/1566261217747.png" alt="1566261217747"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><img src="/2019/11/22/ComputerNetworks/1566261228418-1574427053238.png" alt="1566261228418"></p><h3 id="为什么要三次连接"><a href="#为什么要三次连接" class="headerlink" title="为什么要三次连接"></a>为什么要三次连接</h3><p>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><h3 id="关于建连接时SYN超时"><a href="#关于建连接时SYN超时" class="headerlink" title="关于建连接时SYN超时"></a>关于建连接时SYN超时</h3><p>试想一下，如果server端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的TCP会重发 SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p><h3 id="关于SYN-Flood攻击"><a href="#关于SYN-Flood攻击" class="headerlink" title="关于SYN Flood攻击"></a>关于SYN Flood攻击</h3><p>一些恶意的人就为此制造了SYN Flood攻击，给服务器发了一个SYN后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫 <strong>tcp_syncookies</strong> 的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p><p>请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择。</p><ul><li>第一个是：tcp_synack_retries 可以用他来减少重试次数；</li><li>第二个是：tcp_max_syn_backlog，可以增大SYN连接数；</li><li>第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了 ；</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍然未收到响应则中断连接</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>即断开连接时需要客户端和服务端总共发送4各数据包来确认断开连接。</p><p><img src="/2019/11/22/ComputerNetworks/1566261278901.png" alt="1566261278901"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>TCP连接是全双工的，服务端可以发送数据到客户端，客户端也可以发送数据到服务端，发送方和接收方都需要两次挥手才能关闭 。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><img src="/2019/11/22/ComputerNetworks/1566261373431.png" alt="1566261373431"></p><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>前面我们说了 TCP 现在我们来认识一下 UDP。</p><h3 id="UPD-的特点"><a href="#UPD-的特点" class="headerlink" title="UPD 的特点"></a>UPD 的特点</h3><ul><li>面向非连接的</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有 8 个字节，额外开销较小</li><li>吞吐量只受限于数据生成率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或则合并</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h2 id="TCP-的滑动窗口"><a href="#TCP-的滑动窗口" class="headerlink" title="TCP 的滑动窗口"></a>TCP 的滑动窗口</h2><p>首先明确：</p><p>TCP滑动窗口分为接受窗口，发送窗口。</p><p>滑动窗口协议是<strong>传输层进行流控</strong>的一种措施，<strong>接收方通过通告发送方自己的窗口大小</strong>，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：</p><ul><li>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</li><li>二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理</li></ul><p><strong>重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。</strong></p><p>发送端窗口的第一个字节序号一定是ACK中期望收到的下一个字节序号，比如下图：</p><p><img src="/2019/11/22/ComputerNetworks/image-20191122205849513.png" alt="image-20191122205849513"></p><p>上图52 53 54 55 字节都是可以新发送的字节序。</p><p>接受端窗口的第一个字节序之前一定是已经完全接收的，后面窗口里面的数据都是希望接受的，窗口后面的数据都是不希望接受的。</p><p>TCP的滑动窗口分为接收窗口和发送窗口 不分析这两种窗口就讨论是不妥当的。 TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>主要特点如下：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持 B/S 及 C/S 模式。</li></ul><p>请求结构：</p><p><img src="/2019/11/22/ComputerNetworks/1566261538473.png" alt="1566261538473"></p><p>响应结构：</p><p><img src="/2019/11/22/ComputerNetworks/1566261644094.png" alt="1566261644094"></p><p>总结：http协议定义了web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端，http协议采用了请求响应模型，客户端向服务器发送一个请求报文，包含请求方法，url，协议版本，请求头部，请求数据；服务器以一个状态行作为响应，响应内容包括，协议版本，错误或成功信息，服务器信息，响应头部和响应数据。</p><ul><li>连接：客户端与web服务器的http端口建立一个TCP套接字连接</li><li>发送请求：即通过套接字客户端向web服务端发送一个文本的请求报文</li><li>响应：服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取</li><li>释放连接：keep-live长连接会保存一段时间，该时间内请求还会响应</li><li>客户端解析：首先解析状态行，查看表明请求是否成功的状态代码，解析响应头，响应头告知以下若干数据为数据信息，客户端按照格式解析数据，在浏览器窗口显示。</li></ul><p>URL输入后的流程？？？</p><ol><li>DNS解析：浏览器会根据url逐层查询DNS服务器缓存，解析url中的域名所对应的IP地址（DNS缓存从近到远为浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存），此时找到IP地址</li><li>TCP连接：找到IP地址后会根据IP地址和对应端口与服务器建立TCP连接（三次握手）</li><li>发送HTTP请求：浏览器会发起读取文件的http请求，</li><li>服务器处理请求并返回HTTP报文：服务器对浏览器请求响应，并把对应的带有http文本的http响应报文发送给浏览器</li><li>浏览器解析渲染页面：浏览器收到报文，解析渲染到浏览器</li><li>释放连接</li></ol><p>状态码</p><p><img src="/2019/11/22/ComputerNetworks/1566261699701.png" alt="1566261699701"></p><h3 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h3><p>从三个层面来解答：</p><ul><li>Http 报文层面：GET 将请求信息放在 URL中，POST 方法报文中</li><li>数据库层面：GET 符合幂等性和安全性，POST 不符合</li><li>其他层面：GET 可以被缓存、被存储（书签），而 POST 不行</li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p><strong>Cookie 简介：</strong></p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把 Cookie 回发给服务端</li><li>服务器接收到后，会解析 Cookie 生成与客户端相对的内容</li></ul><p><strong>Cookiet 的设置以及发送过程：</strong></p><p><img src="/2019/11/22/ComputerNetworks/image-20191122210015905.png" alt="image-20191122210015905"></p><p><strong>Session 简介：</strong></p><ul><li>服务端的机制，在服务端保存的信息</li><li>解析客户端请求并操作 Session id ，按需保存状态信息</li></ul><p><strong>Session 的实现方式：</strong></p><ul><li>使用 Cookie 来实现</li><li>使用 URL 回写来实现，每次在 URL 添加 Session id 信息</li></ul><p><strong>区别</strong>：</p><ul><li>Cookie 数据存放在客户端的浏览器上，Session 数据存放在服务器上</li><li>Session 相对于 Cookie 更安全</li><li>若考虑减轻服务器负担，应当使用 Cookie</li></ul><h3 id="HTTP-和-HTTPs-的区别"><a href="#HTTP-和-HTTPs-的区别" class="headerlink" title="HTTP 和 HTTPs 的区别"></a>HTTP 和 HTTPs 的区别</h3><p><img src="/2019/11/22/ComputerNetworks/image-20191122210051958.png" alt="image-20191122210051958"></p><h4 id="SSL-Security-Sockets-Layer-安全套接层"><a href="#SSL-Security-Sockets-Layer-安全套接层" class="headerlink" title="SSL (Security Sockets Layer) 安全套接层"></a>SSL (Security Sockets Layer) 安全套接层</h4><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的 API，SSL 3.0 更名为 TLS</li><li>采用身份验证和数据加密来保证网络的通信的安全和数据的完整性</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTPS 需要到 CA 申请证书，HTTP 不需要</li><li>HTTPS 密文传输，HTTP 明文传输</li><li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li><li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，较 HTTP 安全</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>唯一标识一个进程：本地中使用PID；</p><p>网络中进程：IP地址+协议+端口号来唯一标识一个网络中的一个进程；</p><p><img src="/2019/11/22/ComputerNetworks/1566261798658.png" alt="1566261798658"></p><p>socket通信流程</p><p><img src="/2019/11/22/ComputerNetworks/1566261805698.png" alt="1566261805698"></p><ul><li><input disabled type="checkbox"> Socket通信编程</li></ul><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="OSI与TCP-IP的协议"><a href="#OSI与TCP-IP的协议" class="headerlink" title="OSI与TCP/IP的协议"></a>OSI与TCP/IP的协议</h3><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/NwMQ9mez*i97f2u6JhqrOh14XAag318f8TuAngEDQ8w!/b/dL8AAAAAAAAA&bo=eQJYAXkCWAEDKQw!&rf=viewer_4" alt="五层体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.xn--comoracle-xj3h/" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/" target="_blank" rel="noopener">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在物理层上所传送的数据单位是比特。 <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p><h3 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h3 id="TCP、UDP-协议的区别"><a href="#TCP、UDP-协议的区别" class="headerlink" title="TCP、UDP 协议的区别"></a>TCP、UDP 协议的区别</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/8Mtws13i04*MNhxm7c6NUQukdKULAlH2ajFaBni3uZc!/b/dDQBAAAAAAAA&bo=YQPbAGED2wADGTw!&rf=viewer_4" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><h4 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h4><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><h4 id="滑动窗口和流量控制"><a href="#滑动窗口和流量控制" class="headerlink" title="滑动窗口和流量控制"></a>滑动窗口和流量控制</h4><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h3 id="URL-到网页显示"><a href="#URL-到网页显示" class="headerlink" title="URL 到网页显示"></a>URL 到网页显示</h3><p>图解（图片来源：《图解HTTP》）：</p><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/krh8m5lpufZU6OX9enXcVdQrVltJTku3irYOENXzFxM!/b/dFMBAAAAAAAA&bo=1AI.AtQCPgIDKQw!&rf=viewer_4" alt="状态码"></p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="各种协议与HTTP协议"><a href="#各种协议与HTTP协议" class="headerlink" title="各种协议与HTTP协议"></a>各种协议与HTTP协议</h3><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/08ikSdkksqhIeEzyW6wrL6*jbSfpvdT2Kr.BKbEOhO4!/b/dDMBAAAAAAAA&bo=SQOpBEkDqQQDSWw!&rf=viewer_4" alt="各种协议与HTTP协议之间的关系"></p><h3 id="HTTP长连接、短连接"><a href="#HTTP长连接、短连接" class="headerlink" title="HTTP长连接、短连接"></a>HTTP长连接、短连接</h3><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p><h3 id="HTTP状态保存机制"><a href="#HTTP状态保存机制" class="headerlink" title="HTTP状态保存机制"></a>HTTP状态保存机制</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><h3 id="Cookie、Session的解析"><a href="#Cookie、Session的解析" class="headerlink" title="Cookie、Session的解析"></a>Cookie、Session的解析</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h4 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-type</span>: text/html</span><br><span class="line"><span class="attribute">Set-Cookie</span>: yummy_cookie=choco</span><br><span class="line"><span class="attribute">Set-Cookie</span>: tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sample_page.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: www.example.org</span><br><span class="line"><span class="attribute">Cookie</span>: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="HTTP-1-0与HTTP-1-1"><a href="#HTTP-1-0与HTTP-1-1" class="headerlink" title="HTTP 1.0与HTTP 1.1"></a>HTTP 1.0与HTTP 1.1</h3><blockquote><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A</a>? 的一些内容。</p></blockquote><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/mkJaDOUBzk87ThnK15P3txuYPndh*ZE.fSG4NT7DD0c!/b/dL4AAAAAAAAA&bo=kALdAJAC3QADCSw!&rf=viewer_4" alt="img"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="http://m.qpic.cn/psb?/V11tv2Vw2h2WsJ/zJyJco59whskn9W9AoddItbQ6kJgG.hSY470evBfB2A!/b/dL8AAAAAAAAA&bo=wAILAcACCwEDGTw!&rf=viewer_4" alt="img"></p><h3 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h3><ol><li><p><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ol><h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1Copy to clipboardErrorCopied</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</span><br></pre></td></tr></table></figure><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure><h4 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h4><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h4><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h3 id="HTTP请求的-7-个步骤"><a href="#HTTP请求的-7-个步骤" class="headerlink" title="HTTP请求的 7 个步骤"></a>HTTP请求的 7 个步骤</h3><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</p>]]></content>
      
      
      <categories>
          
          <category> Interview Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Java</title>
      <link href="/2019/08/26/%E5%89%91%E6%8C%87Java/"/>
      <url>/2019/08/26/%E5%89%91%E6%8C%87Java/</url>
      
        <content type="html"><![CDATA[<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>OSI制定的是概念框架：7层协议。</p><a id="more"></a><p>物理层：两台物理机器之间传输比特流，定义物理设备的标准，网卡</p><p>数据链路层：在传输比特流的过程会产生各种错误，数据链路层应运而生，该层定义了如何格式化数据以进行传输以及控制对物理介质的访问，还提供错误检测和纠正。该层将比特数据组成帧，交换机工作在该层，对帧解码，根据帧中的数据将信息发送到正确的接收方。</p><blockquote><p>随着网络节点的增加，点对点间的通信是需要经过多个节点的，如何找到目标节点，如何选择最佳路径是首要需求，此时产生网络层</p></blockquote><p>网络层：其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。发送方综合考虑发送优先权、网络拥塞、服务质量、可选路由的花费决定从网络中一个节点A到另一个网络中B的最佳路径，网络层处理并智能指导数据传送，路由器连接网络各端，所以路由器属于网络层。此层的数据称为数据包。本层关注TCP/IP协议中的IP协议。</p><blockquote><p>随着网络通信需求的进一步扩大，通信过程中需要发送大量数据，可能需要很长时间，网络在通信过程会中断多次，此时为了保证传输文件的准确性，需要对发出去的数据进行切分，切为数据段。当发生数据段络丢失，失序等情况时，传输层应运而生。</p></blockquote><p>传输层：解决主机间的数据传输，和传输质量问题。该层传输协议进行流量控制或是基于接收方可接受数据的快慢程度规定适当的发送速率。同时分割数据包以适应在网络上传输（以太网无法接受大于1500字节的数据包），分割数据为数据片，同时在数据片上给定序号，以便接受时可按序排组。需要关注TCP和UDP协议。</p><blockquote><p>为了不用用户级不要每次调用TCP打包数据，IP协议去寻找路由，现在需要自动收发包，自动寻址的功能，会话层应运而生</p></blockquote><p>会话层：作用是建立和管理应用程序之间的通信。至此可以保证用用程序能够自动收发包和寻址。</p><blockquote><p>考虑各应用程序的环境不同，如window和Linux之间的差异，需要表示层来消除</p></blockquote><p>表示层：解决不同系统之间的通信语法的问题，该层数据将按照网络能够理解的方式进行格式化。此时完成数据转化成相应的字节。</p><blockquote><p>此时发送方知道发送的数据是什么，转换成字节数据有多长，但接收方并不知道，为了发送方和接收方能够理解传输字节的含义，应用层网络协议诞生</p></blockquote><p>应用层：应用层网络协议规定消息发送方和接收方必须使用一个固定长度的一个消息头，消息头必须是固定组成，记录各种信息以方便接收方解析。该层旨在让你能够更方便的从网络中接受数据，没有该层也可以在两台主机间传递，但是我们能了解的就是一堆0101编码的字节数组。需要关注TCP/IP协议中的HTTP协议。</p><p>这是一个框架来协调和组织各层所提供的服务，但是该模型仅是概念模型，来协调进程间通信标准的制定。实际的实现是TCP/IP协议。</p><h3 id="为什么有了MAC层还要走IP层"><a href="#为什么有了MAC层还要走IP层" class="headerlink" title="为什么有了MAC层还要走IP层"></a>为什么有了MAC层还要走IP层</h3><p><code>mac地址就好像个人的身份证号，人的身份证号和人户口 所在的城市，出生的日期有关，但是和人所在的位置没有关系</code>，人是会移动的，知道一个人的身份证号，并不能找到它这个人，mac地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的mac，并不能 在网络中将数据发送给它，除非它和发送方的在同一个网 络内。所以要实现机器之间的通信，还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于 城市名+道路号+门牌号的概念。通过ip层的寻址，我们能知道按何种路径在全世界任意两台Internet上的的机器间传输数据</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>IP协议是无连接的协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求每条线可以同时满足许多不同计算机之间的通信需要。通过IP协议，消息或者其他数据会被分割为较小的包，并通过因特网在计算机之间传送，IP负责将每个包路由至他的目的地，但是IP协议未作任何事来确认数据包是否安全到达，所以他是不可靠的，需要他的上层协议来控制。传输控制协议TCP是传输层的协议。（简介）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261200266.png" alt="1566261200266"></p><p>TCP报文头：</p><p>源端口和目的端口各2个字节，TCP/UDP都是不包含IP地址信息的，两者头部都会有端口号，这是在传输层范畴的知识。两个进程在计算机内部进行通信可以有：管道、内存共享、信号量和消息队列等方法。其中最唯一要求是唯一的表示对方进程，在本地进程中可以使用PID，但是在网络中的不同主机中使用便失效了，解决方式就是在传输层中使用协议端口号，已知在网络层中IP可以唯一标识一个主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样可以利用IP地址+协议+端口号这样的唯一标识去表示网络中的一个进程，这种方式也成为套接字。这样，虽然通信的重点是应用进程，但是我们只要把要传送的报文交到目的主机的某一个合适端口中，剩下的工作就由TCP来完成了。</p><p>sequence number（seq序号）4字节，tcp连接中传送的字节流中的每个字节都有序号，例如一段报文的序号字段值是107，携带的数据字节数是100，那么下一个报文段的序号就是107+100，即从207开始。</p><p>ACK number（ack序号）4字节，表示期望收到对方下一个报文的第一个字节的序号。例如B收到A发送的报文seq序号是301，全部数据是200字节，B正确收到从A发送的序号到500（301+200-1）的数据，所以B期望收到的A的下一个数据序号是501，于是，B在发送给A的确认报文中，会把ack确认号置为501。</p><p>TCP Flags</p><ul><li>ACK：确认序号标志，1有效，0表示报文中不含确认信息，忽略确认号字段</li><li>SYN：同步序号，用于建立连接过程</li><li>FIN：finish标志，用于释放连接，1时表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul><p>Window窗口：滑动窗口大小，告知发送端接收端的缓存大小（还有多少空间可以接收数据），以此控制发送端发送数据速率，从而达到流量控制</p><p>通信过程：</p><p>当应用程序希望通过TCP和另一个应用程序通信时，会发送一个通信请求，必须有一个确切地址，在双方握手后TCP将在两个程序间建立一个全双工的通信，将占据两个计算机的通信线路，直到双方关闭为止。（三次握手）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261217747.png" alt="1566261217747"></p><p>第一次A发送seq=x，B响应时，ack=x+1表示期望下一个从A发来的报文字节从x+1开始，同时B也发送一个自己的缓存初始化序列号seq=y，这里第二次握手完成。A收到确认后，还要向B给出一个确认：小ack=y+1，表示期望从B接受到的报文字节从y+1开始，同时，自己的报文序号从seq=x+1开始（B告知的），此时TCP连接建立，其中第三个报文可以携带数据，前两个不可以。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261228418.png" alt="1566261228418"></p><p>为什么要三次连接？</p><p>为了初始化Sequence Number 的初始值，通信双方要互相通知初始化的Sequence Number，也就是x和y，这是是作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输发生错误，即TCP会用这个数值来拼接数据。所以需要第三次握手：告知服务端，客户端已经知道了你的Sequence Number 了。</p><p>第一次握手的隐患！SYN的超时问题！</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261239169.png" alt="1566261239169"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261247780.png" alt="1566261247780"></p><p>连接后客户端故障怎么办？</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261257369.png" alt="1566261257369"></p><p>TCP四次挥手？</p><p>即断开连接时需要客户端和服务端总共发送4各数据包来确认断开连接。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261278901.png" alt="1566261278901"></p><p>客户端开始发送连接释放报文，并且停止发送数据，FIN=1，seq=u（已传送的最后一个字节的序号）；服务器收到后发出确认报文，ACK=1，小ack=u+1（表示期望从客户端收到的下一个报文从字节u+1开始），seq=v（表示自己的序列号）；此时服务端进入关闭等待状态，TCP通知高层进程客户端要释放联系了，这是出于半关闭状态：即客户端已经不发送数据了，服务端发送数据客户端还是会接受的。此时客户端进入等待关闭状态2，等待服务器的第3次挥手请求。等到服务器发送完数据后，服务器便发送连接释放报文，FIN=1，ACK=1，ack=u+1（表示客户端发送的下一个报文字节号从哪开始），seq=w（表示自己的序列号）；最后，客户端发送确认报文，ACK=1，ack=w+1，seq=u+1（自己的序号），此时客户端进入等待状态，还没完全关闭（2MSL），服务端已经完全关闭，完成4次挥手。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261354806.png" alt="1566261354806"></p><p>为什么客户端要等待2MSL再关闭？</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261362533.png" alt="1566261362533"></p><p>为什么需要四次挥手？</p><p>因为全双工，发送方和接收方都需要FIN报文和ACK报文，即发送方和接收方各只需两次挥手，因为有一方是被动的，所以看上去是4次挥手。？？？？？？？？？？？</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261373431.png" alt="1566261373431"></p><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p>不支持像TCP滑动窗口、错误重传等机制。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261476354.png" alt="1566261476354"></p><p>吞吐量不受拥塞控制。面向报文，添加首部后直接向下交付给IP层</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261484934.png" alt="1566261484934"></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>RTT：发送一个数据包到接收到对应ACK，所花费的时间</p><p>RTO：TCP在发送一个数据报后会启用数据重传计时器，收到ACK时他就失效，未收到ACK而且计时器时间也到了，那就要重传。</p><p>为了实现数据的批量传送，同时解决可靠性和包乱序的问题，所以TCP需要知道网络实际的处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261500714.png" alt="1566261500714"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261526343.png" alt="1566261526343"></p><p>特点：客户端像服务端请求数据的时候只需传送请求方法（get/post等）和路径。http1.1开始默认使用长连接，即服务器需要等待一段时间才断开连接。无状态协议，指协议对事物处理无记忆能力。</p><p>请求结构：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261538473.png" alt="1566261538473"></p><p>响应结构：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261644094.png" alt="1566261644094"></p><p>总结：http协议定义了web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端，http协议采用了请求响应模型，客户端向服务器发送一个请求报文，包含请求方法，url，协议版本，请求头部，请求数据；服务器以一个状态行作为响应，响应内容包括，协议版本，错误或成功信息，服务器信息，响应头部和响应数据。</p><ul><li>连接：客户端与web服务器的http端口建立一个TCP套接字连接</li><li>发送请求：即通过套接字客户端向web服务端发送一个文本的请求报文</li><li>响应：服务器解析请求，定位请求资源，将资源副本写到TCP套接字，由客户端读取</li><li>释放连接：keep-live长连接会保存一段时间，该时间内请求还会响应</li><li>客户端解析：首先解析状态行，查看表明请求是否成功的状态代码，解析响应头，响应头告知以下若干数据为数据信息，客户端按照格式解析数据，在浏览器窗口显示。</li></ul><p>URL输入后的流程？？？</p><ol><li>DNS解析：浏览器会根据url逐层查询DNS服务器缓存，解析url中的域名所对应的IP地址（DNS缓存从近到远为浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存），此时找到IP地址</li><li>TCP连接：找到IP地址后会根据IP地址和对应端口与服务器建立TCP连接（三次握手）</li><li>发送HTTP请求：浏览器会发起读取文件的http请求，</li><li>服务器处理请求并返回HTTP报文：服务器对浏览器请求响应，并把对应的带有http文本的http响应报文发送给浏览器</li><li>浏览器解析渲染页面：浏览器收到报文，解析渲染到浏览器</li><li>释放连接</li></ol><p>状态码</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261699701.png" alt="1566261699701"></p><p>GET和POST请求区别</p><ol><li>Http报文层：get将请求信息放在url中，请求信息和url以问号？隔开，请求信息的格式为键值对；post请求将请求信息放在报文体中，想获得请求信息必须解析报文，因此安全性较高。而且get请求会有长度限制，post无限制。</li><li>数据库层面：get符合幂等性和安全性，多次访问数据库的结果是一样的，不改变数据库的值；post都不符合。</li><li>其他层面：get请求能够被缓存，保存在浏览器的浏览记录中；post不具备。通常绝大部分的get请求都被cdn缓存了，大大减少了服务器的压力，而post请求必须要服务器来处理。</li></ol><p>cookie和session的区别</p><p>因为Http是无状态的，每次我们访问有登陆需求的业务时都要输入账号密码，使用cookie和session避免了这种情况。</p><p>cookie：客户端机制。由服务器发送给客户端的特殊信息，以文本的形式存放在客户端，客户端每次向服务器发送请求的时候都会带上这些特殊信息；当客户使用浏览器访问一个支持cookie的网站时，用户会提供一个包括用户名在内的个人信息并且提交至服务器，紧接着服务器向客户端回传相应的超文本时也会发回这些个人信息，这些是放在http响应头中，当用户端接受来自服务器的响应后，浏览器会将这些信息存放在统一位置，自此客户端再向服务器发送请求的时候，会把相应的cookie再次发送至服务器中，这次cookie将会存放在http请求头中，有了cookie后，服务端再次接受请求后，会解析存在于请求头中的cookie得到客户端特有的信息，从而动态生成与该客户端相应的内容。</p><p>cookie的设置和发送过程：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261750519.png" alt="1566261750519"></p><p>session：服务器端机制。当程序需要为某个客户端请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识，称为sessionId，如果包含，则说明以前已为该客户端创建过session，服务器就按照sessionId把这个session检索出来使用（检索不到就生成一个）。不包含就创建一个session和与此相关的sessionId。这个sessionId将会回发给客户端进行保存。</p><p>实现方式：</p><p>使用cookie实现，服务器给每个session分配一个唯一的JSESSIONID，并通过cookie发送给客户端，待客户端发送新的请求时，将在cookie头中携带这个JSESSIONID，这样服务器能够找到客户端对应的session。</p><p>使用URL重写实现，是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID参数，这样客户端点击任何链接都会将JSESSIONID带回服务器。如果直接在浏览器输入服务器资源url，是请求不到session的，tomcat对session的实现是同时使用cookie和url重写。</p><p>区别：</p><p>cookie数据存放在客户的浏览器上，session数据放在服务器上</p><p>session相对于本地存放的cookie更安全</p><p>session会一定时间内保存在服务器上，当缓存增多时会影响服务器性能，应当使用cookie</p><p>HTTP和HTTPS</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261761422.png" alt="1566261761422"></p><p>简单说就是安全版的http协议。</p><p>SSL：</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议。</li><li>是操作系统对外的API，后更名为TLS</li><li>采用身份验证和数字加密保证安全性</li></ul><p>加密的方式：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261769541.png" alt="1566261769541"></p><p>数字签名：就是在信息后面加上一段内容，这些内容证明信息没有被修改过。</p><p>HTTPS流程：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261778815.png" alt="1566261778815"></p><p>区别：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261789814.png" alt="1566261789814"></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>唯一标识一个进程：本地中使用PID；</p><p>网络中进程：IP地址+协议+端口号来唯一标识一个网络中的一个进程；</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261798658.png" alt="1566261798658"></p><p>socket通信流程</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261805698.png" alt="1566261805698"></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261813252.png" alt="1566261813252"></p><h3 id="题：如何设计一个数据库"><a href="#题：如何设计一个数据库" class="headerlink" title="题：如何设计一个数据库"></a>题：如何设计一个数据库</h3><p>开始设计</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261820297.png" alt="1566261820297"></p><p>数据库最主要的功能是存储数据，因此他有一个存储模块，将数据持久化存入磁盘中；</p><p>我们还需要组织并且用到这些数据，所以需要程序实例来映射出物理结构。</p><p>实际程序时要考虑：存储管理（尽量优化减少IO操作），缓存机制（优化访问），sql解析（操作数据库，优化可将sql放入缓存，编译好的sql可以直接用），日志管理（记录操作），权限划分，异常机制（容灾），<strong>索引管理</strong>（优化查询），<strong>锁管理</strong>（并发）</p><h3 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h3><p>为什么使用索引？</p><p>直接加在到内存中，进行全表扫描，很慢。使用索引避免全表查询，加速查询数据；</p><p>什么样的信息能够称为索引？</p><p>主键，唯一键，普通键，有一定区分性</p><p>主键：唯一标识表中的每一行数据，特点不能为空！！！不能重复！！！</p><blockquote><p><code>auto_increment</code>的字段必须是主键, 但是主键不一定是<code>auto_increment</code>的, 只要是唯一的就可以 一个表只能有一个主键, 但是主键可以是1个或多个字段组成</p></blockquote><p>唯一键：将表中的某个字段设置为不可重复值，可以将其设为唯一键！！！</p><blockquote><p>唯一键不是主键，但主键有不可重复性</p><p>一张表可以有多个唯一键，但只能有一个主键</p></blockquote><p>有了关键字索引还不行，还需要以某种数据结构将其组织起来才能够使检索更高效。</p><p>磁盘文件存储</p><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。</p><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>索引的数据结构？</p><p>二叉树：二分查找，缺点：每个节点只能存储两个节点，树的深度很深，IO的操作就会很多，效率就很差</p><p>B数：树的每个节点最多有m个孩子，就是m阶B树，下图3阶：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261830802.png" alt="1566261830802"></p><p>特性：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261842897.png" alt="1566261842897"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261850318.png" alt="1566261850318"></p><p>让每个索引块尽可能存储更多信息，让树的高度低，减少IO次数；</p><p>B+树：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261860507.png" alt="1566261860507"></p><p>结论：B+树更适合，原因：</p><p>B+树的磁盘读写代价更低，内部（非叶子节点）并没有指向关键字具体信息的指针，不存放数据只存放索引信息。</p><p>查询效率更稳定，每次查询都是根节点到叶子节点的路径，查询基本一样</p><p>只需要遍历叶子节点就可以完成对全部关键字的扫描，所以他更有利于对数据库的扫描。（更适合范围条件查询）</p><p>Hash索引了解一下：</p><p>缺点：</p><ul><li>比较进行hash运算之后的值，仅满足等值查询，不能使用范围查询；</li><li>无法运用索引值来排序</li><li>不能利用部分索引键查询</li><li>不能避免表扫描，哈希值可能重复，需要全表扫描</li><li>大量hash值相等时，效率很底。</li></ul><p>密集索引和稀疏索引</p><p>密集索引：叶子节点不仅保存了索引值，还保存了其同一行的其他列的数据。</p><blockquote><p>所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。在<code>InnoDB</code>存储引擎中，<code>聚簇索引</code>就是数据的存储方式</p></blockquote><p>稀疏索引：叶子节点仅保存了键位信息及其主键。</p><p>InnoDB的索引</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261871063.png" alt="1566261871063"></p><p>如何定位并优化慢查询sql？</p><ul><li><p>根据慢日志定位慢查询sql（较慢sql执行的记录）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262283010.png" alt="1566262283010"></p></li><li><p>使用explain等工具分析sql</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262067821.png" alt="1566262067821"></p><ul><li>一般放在select查询语句前，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数</li><li>字段：type表示MySQL找到数据行的方式，性能最优到最差如图，index/all表示是全表查询。</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261930304.png" alt="1566261930304"></p><ul><li>字段：extra，如图</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566261963108.png" alt="1566261963108"></p></li><li><p>修改sql或者尽量让sql走索引</p><ul><li>改用索引查</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262116465.png" alt="1566262116465"></p><ul><li>添加索引</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262137053.png" alt="1566262137053"></p></li><li><p>使用fore_index()测试那个索引更好</p></li></ul><p>联合索引的最左匹配原则的成因？</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262151740.png" alt="1566262151740"></p><p>MySQL创建复合索引的规则是首先会对最左边的也就是第一个字段进行排序，在第一个字段排序的基础上再对第二个字段排序，所以第一个字段是绝对有序的，第二个字段就是无序的了，因此通常情况下直接使用第二个字段进行条件判断是用不到索引的。这就是MySQL联合索引强调最左匹配的原因。</p><p>索引建立的越多越好吗？</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262159079.png" alt="1566262159079"></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>Myisam：表级锁，不支持行级锁</p><p>InnoDB：默认行级锁，支持表级锁，</p><blockquote><p>注：当SQL语句中使用索引作为条件时，使用的是行级索，当不用索引时，整张表会被锁住，使用的是表级锁，</p></blockquote><p>无论表锁还是行锁，默认都分为共享锁和排他锁</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566262385992.png" alt="1566262385992"></p><p>场景分析：</p><p>MyISAM</p><ul><li>适用频繁执行全表count语句；因为有一个变量值存储了该值</li><li>适用增删改不高，查询频繁；因为增删改会涉及锁表操作，会产生很多碎片，但是纯查询效率是可以的</li><li>适合没有事务的</li></ul><p>InnoDB</p><ul><li>适合数据增删改查都频繁；增删改时某些行被锁，避免了被阻塞，不像MyISAM每次锁住整张表</li><li>支持事务的系统</li></ul><p>数据库锁分类：</p><ul><li>按粒度划分：表级锁，行级锁，页级锁</li><li>按级别划分：共享锁，排他锁</li><li>按加锁方式：自动锁（意向锁，MyISAM表锁，以及增删改时的锁），显示锁</li><li>按操作划分：DML锁（数据操作），DDL锁（表结构变更）</li><li>按使用方式：乐观锁（认为数据处理过程不会发生冲突，提交更新时才会检测，实现方式是记录数据版本：版本号或者时间戳），悲观锁（全程使用排他锁）</li></ul><p>数据库事务的特性</p><p>ACID：原子性，一致性，隔离性，持久性</p><p>事务的隔离性以及各级别下的并发问题</p><p>更新丢失——MySQL所有事务隔离级别在数据库层面上均可避免</p><p>脏读——一个事务读到另一个事务未提交的更新数据，READ-UNCOMMITTED事务隔离级别不能解决，使用READ-COMMITTED（读提交）级别，隔离一个事物读取另一个事务未提交数据</p><p>不可重复读——一事务A多次读取数据，另一事务B在此期间修改数据，导致事务A多次读取数据不一致，使用REPEATABLE-READ（可重复读）级别可以避免。</p><p>幻读——事务A读取匹配条件的行数据，事务B以插入或删除的方式修改A的结果集，导致事务A产生差错。设置为SERIALIZABLE可以避免。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566263834174.png" alt="1566263834174"></p><p>InnoDB在可重复度隔离级别下是如何避免幻读？</p><p>表象：快照度（非阻塞读）——伪MVCC</p><p>内在：next-key锁（行锁+gap锁）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566264130165.png" alt="1566264130165"></p><p>当前读表示：读取的是记录的最新版本，并且读取后保证其他并发事务不能修改当前记录，对读取记录加锁。</p><p>快照读是基于提升并发性能的考虑，基于多版本并发控制（MVCC），他是行级锁的变动，但是他在很多情况下避免了加锁操作，开销更低，由于是基于多版本快照，所以读到的数据不是最新版本。</p><p>RC、RR级别下InnoDB的非阻塞读（快照读）如何实现？</p><ol><li>每行数据的额外字段，DB_TRX_ID（最近一次事务标识符），DB_ROLL_PTR（回滚指针段），DB_ROW_ID（行号，隐藏主键）</li><li>undo日志，当我们对记录做了变更操作时就会产生undo日志，其中存储的是老版数据</li></ol><p>例：数据（11，12，13）修改为（11，32，13）时，会发生：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566265001814.png" alt="1566265001814"></p><p>再次修改为（11，32，45）时会发生：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566264973315.png" alt="1566264973315"></p><ol start="3"><li>read view可见性判断，当使用快照读时，会创建一个read view，告知我们读的是哪一个版本，根据可见性算法，将DB_TRX_ID取出与系统其他活跃事务ID对比，如果大于或者等于，就取出undo log中的版本，直到取出小于活跃事务ID号（事务ID是递增状态，越新开启的事务，ID越大）</li></ol><p>因为<strong>生成时机</strong>？？？的不同造成RC,RR隔离级别的不同可见性，在RR级别下，事务在开启事务的第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来，此后在调用快照读时还是使用同一个read view；而在RC级别下，事务中每次调用快照读时都会创建一个新的快照，这就是为什么在RC下能够看到别的事务提交的对表记录的增删改。而在RR下，如果首次使用快照读是在别的事物对数据做出增删改并提交之前的，此后即便别的事物对数据进行增删改并提交还是读不到数据变动的原因。对RR来说，首次事务调用快照读的时机很重要。</p><p><strong>正是因为上面三个原因，使得InnoDB在RR、RC级别支持非阻塞读，而读取数据时的非阻塞就是MVCC，而InnoDB的非阻塞读实现了MVCC的仿照版；MVCC代表多版本并发控制，读不加锁，读写不冲突，在读多写少的应用中，读写不冲突很重要。这里仅实现伪MVCC机制是因为并没有实现核心的多版本并存，undo log中的内容是串行化的结果，记录了多个事务的过程，不属于多版本共存。</strong></p><p>next-key锁（行锁+gap锁）</p><ul><li>行锁：对单个行记录上锁，锁定一个记录上的索引，而不是记录本身。</li><li>gap锁：gap表示索引树中插入新纪录的空隙，gap锁即锁定一个范围但不包括记录本身，是为了方式同一事物的两次当前读出现幻读的情况</li></ul><p>在RR及以上级别默认都支持gap锁，RC及以下级别都没有gap锁。</p><p>RR级别下gap锁的使用场景，对主键索引或唯一索引会使用gap锁吗？</p><ul><li>如果where条件全部命中，就不会用gap锁，只会加记录锁（行锁）</li><li>如果where条件部分命中或者未命中，就会加上gap锁</li></ul><p>gap锁会出现在非唯一索引或者不走索引的当前读中</p><p>非唯一索引：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566268250911.png" alt="1566268250911"></p><p>gap会在（6，9]，（9，11] 这两个区间加上gap锁，防止幻读。</p><p>不走索引</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566268427287.png" alt="1566268427287"></p><p>会对所有gap上锁，类似表锁，也能防止幻读。</p><p>InnoDB在RR级别主要通过引入next-key锁来避免幻读问题，next-key由行锁和gap锁，gap锁会用在非唯一索引或者不走索引的当前读以及仅命中检索条件的部分结果集并且用到主键索引以及唯一索引的当前读中。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="linux体系结构"><a href="#linux体系结构" class="headerlink" title="linux体系结构"></a>linux体系结构</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528183180.png" alt="1566528183180"></p><p>在Linux系统启动时候首先会启动内核，内核程序直接管理硬件，包括CPU、内存空间、硬盘接口、网络接口等。所有的计算机操作都要通过内核传递给硬件设备。用户态及上层应用程序的活动空间、应用程序的执行必须依托于内核提供的资源，包括cpu资源、存储资源、IO资源等，为了使上层应用能够访问这些资源，内核必须为这些上层应用提供访问的接口，即系统调用；可以将其视为一种不能再简化的操作，一个操作系统上的功能可以看作是系统调用的组合结果。公用函数库是对系统调用的组合。</p><p>shell：是一个特殊的应用程序，本质是一个命令解释器。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>查找文件</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528347788.png" alt="1566528347788"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528549046.png" alt="1566528549046"></p><p>文本检索、</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528593466.png" alt="1566528593466"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528850938.png" alt="1566528850938"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528627788.png" alt="1566528627788"></p><p>文件内容的统计</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528687004.png" alt="1566528687004"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528703425.png" alt="1566528703425"></p><p>替换文本内容</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528735871.png" alt="1566528735871"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566528789476.png" alt="1566528789476"></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Mysql数据库也有缓存，但是是针对查询内容，一般只有表中的数据没有变动的时候，缓存才有作用，这并不能减轻业务系统对数据库的I/O压力，因此缓存数据库应运而生。</p><p>缓存数据库：实现对热点数据的高速缓存，提高响应速度，缓解后端数据库的压力。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566269898991.png" alt="1566269898991"></p><blockquote><p>熔断：存储层挂了，直接访问缓存层。</p><p>穿透：未在缓存中换取数据，直接访问存储层</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566270011709.png" alt="1566270011709"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566270041007.png" alt="1566270041007"></p><p>为什么Redis这么快？</p><ul><li>完全基于内存操作，绝大多数请求是纯内存操作，执行效率高；</li><li>数据结构简单，操作也就简单；</li><li>使用单线程，是指主线程是单线程的，这里主线程包括I/O事件处理、过期键处理、复制协调、集群协调，这些处理IO事件的逻辑会被封装成周期性的任务由主线程周期性处理。单线程设计，对于客户端的所有读写请求，都由一个主线程串行处理，因此多个客户端同时对一个键进行写操作时候就不会有并发的问题，避免频繁的上下文切换、锁竞争问题；</li><li>redis单线也可以处理高并发请求，并发性IO流指让一个计算单元处理来自多个客户端的流请求，redis使用单线程配合上IO多路复用可大幅度提升性能，这里的单线程是指处理网络请求只有一个单线程来处理；一个正式的redis servlet肯定是不止一个进程的。</li><li>多路I/O复用模型，即非阻塞I/O；redis是单线程的，所有的操作是按照顺序线性执行的，但是由于读写操作，等待用户输入或者输出都是阻塞的，所以IO操作往往不能直接返回就会导致某一文件的IO阻塞，进而进程无法对其他客户端提供服务；IO多路复用就是解决这个问题！</li></ul><blockquote><p>FD：一个打开文件通过唯一的描述符进行引用。</p></blockquote><p>传统的IO阻塞模型，当进行读写操作时，不可读或者不可写时，整个redis就不会对其它操作进行响应，导致整个服务不可用。</p><p>IO多路复用调用，这其中最重要的函数调用就是select系统调用，select能够同时监控多个文件描述符的可读可写情况，当文件描述符可读可写时就会返回响应的参数，即将监听文件读写情况的任务交给select，程序就可以继续做别的而不被堵塞</p><p>基于react设计模式来实现文件事件处理器，文件事件处理器使用IO多路复用模块同时监听多个FD，当发生文件读写函数（read、write、close等）事件时，文件事件处理器就会回调FD绑定的事件处理器，虽然文件事件处理器是在单线程上，但是通过IO多路复用，实现同时对多个FD读写的监控，提高了网络通信模型的性能。</p><p>同时也有其他的IO多路复用函数：</p><ul><li>evport：Linux</li><li>kqueue：MAC OS</li><li>select：都兼容，作为保底函数，O(n)</li></ul><h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><p>String类型：最基本的，二进制安全（即可以包含任何数据），常用的key-value键值对，最大可存储512M，底层由简单动态字符串实现。</p><blockquote><p>案例：记录一个用户每天访问这个网站的次数，只需要拼接用户id和代表当前时间的字符串作为key，每次用户访问时对这个页面时，对这个字符执行incr命令即可，就可以统计用户当天访问站点的次数。</p></blockquote><p>Hash：String元素组成的，适合存储对象</p><p>List：按照String插入元素顺序排序，类似于栈的，使用可以用于最新消息，排行榜</p><p>Set：String类组成的无序集合，通过hash表实现，不允许重复，使用于共同关注，共同喜好值之类的交并集操作</p><p>Sorted Set：通过分数(double类型的)来为集合中的成员进行从小到大的排序，不重复</p><p>例题：从海量key中查询某一固定前缀的Key？</p><ol><li>数据规模大小</li><li>误区：用keys pattern扫描出符合条件的key列表，问题在于当redis正在执行服务时会发生什么？当key的数量过大时会发生内存消耗过大而卡顿</li><li>正确：使用SCAN cursor指令，每次只会返回少量元素；基于游标的迭代器，基于上一次的游标延续之前的迭代过程</li></ol><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566517280989.png" alt="1566517280989"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566517363631.png" alt="1566517363631"></p><p>如何通过Redis实现分布式锁？</p><p>分布式锁是控制分布式系统或不同系统之间共同访问共同资源的一种锁的实现。如果不同系统或者同一系统不同主机间共享了某个资源时，往往需要互斥来防止彼此干扰，进而保证一致性。分布式锁需要解决的问题有：</p><ul><li>互斥性：任意时刻，只能有一个客户端获取锁；</li><li>安全性：锁只能由获取该锁的客户端删除，不能由其他客户端删除</li><li>死锁：避免获取锁的客户端因为宕机而未能释放锁</li><li>容错：当部分节点（例如redis）宕机时，客户端仍能正常获取锁，释放锁</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566518008463.png" alt="1566518008463"></p><p>SETNX的原子操作和保持不变，可以用来实现分布式锁。在执行一段程序时，可以先尝试对某个key设值，如果设值成功则表示当时没有别的线程在执行该段代码或者说占用该独占资源。这里需要解决的就是key值的时间问题，因为SETNX设置完该值就存在了。</p><p>解决key值得时效问题：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566518578527.png" alt="1566518578527"></p><p>缺点的原子性在于：如果一个线程只执行到setnx语句后就挂了，那么设置的key值将会一直存在，其他线程就无法访问后面的资源。两个原子操作（setnx和expire）组合成一个逻辑，就变得不是原子操作了。</p><p>正确操作：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566518903284.png" alt="1566518903284"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566518969999.png" alt="1566518969999"></p><p>如果有大量key同时过期得注意事项?</p><ol><li>集中过期时处理key会很耗时，出现卡顿现象</li><li>解决：在设置key过期时间时，加上随机值</li></ol><p>如何使用Redis做异步队列？</p><p>使用List作为队列，RPUSH生产消息，LPOP消费消息。</p><ul><li>缺点：在于没有等待队列中有值（消息）时就直接消费，</li><li>处理：可以通过应用层引入Sleep机制去调用LPOP重试。</li></ul><p>加上无消息时阻塞方式</p><ul><li>缺点：生产得消息只能供一个消费者使用，用完就没了</li><li>改进：使用主题订阅者模式</li></ul><p>pub/sub主题订阅者模式</p><ul><li>发送者pub发送消息，订阅者sub接收消息</li><li>订阅者可以订阅任意数量得频道</li><li>缺点：消息得发布是无状态的，无法保证可达，对发布者来说消息是即发即失的，如果消息发送时一个订阅者下线了，重新上线时，消息是不会重新收到的，要解决这个问题需要使用专业的消息队列，例如kafuka等。</li></ul><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>RDB（快照）持久化：即保存某个时间点的全量数据快照；</p><ul><li>创建方式：save，使用主线程执行快照，该方法会阻塞redis的服务器进程（阻塞客户端请求操作），直到快照文件被创建完毕（很少用）</li><li>bgsave，会fork出一个子进程来创建rdb文件，不会阻塞服务器进程，父进程通过轮询接受子进程完成的信号</li><li>其他自动化出发RDB持久化</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566520939557.png" alt="1566520939557"></p><p>BGSAVE底层实现方式：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566521057383.png" alt="1566521057383"></p><ol><li>查询子进程是否有冲突</li><li>系统调用fork()函数：创建进程，实现copy-on-write（写时复制），传统方式下fork在创建子进程时会将资源全部复制给子进程，简单但是效率低。Linux环境下该进fork方式，当父进程创建子进程时，内核只为子进程创建虚拟空间，父子进程使用的是相同的物理空间，只有父子进程发生更改时，才会为子进程分配独立的物理空间</li></ol><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566521457362.png" alt="1566521457362"></p><p>优点在于：如果调用者没有修改资源，则不会发生复制操作，因此多个调用者只是读取操作时可以共享资源。COW调用时会维持一个为读操作请求的指针，并在读完后更新这个指针，以提升读写并发能力。因此COW也提供了数据更新过程中的原子性，提升了读写效率。当redis执行持久化时，redis会fork一个子进程，子进程将数据持久化到一个临时的RDB文件中，当完成写操作后，将原来的rdb替换掉，这样做的好处就是可以实现COW操作。</p><p>持久化时，子父进程都存在，父进程继续处理客户端请求，子进程负责将内存内容写入临时文件中，由于OS的COW操作，父子进程会共享相同的物理页面，当父进程处理写请求的时候，OS会为父进程调修改的页面创建副本，而不是写共享的页面，所以子进程的地址空间内的数据是fork时刻的整个数据库的快照，子进程完成写操作时，只要替代原快照，然后退出，这样就完成一次备份操作。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566522571316.png" alt="1566522571316"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566522633940.png" alt="1566522633940"></p><p>使用日志重写解决aof文件不断增大的问题</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524281028.png" alt="1566524281028"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524319355.png" alt="1566524319355"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524383680.png" alt="1566524383680"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524408719.png" alt="1566524408719"></p><p>子进程在做aof重写时，会通过管道从父进程读取增量数据，并缓存下来；在以rdb格式做全量持久时，也会从管道读取数据，同时不会造成管道阻塞，也就是aof文件前半段是rdb格式的全量数据，后半段是redis命令格式的增量数据。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524467090.png" alt="1566524467090"></p><p>redis实例重启时会使用bgsave持久化文件重新构建内容，再使用aof重放近期的操作指令，使用两者结合恢复重启之前的状态。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566524719291.png" alt="1566524719291"></p><p>如果同时需要执行大量命令，就需要等待上一条命令应答完成，这中间会有大量来回交互的时间和IO磁盘操作，为了提升效率，使用Pipeline可允许客户端一次发送多条命令，而不需要上一条命令的结果，客户端首先将命令写入缓存中，再一次性发送给redis，这样pipeline可以将多次io往返是的时间缩减为一次。（注：这里的命令指无相关性的命令）</p><h3 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h3><p>主从同步原理</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566525604430.png" alt="1566525604430"></p><ul><li>一个M：写；</li><li>若干个S：读；定期的数据备份也是在其中选择一个实例完成。</li></ul><p>这里不需要M，S的实时一致性，而是保持一种弱一致性，即一段时间后的最终一致性</p><p>同步操作：主节点做一次BGSAVE，并同时将后续修改操作记录在内存的缓存中，待完成后将RDB文件全量同步到从节点，从节点接收后，就将RDB镜像加载到内存中，加载完成后，再通知主节点将期间的修改操作记录即增量操作同步到从节点进行重放，就完成了同步过程。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566526103267.png" alt="1566526103267"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566526205097.png" alt="1566526205097"></p><p>Redis哨兵</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566526286410.png" alt="1566526286410"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566526378478.png" alt="1566526378478"></p><h3 id="Redis的集群管理"><a href="#Redis的集群管理" class="headerlink" title="Redis的集群管理"></a>Redis的集群管理</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566526471318.png" alt="1566526471318"></p><p>这样就实现了数据分片，通过数据分片，实现单节点服务器的压力。Redis集群才用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其它节点连接，使用Gossip协议传播信息和发现新的节点。redis节点的目的是将不同的key分散放在不同的节点，通常是获取key的hash值，但是节点动态增减时会有问题。</p><p>Redis采用的是一致性哈希算法。使用哈希环，先在环上确定节点位置，存储数据时同样计算key哈希值在环上位置，顺时针寻找离key最近的节点存储数据。</p><blockquote><p>一致性哈希在节点个数过少时也有个数据倾斜的问题，解决方式是引入虚拟节点，一个节点计算多个哈希值放在环中。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566270540934.png" alt="1566270540934"></p><h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566270931694.png" alt="1566270931694"></p><p>编译生成字节码，字节码保存在.class文件中，.class文件在各种JVM中运行。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566270966871.png" alt="1566270966871"></p><p>为什么JVM不直接将源码解析成机器码去执行？</p><p>因为每次执行都需要各种检查（java语法句法的检查），都要重新编译一次，在程序整体的性能就很受影响。所以引入中间字节码。</p><h3 id="JVM如何加载-class文件"><a href="#JVM如何加载-class文件" class="headerlink" title="JVM如何加载.class文件"></a>JVM如何加载.class文件</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566530314661.png" alt="1566530314661"></p><p>Class.forName()函数返回与给定的字符串名称相关的类或者接口的class对象。（返回一个给定类或者接口的一个 Class 对象）</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566271359683.png" alt="1566271359683"></p><p>一句话：反射就是将Java中的各种成分映射成一个个对象（下面代码中的Class，Method），然后获取。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566538204663.png" alt="1566538204663"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566271649284.png" alt="1566271649284"></p><ol><li>Clas.forName(类全路径)的方式获取类对象：rc</li><li>创建这个实例：r</li><li>获取throwHello这个方法getHello，使用Method这个对象，getDeclareMethod()能返回共有或者私有的方法，不能获取继承的方法</li><li>调用这个方法，invoke(对象实例，参数)</li><li>使用getMethod()可以调用公有方法，还能获取继承和接口实现的方法</li></ol><p><strong>Java类从编译到执行的过程</strong></p><p>由上面的反射发现：之所以能获取类的属性或者方法并对其调用，必须要获取class对象，要获取该类的class对象，必须要获取该类的字节码文件对象。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566539503027.png" alt="1566539503027"></p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566539550619.png" alt="1566539550619"></p><ul><li>抽象类</li><li>提供类加载方式的接口</li><li>loadClass()：通过给定一个类名去加载这个类，返回代表这类的class的实例，发现其中有很多Classloader类</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566539925530.png" alt="1566539925530"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566539976907.png" alt="1566539976907"></p><p>AppClassLoader会去java.class.path路径中去找编译好的class文件：ReflectSample.calss、Robot.class，执行时就会加载这两个文件。</p><h3 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h3><p>不同的ClassLoader加载类的方式和路径各不相同，为了明确分工，加载类的时候，各类ClassLoader按照自己管理的区域各司其职，需要一个机制管理，这就是双亲委派机制。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566540879924.png" alt="1566540879924"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566541051079.png" alt="1566541051079"></p><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566541089646.png" alt="1566541089646"></p><p>隐示加载方法不需要使用newInstance()方法获取实例，并且支持带参数的构造器（可以使用构造函数传入参数）生成对象实例</p><p>显示加载的方式获取类对象后，需要使用newInstance()方法获取对象实例，不支持传入参数，需要通过反射，调用构造器的newInstance()方法，才能使用参数？？？？？？</p><p>都能在运行时对任意一个类，知道该类的所有属性和方法，队友任意一个对象，能调用他的任意方法和属性。</p><p><strong>Java类的装载过程：</strong></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566541766165.png" alt="1566541766165"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566541877658.png" alt="1566541877658"></p><p>SpringIOC资源加载器在获取要读取的资源时，即读取spring Bean的配置文件时，如果是以classpath的方式加载，就需要使用classloader方式加载，这样做是和SpringIOC的延时加载有关，目的是为了加快初始化速度，不执行加载中链接、初始化步骤，加快加载速度，把这些工作留到实际使用时再去做。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566542351974.png" alt="1566542351974"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566542443473.png" alt="1566542443473"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566542526507.png" alt="1566542526507"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566542550343.png" alt="1566542550343"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566542572034.png" alt="1566542572034"></p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>标准：没有被其他对象引用；</p><h3 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566280952080.png" alt="1566280952080"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566280970515.png" alt="1566280970515"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281027327.png" alt="1566281027327"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281116146.png" alt="1566281116146"></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281167400.png" alt="1566281167400"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281260890.png" alt="1566281260890"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281297740.png" alt="1566281297740"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281358412.png" alt="1566281358412"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281417461.png" alt="1566281417461"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281459812.png" alt="1566281459812"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281495964.png" alt="1566281495964"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281533807.png" alt="1566281533807"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281682294.png" alt="1566281682294"></p><p>新生代：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566281754772.png" alt="1566281754772"></p><p>每次使用一块Eden和一块survivor，进行垃圾回收时，将这两个中存活的对象一次性复制到另一个survivor。复制一次，对象年龄加 1 ，当年龄达到15（默认的）岁时，就会进入老年代。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282162342.png" alt="1566282162342"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282206402.png" alt="1566282206402"></p><p>老年代：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282262255.png" alt="1566282262255"></p><p>当发生老年代的GC时，通常也会伴随着年轻代的GC，对整个堆进行垃圾回收，Full GC。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282462012.png" alt="1566282462012"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282604274.png" alt="1566282604274"></p><blockquote><p>调用了System.gc()只是告诉虚拟机要回收，但究竟什么时候回收由虚拟机说了算。</p></blockquote><p>永久代时jdk7及以下才有的，8使用元空间代替了，一个原因就是降低Full GC的频率，减小GC的负担。</p><p>GC发生时：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282779359.png" alt="1566282779359"></p><p>GC安全点，GC开始前，让程序“停在某个地方”</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566282872797.png" alt="1566282872797"></p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283101929.png" alt="1566283101929"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283143252.png" alt="1566283143252"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283216314.png" alt="1566283216314"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283265976.png" alt="1566283265976"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283314476.png" alt="1566283314476"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283430988.png" alt="1566283430988"></p><p>CMS使GC线程和用户线程并发</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283521787.png" alt="1566283521787"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566283567047.png" alt="1566283567047"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566284005512.png" alt="1566284005512"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566284156542.png" alt="1566284156542"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566284237462.png" alt="1566284237462"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566284288209.png" alt="1566284288209"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566284328030.png" alt="1566284328030"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>串行→批处理（程序）→进程→线程</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566346496101.png" alt="1566346496101"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566634603893.png" alt="1566634603893"></p><p>进程拥有一个完整的虚拟内存地址空间，当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。线程只有相关堆栈寄存器、程序计数器和线程控制表TCB组成，寄存器可用来存储局部标量，但不能存储其他线程的相关变量。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566634628484.png" alt="1566634628484"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566346516168.png" alt="1566346516168"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566634813194.png" alt="1566634813194"></p><ul><li>每一个JVM实例唯一对应一个堆，每个线程有唯一私有的栈。</li><li>一个程序是一个可执行文件，一个进程是一个执行中程序的实例。</li></ul><h3 id="Java线程中start和run的区别？"><a href="#Java线程中start和run的区别？" class="headerlink" title="Java线程中start和run的区别？"></a>Java线程中start和run的区别？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    syso.(<span class="string">"current Thread is :"</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            attack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    syso.(<span class="string">"current main thread is :"</span> + Thread.currentThread().getName());</span><br><span class="line">    t.run();<span class="comment">//两个打印执行结果都是main线程</span></span><br><span class="line">    t.start();<span class="comment">//结果为：主线程main；和另一个线程Thread-0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start</code>方法源码调用的是一个native的方法<code>start0</code>，<code>start0</code>方法调用的是JVM的<code>JVM_StarThread</code>方法。该层源码中的关键语句是：<code>native_thread = new JavaThread(&amp;thread_entry, sz)</code></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739211692.png" alt="1566739211692"></p><p>即start方法会调用JVM_StartThread方法去创建已给新的线程，并通过Thread#run()方法去调用方法；</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739228427.png" alt="1566739228427"></p><h3 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a>Thread和Runnable</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739241431.png" alt="1566739241431"></p><p>如何给run()方法传参</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739254477.png" alt="1566739254477"></p><h3 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h3><p>主线程等待方法；</p><p>使用Thread类的join()方法阻塞当前线程以等待子线程处理；</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739268790.png" alt="1566739268790"></p><p>通过Callable接口实现：通过Future Or 线程池获取</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739287783.png" alt="1566739287783"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739300563.png" alt="1566739300563"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739313007.png" alt="1566739313007"></p><h3 id="Sleep和Wait方法"><a href="#Sleep和Wait方法" class="headerlink" title="Sleep和Wait方法"></a>Sleep和Wait方法</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739324885.png" alt="1566739324885"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739335235.png" alt="1566739335235"></p><blockquote><p>wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p><p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p><p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p><p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p><p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。  </p></blockquote><p>锁池</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739344235.png" alt="1566739344235"></p><p>等待池</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739353388.png" alt="1566739353388"></p><h3 id="notify和notifyAll"><a href="#notify和notifyAll" class="headerlink" title="notify和notifyAll"></a>notify和notifyAll</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739364448.png" alt="1566739364448"></p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566739786416.png" alt="1566739786416"></p><p>当前线程A的暗示调度器让出CPU给线程B，但是调度器可以选择忽视或者执行。</p><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>stop()方法，已抛弃，问题包括突然停止不好清理线程，会释放锁，造成数据不一致等。</p><p>当前方法：interrupt()方法，通知线程应该中断，</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566740196347.png" alt="1566740196347"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566740234431.png" alt="1566740234431"></p><p><a href="https://www.bilibili.com/video/av62633602?p=74" target="_blank" rel="noopener">详细解释</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566740538242.png" alt="1566740538242"></p><h3 id="同步和互斥的区别："><a href="#同步和互斥的区别：" class="headerlink" title="同步和互斥的区别："></a>同步和互斥的区别：</h3><p>各个线程可以访问进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括</p><p>1、间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步</p><p>所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p><p>2、直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系</p><p>所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上(大多数情况)，通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p><h3 id="进程间的通信方式："><a href="#进程间的通信方式：" class="headerlink" title="进程间的通信方式："></a>进程间的通信方式：</h3><p>1.管道(pipe)及有名管道(named pipe)：</p><blockquote><p>管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p></blockquote><p>2.信号(signal)：</p><blockquote><p>信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></blockquote><p>3.消息队列(message queue)：</p><blockquote><p>消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p></blockquote><p>4.共享内存(shared memory)：</p><blockquote><p>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p></blockquote><p>5.信号量(semaphore)：</p><blockquote><p>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p></blockquote><p>6.套接字(socket)；</p><blockquote><p>这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p></blockquote><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>使用全局变量</p><blockquote><p>主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile（易变的）</p></blockquote><p>使用消息实现通信</p><blockquote><p>在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。<br>1)定义消息#define WM_THREAD_SENDMSG=WM_USER+20;<br>2)添加消息函数声明afx_msg int OnTSendmsg();<br>3)添加消息映射ON_MESSAGE(WM_THREAD_SENDMSG,OnTSM)<br>4)添加OnTSM()的实现函数；<br>5)在线程函数中添加PostMessage消息Post函数</p></blockquote><p>使用事件CEvent类实现线程间通信</p><blockquote><p>Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。<br>1)创建一个CEvent类的对象：CEvent threadStart;它默认处在未通信状态；<br>2)threadStart.SetEvent();使其处于通信状态；<br>3)调用WaitForSingleObject()来监视CEvent对象</p></blockquote><h3 id="线程间的同步方式有四种"><a href="#线程间的同步方式有四种" class="headerlink" title="线程间的同步方式有四种"></a>线程间的同步方式有四种</h3><p>临界区</p><blockquote><p>临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。<br>PS:关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）</p></blockquote><p>互斥量</p><blockquote><p>互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。<br>PS:1、互斥量由于也有线程所有权的概念，故也只能进行线程间的资源互斥访问，不能由于线程同步；<br>2、由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了”遗弃”问题</p></blockquote><p>信号量</p><blockquote><p>信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作<br>PS:事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信</p></blockquote><p>事件</p><blockquote><p>事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。<br>PS:事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题</p></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566740782536.png" alt="1566740782536"></p><p>这时要引入互斥锁，目的是互斥访问，特性如下：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566740966586.png" alt="1566740966586"></p><p>关键字synchronized可以满足上述特性。根据获取的锁的分类：获取对象锁和获取类锁！！！</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566741172390.png" alt="1566741172390"></p><p>2表示使用synchronized修饰的方法（method）<a href="https://www.bilibili.com/video/av62633602?p=77" target="_blank" rel="noopener">代码解释</a></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566741606620.png" alt="1566741606620"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566741663767.png" alt="1566741663767"></p><h3 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h3><p>两个要点：</p><ul><li>Java对象头</li><li>Monitor</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566741979672.png" alt="1566741979672"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566742014520.png" alt="1566742014520"></p><blockquote><p>轻量级锁和偏向锁是1.6后对锁的优化。</p></blockquote><p>Monitor相当于Java对象天生自带的一把看不见的锁（或称监视器锁，一种同步机制或同步对象）</p><p>重量级锁指针指向的就是Monitor对象的起始地址（每个对象都有一个Monitor对象与之关联）；Monitor对象中的关键属性如下：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566742496980.png" alt="1566742496980"></p><p>Monitor对象存在于每个Java对象的对象头中，</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566742578548.png" alt="1566742578548"></p><p>查看编译后的指令，monitorenter进入同步块，monitorexit表示退出，两者配对表示monitor锁。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566742741353.png" alt="1566742741353"></p><p>锁的重入：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566742914574.png" alt="1566742914574"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566743138977.png" alt="1566743138977"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566743185944.png" alt="1566743185944"></p><h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><ul><li>自旋锁</li><li>线程A想要获取线程B占有的资源，就让线程A执行时等一会但是不放弃CPU的时间</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566743670713.png" alt="1566743670713"></p><ul><li>自适应自旋锁</li><li>应该是自旋等待时间的变化</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566743820035.png" alt="1566743820035"></p><ul><li>锁消除</li><li>编译时对运行上下文进行扫描，去除不可能存在竞争的锁</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744166712.png" alt="1566744166712"></p><ul><li>锁粗化</li><li>通过扩大锁的范围，避免反复加锁和解锁</li></ul><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744269477.png" alt="1566744269477"></p><p>synchronized锁的四种状态</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744363854.png" alt="1566744363854"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744495783.png" alt="1566744495783"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744516440.png" alt="1566744516440"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744545011.png" alt="1566744545011"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744573288.png" alt="1566744573288"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744597530.png" alt="1566744597530"></p><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744650852.png" alt="1566744650852"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744677379.png" alt="1566744677379"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566774525373.png" alt="1566774525373"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566774615642.png" alt="1566774615642"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566774835528.png" alt="1566774835528"></p><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744755180.png" alt="1566744755180"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744772543.png" alt="1566744772543"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744787208.png" alt="1566744787208"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744807706.png" alt="1566744807706"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744833721.png" alt="1566744833721"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744849777.png" alt="1566744849777"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744873786.png" alt="1566744873786"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744897082.png" alt="1566744897082"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744927952.png" alt="1566744927952"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566744957721.png" alt="1566744957721"></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566745004318.png" alt="1566745004318"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566775040568.png" alt="1566775040568"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566775257695.png" alt="1566775257695"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566775322604.png" alt="1566775322604"></p><h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><p>在web开发中，服务器要接受并处理请求，所以会为一个请求分配一个线程来处理，如果并发的请求比较多，则耗费在线程创建和回收大量时间，使用线程池来重复利用线程</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566775915639.png" alt="1566775915639"></p><blockquote><p>3中会保证顺序执行各个任务，在任意给定线程不会有多个线程执行；8是Java8加入的</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566776250404.png" alt="1566776250404"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566776478492.png" alt="1566776478492"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566776441213.png" alt="1566776441213"></p><blockquote><p>是一个根据一组执行策略调度，调用、执行和控制的异步任务的框架，目的是提供一种将任务提交和任务融合运行分离开的机制。</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566776736541.png" alt="1566776736541"></p><p>线程池设计</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566776835646.png" alt="1566776835646"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777028608.png" alt="1566777028608"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777063200.png" alt="1566777063200"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777089962.png" alt="1566777089962"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777290218.png" alt="1566777290218"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777307025.png" alt="1566777307025"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777325088.png" alt="1566777325088"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777405991.png" alt="1566777405991"></p><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566286012980.png" alt="1566286012980"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566286247944.png" alt="1566286247944"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566286283521.png" alt="1566286283521"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566286308847.png" alt="1566286308847"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566286637054.png" alt="1566286637054"></p><p>finally是先于return执行的。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566287202869.png" alt="1566287202869"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566287412849.png" alt="1566287412849"></p><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566287490549.png" alt="1566287490549"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566287502906.png" alt="1566287502906"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566288132427.png" alt="1566288132427"></p><h3 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1568710462272.png" alt="1568710462272"></p><h3 id="Map家族"><a href="#Map家族" class="headerlink" title="Map家族"></a>Map家族</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1568706469430.png" alt="1568706469430"></p><h3 id="选用"><a href="#选用" class="headerlink" title="选用"></a>选用</h3><p>主要根据集合的特点来选用，比如我们<strong>需要根据键值获取到元素值时</strong>就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap。</p><p>当我们<strong>只需要存放元素值时</strong>，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>的底层是HashMap实现的，是将元素以键的形式存入HashMap的Key中，而他的值Value是一个final类型的PRESENT对象</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>实现了排序；底层也是HashMap实现</p><p>第一种是基于元素对象自身实现comparable接口的<strong>自然排序</strong></p><blockquote><p>即让一个元素对象A实现Comparable接口，就要重写<code>equals()；compareTo()自然排序；hashCode()；</code>三个方法，为了能够让对象A在加入TreeSet后能正确排序，其中equals和compareTo()的方法就要按相同的规则比较两个对象是否相等。一旦equals()方法重写，就要重写hashCode()，即在使用equals方法比较两个对象相同时，也要保证两个对象的hashCode值也相等。</p><p>其主要的方法就是compareTo()方法。</p></blockquote><p>另一种是基于不与单元元素绑定的Comparator接口的排序，即<strong>客户化排序</strong></p><blockquote><p>首先对象A还是实现Comparable接口，但不需要在A中改变compareTo()方法，只需要在外部类AComparator实现Comparator<A>，实现其中的compare()方法（该方法中设计一个比较方式即可）。此时A类即实现了Comparable接口，在外部又实现了Comparator，在存入Set集合中时，会优先以compare()方法中的比较规则为准。TreeSet集合中也是如此。</A></p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566288990431.png" alt="1566288990431"></p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Key-Value的形式存储数据，其中的key是不可重复的，使用Set来保存的，有去重功能，value是通过Collection。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567167431023.png" alt="1567167431023"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567167408933.png" alt="1567167408933"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566289552062.png" alt="1566289552062"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566289709492.png" alt="1566289709492"></p><p>混合高低位计算hash值，使之分布散列均匀。用位与操作替代取模。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566290019896.png" alt="1566290019896"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567171193672.png" alt="1567171193672"></p><p>1.8之前会发生扩容死锁问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">// 这行也是重点</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 重点这三行</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567176014673.png" alt="1567176014673"></p><blockquote><p>此时有两个线程T1、T2同时插入a4，则T1、T2同时进行扩容操作，它们各自新建了一个Entry数组newTable。</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567175751529.png" alt="1567175751529"></p><blockquote><p>T2线程执行到transfer方法的Entry&lt;K,V&gt; next = e.next;时被挂起，T1线程执行transfer方法后Entry数组如下图：</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567175785376.png" alt="1567175785376"></p><blockquote><p>在T1线程没返回新建Entry数组之前，T2线程恢复，因为在T2挂起时，变量e指向的是a1，变量next指向的是a2，所以在T2恢复执行完transfer之后，Entry数组如下图：</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567175825876.png" alt="1567175825876"></p><blockquote><p>可以看到在T2执行完transfer方法后，a1元素和a2元素形成了循环引用，此时无论将T1的Entry数组还是T2的Entry数组返回作为扩容后的新数组，都会存在这个环形链表，当调用get方法获取该位置的元素时就会发生死循环</p></blockquote><p>1.8之后就解决了这个问题，因为没有再使用指针引用的方式去传值，而是重新计算在新数组上的hash序列号，移动值到新HashMap上。</p><p>没解决的问题就是<strong>多线程安全问题</strong>：</p><p>如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位置还没有其他的数据。所以这两个线程都会进入插值处的代码中。假设一种情况：</p><ul><li>线程A通过if判断，该位置没有哈希冲突，进入了if语句，还没有进行数据插入，这时候 CPU 就把资源让给了线程B，线程A停在了if语句里面，</li><li>线程B判断该位置没有哈希冲突（线程A的数据还没插入），也进入了if语句，线程B执行完后，轮到线程A执 行，现在线程A直接在该位置插入而不用再判断。</li><li>这时候，你会发现线程A把线程B插入的数据给覆盖了，发生了线程不安全情况。</li></ul><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>哈希表（HashTable）又叫做散列表，是根据关键码值（即键值对）而直接访问的数据结构。也就是说，它通过把关键码映射到表中一个位置来访问记录，以加快查找速度。</p><ul><li>特点一：线程安全；</li><li>特点二：K/V都不允许为null；</li></ul><blockquote><p>使用<strong>哈希函数</strong>将被查找的键转化为数组的索引。</p></blockquote><p>处理冲突的方法很多，有<strong>拉链法</strong>和<strong>线性探索法</strong>。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567177495680.png" alt="1567177495680"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567177516502.png" alt="1567177516502"></p><blockquote><p>注：线程安全，使用synchronized关键字修饰关键方法</p></blockquote><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>锁细粒度化：将数组拆分成子数组，16位为一段，加上一把锁。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566290353254.png" alt="1566290353254"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p>更细化：<strong>Node + CAS + Synchronized</strong></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566290416620.png" alt="1566290416620"></p><p>sync只锁定当前链表或者红黑树的首结点，将锁细粒化到表中每个元素，只要hash不冲突就不会发生并发。不允许插入null键，对数组元素的更新是使用CAS，需要不断地的失败重试。</p><p>容量控制参数：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567214818968.png" alt="1567214818968"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566290826092.png" alt="1566290826092"></p><p>（2）图示：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1568773675821.png" alt="1568773675821"></p><p>（4）表示发生哈希碰撞，则会锁住链表或二叉树头节点即数组元素；</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566290892669.png" alt="1566290892669"></p><blockquote><p>只要哈希不冲突就不会出现并发获得锁的情况！</p><ol><li>首先用CAS无锁操作插入头节点，如果插入失败，则表示有别的线程已经插入头节点了，需要循环重试；</li><li>如果头节点已经存在，就尝试获取头节点的synchronized锁，再进行操作</li></ol></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291042885.png" alt="1566291042885"></p><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566777522291.png" alt="1566777522291"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291118596.png" alt="1566291118596"></p><blockquote><p>P91集20秒处</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291155664.png" alt="1566291155664"></p><blockquote><p>executor：线程执行器，一个任务执行和调度的框架；tools下还有和executor相关的executors类，用来创建executorServices等对象；</p><p>locks：Java5后增加协调共享对象的访问方法，显示锁，方便对线程之间的共享资源做更细粒度的锁控制，一个lock可以创建多个Condition，用于将线程的等待和唤醒对象化，基于AQS实现，底层是调用Locksupport.unpark/park()实现线程的阻塞和唤醒。另一个是可重入读写锁，读读可共存，读写不可同时；</p><p>atomic：原子操作类，一个操作是不可中断的（即使是多线程环境中）。4中原子更新方式：原子更新基本类型、原子更新数组、原子更新引用、原子更新字段。atomic使用的是CAS的更新方式，当某个线程在执行atomic方法时，不会被其他线程打断，别的线程就会像自旋锁一样一直等到该方法执行完成，才由JVM从等待队列中选择一个线程来执行，是非阻塞的。在多线程中的累加操作时可以使用atomic变量来实现；</p></blockquote><p>tools下的并发工具类：主要用于线程的同步</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291262574.png" alt="1566291262574"></p><p>闭锁：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291338890.png" alt="1566291338890"></p><p>TA主线程，事件T123，引入CountDownLatch后，主线程就陷入等待，并有一个计数器cnt（事件的个数），每一个事件执行countDown()方法后就减一，直到所有子线程（事件）执行完毕，cnt为0时，主线程重新进入执行状态。</p><blockquote><p>注：这里的子线程在执行完countDown()方法会可以继续执行</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567217338361.png" alt="1567217338361"></p><p>栅栏：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291397783.png" alt="1566291397783"></p><p>线程T123每调用一次await()方法时，其中的计数器都会减一，只要计数器不为0，该线程都会阻塞，其中TA线程（当前线程）会和T123一起，在计数器为0时同时执行。</p><blockquote><p>这里的子线程到达栅栏处便会等待，不可继续执行。</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567217754584.png" alt="1567217754584"></p><p>信号量：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291447240.png" alt="1566291447240"></p><blockquote><p>通过acquire去获取一个许可，没有就等待；拥有资源的线程执行完后会release释放资源</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567217900626.png" alt="1567217900626"></p><p>交换器：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291480921.png" alt="1566291480921"></p><blockquote><p>提供一个同步点，在这个同步点，两个线程会彼此交换数据。一个线程先到同步点会被阻塞，直到李刚一个线程也到该同步点。只能用于两个线程。</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567218127016.png" alt="1567218127016"></p><p>会发现男孩女孩说的话被交换了：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567218139507.png" alt="1567218139507"></p><h3 id="JUC：BlockingQueue阻塞队列"><a href="#JUC：BlockingQueue阻塞队列" class="headerlink" title="JUC：BlockingQueue阻塞队列"></a>JUC：BlockingQueue阻塞队列</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291534420.png" alt="1566291534420"></p><blockquote><p>如果队列满了，入队操作将阻塞，如果队列空了，出队操作将阻塞</p><p>方法：boolean add()：队尾添加元素方法，满了报异常；offer()队尾添加怨怒，满了返回false，或者添加等待时间；put()队尾添加元素，满了就阻塞一直等待到可添加；</p><p>E take()：头部取出元素，为空就一直等待队列中有元素；poll()头部取元素，为空可设置等待时间，或返回false；</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291576395.png" alt="1566291576395"></p><p>以下七个实现，均线程安全：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/%E5%89%91%E6%8C%87Java%5C1566291602923.png" alt="1566291602923"></p><blockquote><p>有边界是指容量有限，初始化时要指定大小；1，2先进先出；3按照优先级（元素具备可比性）</p></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567219162671.png" alt="1567219162671"></p><p>基于流模型实现的，标志着其交互方式是基于同步阻塞方式，在读取输入流或写入输出流时，在读写操作完成前，线程会一直阻塞住，这之间的调用是可靠的线性操作；程序发送请求到内核，由内核进行通信，在内核准备好之前，该程序是被挂起的，所以在两个阶段程序都是挂起状态；</p><p>类比于C/S模式：一个连接一个线程；即客户端有连接请求时，服务端就要启动一个线程来处理，待操作系统返回结果，如果这个连接不做任何事，则会造成不必要的线程开销，可以通过线程池机制来改善。BIO的特点就是在IO执行的两个阶段都被阻塞住。</p><h4 id="NIO-Java4引入"><a href="#NIO-Java4引入" class="headerlink" title="NIO-Java4引入"></a>NIO-Java4引入</h4><p>构建多路复用、同步非阻塞的IO操作；提供了channel、select、buffer等新的抽象可以构建多路复用、同步非阻塞的IO操作，提供更接近操作系统底层的数据操作方式。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567219610645.png" alt="1567219610645"></p><p>特点是：在程序发起第一次请求时，线程并没有被阻塞，会反复检查数据有没有准备好，将原来大块阻塞不能用的时间分为小块的阻塞时间，有点类似于轮询，会有机会去执行。</p><p>类比C/S模式为：一个请求一个线程，客户端发送的请求会被注册到多路复用器上，多路复用器轮询到连接有IO请求时，才会启动一个线程处理；特点就是程序会询问内核数据有没有准备好，该阶段是非阻塞的，在后一阶段是阻塞的（数据拷贝）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567219995578.png" alt="1567219995578"></p><p>基本所有的IO在NIO中都从Channel开始，有点像流，数据可以从Channel读到Buffer中（反过来亦可）；</p><p>Channel有如下：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567223433011.png" alt="1567223433011"></p><p>FileChannel的两个方法：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567223087988.png" alt="1567223087988"></p><p>常用于：高效的网络文件的数据传输，和大文件拷贝，避免了将文件从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，避免了两次用户态和内核态的切换。</p><p>Buffers有如下：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567223415859.png" alt="1567223415859"></p><p>Selector：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567223507533.png" alt="1567223507533"></p><p>Selector允许单线程处理多个Channel，如果你的应用打开了多个连接（通道），每个连接的流量都很低，就可以使用selector。图示为一个单线程使用一个selector来处理3个channel的情形；使用selector得向selector注册channel，然后调用它的selector方法，这方法会一直阻塞直到某个注册的channel有事件就绪，一旦这个方法返回，线程就可以返回处理这些事件了，事件可以是有新的连接进来或者buffer里有数据可以读取等等。</p><p>selector源码：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224057240.png" alt="1567224057240"></p><p>Selector组件是由SelectorProvider创建的，底层根据不同操作系统的IO多路复用来实现，会返回PollSelectorProvider（others）、EPollSelectorProvider（Linux）等</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224328096.png" alt="1567224328096"></p><p>单线程可以处理多个网络IO，IO多路复用调用系统级别的select/poll/epoll模型，由系统监控IO状态，select轮询可以监控多个IO请求，当有一个准备好时，就可以返回。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224757594.png" alt="1567224757594"></p><blockquote><p>select连接是有限的，因为是基于数组的</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224860983.png" alt="1567224860983"></p><blockquote><p>FD：文件唯一标识符</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224929810.png" alt="1567224929810"></p><h4 id="AIO：异步非阻塞IO"><a href="#AIO：异步非阻塞IO" class="headerlink" title="AIO：异步非阻塞IO"></a>AIO：异步非阻塞IO</h4><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567224985271.png" alt="1567224985271"></p><p>应用操作直接返回，而不会阻塞在那里，当后台完成，操作系统就会通知响应线程进行后续操作。AIO属于异步模型，用户线程可以同时处理别的事务。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567225187685.png" alt="1567225187685"></p><blockquote><p>基于回调：实现接口，调用时把回调函数传给对应的API即可</p><p>返回Future：处理完一个事，通过isDone()方法查看是否已经准备好数据</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567226204994.png" alt="1567226204994"></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>家族图谱</p><p>第一阶段Spring Core、Spring Security、Spring Data，实现将单体应用开发服务好。不仅仅提供的便捷的数据库访问，web 中SpringMVC等必要功能。使用IOC、AOP实现应用低耦合、可扩展。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567131737917.png" alt="1567131737917"></p><blockquote><p>利用工厂模式（DI）和代理模式（AOP）来解耦应用组件，然后实现了web应用的框架（SpringMVC）;</p></blockquote><p>第二阶段推出的SpringBoot不仅仅提高了开发效率，而且将程序由可用变为好用。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132198944.png" alt="1567132198944"></p><p>第三阶段的Spring Cloud，推动了微服务架构的落地</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132290549.png" alt="1567132290549"></p><p>第四阶段：Spring Cloud DataFlow</p><p>DataFlow将实时消息的处理任务和临时运行的任务都作为组件处理，定义这样组件的交互。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132348627.png" alt="1567132348627"></p><h3 id="SpringIOC"><a href="#SpringIOC" class="headerlink" title="SpringIOC"></a>SpringIOC</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132527700.png" alt="1567132527700"></p><p>IOC是一种思想，使我们从繁琐的对象交互中解脱出来，进而专注于对象本身，更进一步了解面向对对象。</p><p>一般的设计思路：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132665135.png" alt="1567132665135"></p><blockquote><p>先设计轮子，根据轮子设计底盘，根据底盘设计箱体…</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567132802864.png" alt="1567132802864"></p><blockquote><p>这里每个类的构造函数都直接调用了底层代码的构造函数，这样底层需求变动时会影响整个上层的代码，是不可取的。</p></blockquote><p>依赖注入的是思路</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567133056969.png" alt="1567133056969"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567133089064.png" alt="1567133089064"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567133141092.png" alt="1567133141092"></p><ul><li>set：实现特定属性的public set()方法，让IOC容器注入所依赖类型的对象</li><li>接口：实现特定接口，让IOC容器注入所依赖类型的对象</li><li>构造函数：实现特定参数的构造函数，实现在创建对象时让IOC容器注入所依赖类型的对象</li><li>注解：通过Java的注解机制，让IOC容器注入所依赖类型的对象</li></ul><h4 id="依赖倒置原则、IOC、DI、IOC容器的关系"><a href="#依赖倒置原则、IOC、DI、IOC容器的关系" class="headerlink" title="依赖倒置原则、IOC、DI、IOC容器的关系"></a>依赖倒置原则、IOC、DI、IOC容器的关系</h4><p><strong>什么是依赖倒置原则？</strong>假设我们设计行李箱：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计箱体，最后根据箱体设计好整个箱子。这里就出现了一个“依赖”关系：箱子依赖箱体，箱体依赖底盘，底盘依赖轮子。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567133889794.png" alt="1567133889794"></p><p>上面的依赖关系是该原则所反对的，该原则的思想为高层模块不应该依赖与底层模块，两者都应该依赖于其抽象。</p><blockquote><p>依赖倒置原则思想的指导才有了IOC的思路，有了IOC的思路则需要DI方法的支撑。Spring框架基于IOC才提出了容器的概念，容器管理着Bean的生命周期，控制着Bean的依赖注入。</p></blockquote><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。这几种概念的关系大概如下：</p><p><img src="https://pic1.zhimg.com/80/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt="img"></p><p>那什么是<strong>控制反转容器(IoC Container)</strong>呢？对行李箱类进行初始化的那段代码发生的地方，就是控制反转容器。</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567134047279.png" alt="1567134047279"></p><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<strong>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化行李箱都要亲手去写那一大段初始化的代码</strong>。这是引入IoC Container的第一个好处。</p><p><strong>IOC的优势：</strong></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567134582679.png" alt="1567134582679"></p><p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567134623398.png" alt="1567134623398"></p><p>我们就像是工厂的客户。我们只需要向工厂请求一个Luggage实例，然后它就给我们按照Config创建了一个Luggage实例。我们完全不用管这个Luggage实例是怎么一步一步被创建出来。</p><h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p>实际Spring IOC容器是怎么实现对象的创建和依赖的：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567135465808.png" alt="1567135465808"></p><p>1、Spring启动时读取应用程序提供的Bean配置信息，并在容器生成一份相应的Bean配置注册表</p><p>2、根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系</p><blockquote><p>这里利用的是Java语言的反射功能实例化bean、并建立Bean之间的依赖关系</p></blockquote><p>3、将这些准备就绪的Bean放到Map缓存池中，为上层提供就绪的运行环境，等待应用程序执行调用</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567135556369.png" alt="1567135556369"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567135577177.png" alt="1567135577177"></p><blockquote><p>Spring 作者设计这两个核心接口用以表示容器</p></blockquote><p>相关接口：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567134859951.png" alt="1567134859951"></p><blockquote><p>Spring容器在启动时会将xml或者注解里的Bean的定义解析为Spring内部的BeanDefinition</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567134968136.png" alt="1567134968136"></p><blockquote><p>Spring 将Bean的定义解析为BeanDefinition后会通过BeanDefinitionRegistry 以BeanName为key，BeanDefinition为value存储到BeanDefinitionMap （这是个ConcurrentHashMap类型的map结构）中。</p></blockquote><h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><h5 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h5><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567135018588.png" alt="1567135018588"></p><blockquote><p>包含Bean的各种定义，以便在接收客户端请求时可以实例化Bean，并在实例化对象时建立Bean 之间的依赖关系，这将使Bean从Bean客户端中解放出来。</p></blockquote><p>BeanFactory源码：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567137963853.png" alt="1567137963853"></p><blockquote><p>各种getBean()方法，可以看到可以从Spring中按类型 / 按名称获取Bean</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567138042701.png" alt="1567138042701"></p><blockquote><p>判断是否为单例方法，SpringIOC中，默认Bean都是以单例存在的</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567138130281.png" alt="1567138130281"></p><blockquote><p>与上面相反，判断为多例的</p></blockquote><h5 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h5><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567138269117.png" alt="1567138269117"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567138332244.png" alt="1567138332244"></p><blockquote><p>3表示可以管理message，4表示可以发布实事件给监听器，实现监听</p><p>可以看出这不单单是个工厂，是整个应用上下文，代表整个大容器的所有功能</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567138744314.png" alt="1567138744314"></p><blockquote><p>SpringBoot的自带启动类的run()方法，深入进去其最终会执行createApplicationContext()方法，会发现其会用Class.forName加载AnnotationConfigServleWebServerApplicationContext类。</p></blockquote><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="Bean装载案例："><a href="#Bean装载案例：" class="headerlink" title="Bean装载案例："></a>Bean装载案例：</h5><p>Person Bean：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567139561022.png" alt="1567139561022"></p><blockquote><p>扫描装配Bean，使用注解@Component（指定要扫描的类进入IOC容器中）@Value()是赋值</p></blockquote><p>启动类：</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567139336948.png" alt="1567139336948"></p><blockquote><p>@SpringBootApplication注解包含了启动扫描的功能。</p></blockquote><h5 id="Bean依赖注入案例："><a href="#Bean依赖注入案例：" class="headerlink" title="Bean依赖注入案例："></a>Bean依赖注入案例：</h5><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567139966763.png" alt="1567139966763"></p><blockquote><p>装载Dog 类进入IOC容器</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567139981229.png" alt="1567139981229"></p><blockquote><p>注入Pet（Pet是个接口），@Autowired会根据属性类型找到对应的Bean进行注入（最基本是用getBean()方法根据类型注入），这里的Dog类是Pet的一种实现，所以会根据类型查找到Dog，由SpringIOC容器将Dog的实例注入Person中。</p><p>当有多个Pet的实现时（例如还有Cat、Bird类），需要在要注入的类上加上@Primary注解。</p></blockquote><h4 id="getBean-解析"><a href="#getBean-解析" class="headerlink" title="getBean()解析"></a>getBean()解析</h4><p>会调用doGetBean()放法；</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141357464.png" alt="1567141357464"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141421420.png" alt="1567141421420"></p><blockquote><p>1、先获取Bean名称beanName；2、获取一个（共享的）实例；3、试着从缓存或者实例工厂中获取实例；</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141491889.png" alt="1567141491889"></p><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141574312.png" alt="1567141574312"></p><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141612844.png" alt="1567141612844"></p><blockquote><p>1、实例化Bean对象以及设置属性</p><p>2、 对 Aware 接口的实现，目的是在Bean中设置对IOC容器的感知</p><p>3、Bean的前置初始化方法，对Spring容器完成实例化的Bean添加自定义的处理逻辑</p><p>4、…   5、…</p><p>6、Bena的后置初始化方法，Bean实例初始化后的自定义工作，3、6和AOP相关</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567141729918.png" alt="1567141729918"></p><h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567142579843.png" alt="1567142579843"></p><p>分类与合并（织入）</p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567142610000.png" alt="1567142610000"></p><blockquote><p>Spring 采用的方式不需要特殊的Java编译器，但性能开销多一些</p></blockquote><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567143238161.png" alt="1567143238161"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567143257267.png" alt="1567143257267"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567143313889.png" alt="1567143313889"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567143353134.png" alt="1567143353134"></p><p><img src="/2019/08/26/%E5%89%91%E6%8C%87Java/1567144837023.png" alt="1567144837023"></p>]]></content>
      
      
      <categories>
          
          <category> 面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
